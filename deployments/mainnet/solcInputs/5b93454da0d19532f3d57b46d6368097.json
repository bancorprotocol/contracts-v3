{
  "language": "Solidity",
  "sources": {
    "contracts/bancor-portal/BancorPortal.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IUniswapV2Pair } from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport { IUniswapV2Factory } from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport { IUniswapV2Router02 } from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils } from \"../utility/Utils.sol\";\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\n\nimport { IBancorPortal, UniswapV2PositionMigration } from \"./interfaces/IBancorPortal.sol\";\n\nstruct MigrationResult {\n    IUniswapV2Pair pair;\n    Token tokenA;\n    Token tokenB;\n    uint256 amountA;\n    uint256 amountB;\n    bool depositedA;\n    bool depositedB;\n}\n\n/**\n * @dev one click liquidity migration between other DEXes into Bancor v3\n */\ncontract BancorPortal is IBancorPortal, ReentrancyGuardUpgradeable, Utils, Upgradeable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IPoolToken;\n    using TokenLibrary for Token;\n    using Address for address payable;\n\n    uint32 private constant MAX_DEADLINE = 10800;\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the bnt contract\n    IERC20 private immutable _bnt;\n\n    // Uniswap v2 router contract\n    IUniswapV2Router02 private immutable _uniswapV2Router;\n\n    // Uniswap v2 factory contract\n    IUniswapV2Factory private immutable _uniswapV2Factory;\n\n    // SushiSwap v2 router contract\n    IUniswapV2Router02 private immutable _sushiSwapV2Router;\n\n    // SushiSwap v2 factory contract\n    IUniswapV2Factory private immutable _sushiSwapV2Factory;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 0] private __gap;\n\n    /**\n     * @dev triggered after a successful Uniswap V2 migration\n     */\n    event UniswapV2PositionMigrated(\n        address indexed provider,\n        IUniswapV2Pair poolToken,\n        Token indexed tokenA,\n        Token indexed tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        bool depositedA,\n        bool depositedB\n    );\n\n    /**\n     * @dev triggered after a successful SushiSwap V1 migration\n     */\n    event SushiSwapV2PositionMigrated(\n        address indexed provider,\n        IUniswapV2Pair poolToken,\n        Token indexed tokenA,\n        Token indexed tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        bool depositedA,\n        bool depositedB\n    );\n\n    error UnsupportedTokens();\n    error NoPairForTokens();\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork network,\n        INetworkSettings networkSettings,\n        IERC20 bnt,\n        IUniswapV2Router02 uniswapV2Router,\n        IUniswapV2Factory uniswapV2Factory,\n        IUniswapV2Router02 sushiSwapV2Router,\n        IUniswapV2Factory sushiSwapV2Factory\n    )\n        validAddress(address(network))\n        validAddress(address(networkSettings))\n        validAddress(address(bnt))\n        validAddress(address(uniswapV2Router))\n        validAddress(address(uniswapV2Factory))\n        validAddress(address(sushiSwapV2Router))\n        validAddress(address(sushiSwapV2Factory))\n    {\n        _network = network;\n        _networkSettings = networkSettings;\n        _bnt = bnt;\n        _uniswapV2Router = uniswapV2Router;\n        _uniswapV2Factory = uniswapV2Factory;\n        _sushiSwapV2Router = sushiSwapV2Router;\n        _sushiSwapV2Factory = sushiSwapV2Factory;\n    }\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __BancorPortal_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __BancorPortal_init() internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __Upgradeable_init();\n\n        __BancorPortal_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __BancorPortal_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @dev authorize the contract to receive the native token\n     */\n    receive() external payable {}\n\n    /**\n     * @inheritdoc IBancorPortal\n     */\n    function migrateUniswapV2Position(\n        Token token0,\n        Token token1,\n        uint256 poolTokenAmount\n    )\n        external\n        nonReentrant\n        validAddress(address(token0))\n        validAddress(address(token1))\n        greaterThanZero(poolTokenAmount)\n        returns (UniswapV2PositionMigration memory)\n    {\n        MigrationResult memory res = _migrateUniswapV2Position(\n            _uniswapV2Router,\n            _uniswapV2Factory,\n            token0,\n            token1,\n            poolTokenAmount,\n            msg.sender\n        );\n\n        emit UniswapV2PositionMigrated({\n            provider: msg.sender,\n            poolToken: res.pair,\n            tokenA: res.tokenA,\n            tokenB: res.tokenB,\n            amountA: res.amountA,\n            amountB: res.amountB,\n            depositedA: res.depositedA,\n            depositedB: res.depositedB\n        });\n\n        return UniswapV2PositionMigration({ amountA: res.amountA, amountB: res.amountB });\n    }\n\n    /**\n     * @inheritdoc IBancorPortal\n     */\n    function migrateSushiSwapV1Position(\n        Token token0,\n        Token token1,\n        uint256 poolTokenAmount\n    )\n        external\n        nonReentrant\n        validAddress(address(token0))\n        validAddress(address(token1))\n        greaterThanZero(poolTokenAmount)\n        returns (UniswapV2PositionMigration memory)\n    {\n        MigrationResult memory res = _migrateUniswapV2Position(\n            _sushiSwapV2Router,\n            _sushiSwapV2Factory,\n            token0,\n            token1,\n            poolTokenAmount,\n            msg.sender\n        );\n\n        emit SushiSwapV2PositionMigrated({\n            provider: msg.sender,\n            poolToken: res.pair,\n            tokenA: res.tokenA,\n            tokenB: res.tokenB,\n            amountA: res.amountA,\n            amountB: res.amountB,\n            depositedA: res.depositedA,\n            depositedB: res.depositedB\n        });\n\n        return UniswapV2PositionMigration({ amountA: res.amountA, amountB: res.amountB });\n    }\n\n    /**\n     * @dev migrates funds from a Uniswap V2 pair into a Bancor V3 pool\n     * - unsupported tokens will be transferred to the caller\n     *\n     * requirements:\n     *\n     * - the caller must have approved the pair to transfer the liquidity on its behalf\n     */\n    function _migrateUniswapV2Position(\n        IUniswapV2Router02 router,\n        IUniswapV2Factory factory,\n        Token token0,\n        Token token1,\n        uint256 poolTokenAmount,\n        address provider\n    ) private returns (MigrationResult memory) {\n        // get Uniswap's pair\n        address pairAddress = factory.getPair(address(token0), address(token1));\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n        if (address(pair) == address(0)) {\n            revert NoPairForTokens();\n        }\n\n        // transfer the tokens from the caller\n        Token(address(pair)).safeTransferFrom(provider, address(this), poolTokenAmount);\n\n        // arrange tokens in an array\n        Token[2] memory tokens = [token0, token1];\n\n        // look for relevant whitelisted pools, revert if there are none\n        bool[2] memory whitelist;\n        for (uint256 i = 0; i < 2; i++) {\n            whitelist[i] = tokens[i].isEqual(_bnt) || _networkSettings.isTokenWhitelisted(tokens[i]);\n        }\n        if (!whitelist[0] && !whitelist[1]) {\n            revert UnsupportedTokens();\n        }\n\n        // save states\n        uint256[2] memory previousBalances = [tokens[0].balanceOf(address(this)), tokens[1].balanceOf(address(this))];\n\n        // remove liquidity from Uniswap\n        _uniV2RemoveLiquidity(tokens, pair, router, poolTokenAmount);\n\n        // migrate funds\n        uint256[2] memory deposited;\n\n        for (uint256 i = 0; i < 2; i++) {\n            uint256 delta = tokens[i].balanceOf(address(this)) - previousBalances[i];\n            if (whitelist[i]) {\n                deposited[i] = delta;\n                _deposit(tokens[i], deposited[i], provider);\n            } else {\n                _transferToProvider(tokens[i], delta, provider);\n            }\n        }\n\n        return\n            MigrationResult({\n                pair: pair,\n                tokenA: tokens[0],\n                tokenB: tokens[1],\n                amountA: deposited[0],\n                amountB: deposited[1],\n                depositedA: whitelist[0],\n                depositedB: whitelist[1]\n            });\n    }\n\n    /**\n     * @dev deposits given amount into a pool of given token\n     */\n    function _deposit(\n        Token token,\n        uint256 amount,\n        address provider\n    ) private {\n        if (token.isNative()) {\n            _network.depositFor{ value: amount }(provider, token, amount);\n        } else {\n            token.toIERC20().safeApprove(address(_network), amount);\n            _network.depositFor(provider, token, amount);\n        }\n    }\n\n    /**\n     * @dev transfer given amount of given token to the caller\n     */\n    function _transferToProvider(\n        Token token,\n        uint256 amount,\n        address provider\n    ) private {\n        if (token.isNative()) {\n            payable(provider).sendValue(amount);\n        } else {\n            token.toIERC20().safeTransfer(provider, amount);\n        }\n    }\n\n    /**\n     * @dev removes liquidity from Uniswap's pair, transfer funds to self\n     */\n    function _uniV2RemoveLiquidity(\n        Token[2] memory tokens,\n        IUniswapV2Pair pair,\n        IUniswapV2Router02 router,\n        uint256 poolTokenAmount\n    ) private {\n        IERC20(address(pair)).safeApprove(address(router), poolTokenAmount);\n\n        uint256 deadline = block.timestamp + MAX_DEADLINE;\n        if (tokens[0].isNative()) {\n            router.removeLiquidityETH(address(tokens[1]), poolTokenAmount, 1, 1, address(this), deadline);\n        } else if (tokens[1].isNative()) {\n            router.removeLiquidityETH(address(tokens[0]), poolTokenAmount, 1, 1, address(this), deadline);\n        } else {\n            router.removeLiquidity(\n                address(tokens[0]),\n                address(tokens[1]),\n                poolTokenAmount,\n                1,\n                1,\n                address(this),\n                deadline\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/token/Token.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\n/**\n * @dev the main purpose of the Token interfaces is to ensure artificially that we won't use ERC20's standard functions,\n * but only their safe versions, which are provided by SafeERC20 and SafeERC20Ex via the TokenLibrary contract\n */\ninterface Token {\n\n}\n"
    },
    "contracts/token/TokenLibrary.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport { SafeERC20Ex } from \"./SafeERC20Ex.sol\";\n\nimport { Token } from \"./Token.sol\";\n\nstruct Signature {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/**\n * @dev This library implements ERC20 and SafeERC20 utilities for both the native token and for ERC20 tokens\n */\nlibrary TokenLibrary {\n    using SafeERC20 for IERC20;\n    using SafeERC20Ex for IERC20;\n\n    error PermitUnsupported();\n\n    // the address that represents the native token reserve\n    address public constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // the symbol that represents the native token\n    string private constant NATIVE_TOKEN_SYMBOL = \"ETH\";\n\n    // the decimals for the native token\n    uint8 private constant NATIVE_TOKEN_DECIMALS = 18;\n\n    /**\n     * @dev returns whether the provided token represents an ERC20 or the native token reserve\n     */\n    function isNative(Token token) internal pure returns (bool) {\n        return address(token) == NATIVE_TOKEN_ADDRESS;\n    }\n\n    /**\n     * @dev returns the symbol of the native token/ERC20 token\n     */\n    function symbol(Token token) internal view returns (string memory) {\n        if (isNative(token)) {\n            return NATIVE_TOKEN_SYMBOL;\n        }\n\n        return toERC20(token).symbol();\n    }\n\n    /**\n     * @dev returns the decimals of the native token/ERC20 token\n     */\n    function decimals(Token token) internal view returns (uint8) {\n        if (isNative(token)) {\n            return NATIVE_TOKEN_DECIMALS;\n        }\n\n        return toERC20(token).decimals();\n    }\n\n    /**\n     * @dev returns the balance of the native token/ERC20 token\n     */\n    function balanceOf(Token token, address account) internal view returns (uint256) {\n        if (isNative(token)) {\n            return account.balance;\n        }\n\n        return toIERC20(token).balanceOf(account);\n    }\n\n    /**\n     * @dev transfers a specific amount of the native token/ERC20 token\n     */\n    function safeTransfer(\n        Token token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isNative(token)) {\n            payable(to).transfer(amount);\n        } else {\n            toIERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev transfers a specific amount of the native token/ERC20 token from a specific holder using the allowance mechanism\n     *\n     * note that the function does not perform any action if the native token is provided\n     */\n    function safeTransferFrom(\n        Token token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0 || isNative(token)) {\n            return;\n        }\n\n        toIERC20(token).safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev approves a specific amount of the native token/ERC20 token from a specific holder\n     *\n     * note that the function does not perform any action if the native token is provided\n     */\n    function safeApprove(\n        Token token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNative(token)) {\n            return;\n        }\n\n        toIERC20(token).safeApprove(spender, amount);\n    }\n\n    /**\n     * @dev ensures that the spender has sufficient allowance\n     *\n     * note that the function does not perform any action if the native token is provided\n     */\n    function ensureApprove(\n        Token token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNative(token)) {\n            return;\n        }\n\n        toIERC20(token).ensureApprove(spender, amount);\n    }\n\n    /**\n     * @dev performs an EIP2612 permit\n     */\n    function permit(\n        Token token,\n        address owner,\n        address spender,\n        uint256 tokenAmount,\n        uint256 deadline,\n        Signature memory signature\n    ) internal {\n        if (isNative(token)) {\n            revert PermitUnsupported();\n        }\n\n        // permit the amount the owner is trying to deposit. Please note, that if the base token doesn't support\n        // EIP2612 permit - either this call or the inner safeTransferFrom will revert\n        IERC20Permit(address(token)).permit(\n            owner,\n            spender,\n            tokenAmount,\n            deadline,\n            signature.v,\n            signature.r,\n            signature.s\n        );\n    }\n\n    /**\n     * @dev compares between a token and another raw ERC20 token\n     */\n    function isEqual(Token token, IERC20 erc20Token) internal pure returns (bool) {\n        return toIERC20(token) == erc20Token;\n    }\n\n    /**\n     * @dev utility function that converts an token to an IERC20\n     */\n    function toIERC20(Token token) internal pure returns (IERC20) {\n        return IERC20(address(token));\n    }\n\n    /**\n     * @dev utility function that converts an token to an ERC20\n     */\n    function toERC20(Token token) internal pure returns (ERC20) {\n        return ERC20(address(token));\n    }\n}\n"
    },
    "contracts/utility/interfaces/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\n/**\n * @dev an interface for a versioned contract\n */\ninterface IVersioned {\n    function version() external view returns (uint16);\n}\n"
    },
    "contracts/utility/Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { AccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport { IUpgradeable } from \"./interfaces/IUpgradeable.sol\";\n\nimport { AccessDenied } from \"./Utils.sol\";\n\n/**\n * @dev this contract provides common utilities for upgradeable contracts\n */\nabstract contract Upgradeable is IUpgradeable, AccessControlEnumerableUpgradeable {\n    error AlreadyInitialized();\n\n    // the admin role is used to allow a non-proxy admin to perform additional initialization/setup during contract\n    // upgrades\n    bytes32 internal constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n\n    uint32 internal constant MAX_GAP = 50;\n\n    uint16 internal _initializations;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 1] private __gap;\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __Upgradeable_init() internal onlyInitializing {\n        __AccessControl_init();\n\n        __Upgradeable_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __Upgradeable_init_unchained() internal onlyInitializing {\n        _initializations = 1;\n\n        // set up administrative roles\n        _setRoleAdmin(ROLE_ADMIN, ROLE_ADMIN);\n\n        // allow the deployer to initially be the admin of the contract\n        _setupRole(ROLE_ADMIN, msg.sender);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    modifier onlyAdmin() {\n        _hasRole(ROLE_ADMIN, msg.sender);\n\n        _;\n    }\n\n    modifier onlyRoleMember(bytes32 role) {\n        _hasRole(role, msg.sender);\n\n        _;\n    }\n\n    function version() public view virtual override returns (uint16);\n\n    /**\n     * @dev returns the admin role\n     */\n    function roleAdmin() external pure returns (bytes32) {\n        return ROLE_ADMIN;\n    }\n\n    /**\n     * @dev performs post-upgrade initialization\n     *\n     * requirements:\n     *\n     * - this must can be called only once per-upgrade\n     */\n    function postUpgrade(bytes calldata data) external {\n        uint16 initializations = _initializations + 1;\n\n        if (initializations != version()) {\n            revert AlreadyInitialized();\n        }\n\n        _initializations = initializations;\n\n        _postUpgrade(data);\n    }\n\n    /**\n     * @dev an optional post-upgrade callback that can be implemented by child contracts\n     */\n    function _postUpgrade(\n        bytes calldata /* data */\n    ) internal virtual {}\n\n    function _hasRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert AccessDenied();\n        }\n    }\n}\n"
    },
    "contracts/utility/Utils.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { PPM_RESOLUTION } from \"./Constants.sol\";\n\nerror AccessDenied();\nerror AlreadyExists();\nerror DoesNotExist();\nerror InvalidAddress();\nerror InvalidExternalAddress();\nerror InvalidFee();\nerror InvalidPool();\nerror InvalidPoolCollection();\nerror InvalidStakedBalance();\nerror InvalidToken();\nerror InvalidType();\nerror InvalidParam();\nerror NotEmpty();\nerror NotPayable();\nerror ZeroValue();\n\n/**\n * @dev common utilities\n */\ncontract Utils {\n    // allows execution by the caller only\n    modifier only(address caller) {\n        _only(caller);\n\n        _;\n    }\n\n    function _only(address caller) internal view {\n        if (msg.sender != caller) {\n            revert AccessDenied();\n        }\n    }\n\n    // verifies that a value is greater than zero\n    modifier greaterThanZero(uint256 value) {\n        _greaterThanZero(value);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _greaterThanZero(uint256 value) internal pure {\n        if (value == 0) {\n            revert ZeroValue();\n        }\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address addr) {\n        _validAddress(addr);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _validAddress(address addr) internal pure {\n        if (addr == address(0)) {\n            revert InvalidAddress();\n        }\n    }\n\n    // validates an external address - currently only checks that it isn't null or this\n    modifier validExternalAddress(address addr) {\n        _validExternalAddress(addr);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _validExternalAddress(address addr) internal view {\n        if (addr == address(0) || addr == address(this)) {\n            revert InvalidExternalAddress();\n        }\n    }\n\n    // ensures that the fee is valid\n    modifier validFee(uint32 fee) {\n        _validFee(fee);\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _validFee(uint32 fee) internal pure {\n        if (fee > PPM_RESOLUTION) {\n            revert InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/network/interfaces/IBancorNetwork.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IPoolCollection } from \"../../pools/interfaces/IPoolCollection.sol\";\nimport { IPoolToken } from \"../../pools/interfaces/IPoolToken.sol\";\n\n/**\n * @dev Flash-loan recipient interface\n */\ninterface IFlashLoanRecipient {\n    /**\n     * @dev a flash-loan recipient callback after each the caller must return the borrowed amount and an additional fee\n     */\n    function onFlashLoan(\n        address caller,\n        IERC20 erc20Token,\n        uint256 amount,\n        uint256 feeAmount,\n        bytes memory data\n    ) external;\n}\n\n/**\n * @dev Bancor Network interface\n */\ninterface IBancorNetwork is IUpgradeable {\n    /**\n     * @dev returns the set of all valid pool collections\n     */\n    function poolCollections() external view returns (IPoolCollection[] memory);\n\n    /**\n     * @dev returns the most recent collection that was added to the pool collections set for a specific type\n     */\n    function latestPoolCollection(uint16 poolType) external view returns (IPoolCollection);\n\n    /**\n     * @dev returns the set of all liquidity pools\n     */\n    function liquidityPools() external view returns (Token[] memory);\n\n    /**\n     * @dev returns the respective pool collection for the provided pool\n     */\n    function collectionByPool(Token pool) external view returns (IPoolCollection);\n\n    /**\n     * @dev returns whether the pool is valid\n     */\n    function isPoolValid(Token pool) external view returns (bool);\n\n    /**\n     * @dev creates a new pool\n     *\n     * requirements:\n     *\n     * - the pool doesn't already exist\n     */\n    function createPool(uint16 poolType, Token token) external;\n\n    /**\n     * @dev creates new pools\n     *\n     * requirements:\n     *\n     * - none of the pools already exists\n     */\n    function createPools(uint16 poolType, Token[] calldata tokens) external;\n\n    /**\n     * @dev migrates a list of pools between pool collections\n     *\n     * notes:\n     *\n     * - invalid or incompatible pools will be skipped gracefully\n     */\n    function migratePools(Token[] calldata pools) external;\n\n    /**\n     * @dev deposits liquidity for the specified provider and returns the respective pool token amount\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer the tokens on its behalf (except for in the\n     *   native token case)\n     */\n    function depositFor(\n        address provider,\n        Token pool,\n        uint256 tokenAmount\n    ) external payable returns (uint256);\n\n    /**\n     * @dev deposits liquidity for the current provider and returns the respective pool token amount\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer the tokens on its behalf (except for in the\n     *   native token case)\n     */\n    function deposit(Token pool, uint256 tokenAmount) external payable returns (uint256);\n\n    /**\n     * @dev deposits liquidity for the specified provider by providing an EIP712 typed signature for an EIP2612 permit\n     * request and returns the respective pool token amount\n     *\n     * requirements:\n     *\n     * - the caller must have provided a valid and unused EIP712 typed signature\n     */\n    function depositForPermitted(\n        address provider,\n        Token pool,\n        uint256 tokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256);\n\n    /**\n     * @dev deposits liquidity by providing an EIP712 typed signature for an EIP2612 permit request and returns the\n     * respective pool token amount\n     *\n     * requirements:\n     *\n     * - the caller must have provided a valid and unused EIP712 typed signature\n     */\n    function depositPermitted(\n        Token pool,\n        uint256 tokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256);\n\n    /**\n     * @dev initiates liquidity withdrawal\n     *\n     * requirements:\n     *\n     * - the caller must have approved the contract to transfer the pool token amount on its behalf\n     */\n    function initWithdrawal(IPoolToken poolToken, uint256 poolTokenAmount) external returns (uint256);\n\n    /**\n     * @dev initiates liquidity withdrawal by providing an EIP712 typed signature for an EIP2612 permit request\n     *\n     * requirements:\n     *\n     * - the caller must have provided a valid and unused EIP712 typed signature\n     */\n    function initWithdrawalPermitted(\n        IPoolToken poolToken,\n        uint256 poolTokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256);\n\n    /**\n     * @dev cancels a withdrawal request\n     *\n     * requirements:\n     *\n     * - the caller must have already initiated a withdrawal and received the specified id\n     */\n    function cancelWithdrawal(uint256 id) external;\n\n    /**\n     * @dev withdraws liquidity and returns the withdrawn amount\n     *\n     * requirements:\n     *\n     * - the provider must have already initiated a withdrawal and received the specified id\n     * - the specified withdrawal request is eligible for completion\n     * - the provider must have approved the network to transfer VBNT amount on its behalf, when withdrawing BNT\n     * liquidity\n     */\n    function withdraw(uint256 id) external returns (uint256);\n\n    /**\n     * @dev performs a trade by providing the input source amount\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer the source tokens on its behalf (except for in the\n     *   native token case)\n     */\n    function tradeBySourceAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount,\n        uint256 deadline,\n        address beneficiary\n    ) external payable;\n\n    /**\n     * @dev performs a trade by providing the input source amount and providing an EIP712 typed signature for an\n     * EIP2612 permit request\n     *\n     * requirements:\n     *\n     * - the caller must have provided a valid and unused EIP712 typed signature\n     */\n    function tradeBySourceAmountPermitted(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount,\n        uint256 deadline,\n        address beneficiary,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev performs a trade by providing the output target amount\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer the source tokens on its behalf (except for in the\n     *   native token case)\n     */\n    function tradeByTargetAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount,\n        uint256 deadline,\n        address beneficiary\n    ) external payable;\n\n    /**\n     * @dev performs a trade by providing the output target amount and providing an EIP712 typed signature for an\n     * EIP2612 permit request and returns the target amount and fee\n     *\n     * requirements:\n     *\n     * - the caller must have provided a valid and unused EIP712 typed signature\n     */\n    function tradeByTargetAmountPermitted(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount,\n        uint256 deadline,\n        address beneficiary,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev provides a flash-loan\n     *\n     * requirements:\n     *\n     * - the recipient's callback must return *at least* the borrowed amount and fee back to the specified return address\n     */\n    function flashLoan(\n        Token token,\n        uint256 amount,\n        IFlashLoanRecipient recipient,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev deposits liquidity during a migration\n     */\n    function migrateLiquidity(\n        Token token,\n        address provider,\n        uint256 amount,\n        uint256 availableAmount,\n        uint256 originalAmount\n    ) external payable;\n\n    /**\n     * @dev withdraws pending network fees\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_NETWORK_FEE_MANAGER privilege\n     */\n    function withdrawNetworkFees(address recipient) external;\n}\n"
    },
    "contracts/network/interfaces/INetworkSettings.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\nerror NotWhitelisted();\n\nstruct VortexRewards {\n    // the percentage of converted BNT to be sent to the initiator of the burning event (in units of PPM)\n    uint32 burnRewardPPM;\n    // the maximum burn reward to be sent to the initiator of the burning event\n    uint256 burnRewardMaxAmount;\n}\n\n/**\n * @dev Network Settings interface\n */\ninterface INetworkSettings is IUpgradeable {\n    /**\n     * @dev returns the protected tokens whitelist\n     */\n    function protectedTokenWhitelist() external view returns (Token[] memory);\n\n    /**\n     * @dev checks whether a given token is whitelisted\n     */\n    function isTokenWhitelisted(Token pool) external view returns (bool);\n\n    /**\n     * @dev returns the BNT funding limit for a given pool\n     */\n    function poolFundingLimit(Token pool) external view returns (uint256);\n\n    /**\n     * @dev returns the minimum BNT trading liquidity required before the system enables trading in the relevant pool\n     */\n    function minLiquidityForTrading() external view returns (uint256);\n\n    /**\n     * @dev returns the global network fee (in units of PPM)\n     *\n     * notes:\n     *\n     * - the network fee is a portion of the total fees from each pool\n     */\n    function networkFeePPM() external view returns (uint32);\n\n    /**\n     * @dev returns the withdrawal fee (in units of PPM)\n     */\n    function withdrawalFeePPM() external view returns (uint32);\n\n    /**\n     * @dev returns the default flash-loan fee (in units of PPM)\n     */\n    function defaultFlashLoanFeePPM() external view returns (uint32);\n\n    /**\n     * @dev returns the flash-loan fee (in units of PPM) of a pool\n     */\n    function flashLoanFeePPM(Token pool) external view returns (uint32);\n\n    /**\n     * @dev returns the vortex settings\n     */\n    function vortexRewards() external view returns (VortexRewards memory);\n}\n"
    },
    "contracts/pools/interfaces/IPoolToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport { IERC20Burnable } from \"../../token/interfaces/IERC20Burnable.sol\";\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IVersioned } from \"../../utility/interfaces/IVersioned.sol\";\nimport { IOwned } from \"../../utility/interfaces/IOwned.sol\";\n\n/**\n * @dev Pool Token interface\n */\ninterface IPoolToken is IVersioned, IOwned, IERC20, IERC20Permit, IERC20Burnable {\n    /**\n     * @dev returns the address of the reserve token\n     */\n    function reserveToken() external view returns (Token);\n\n    /**\n     * @dev increases the token supply and sends the new tokens to the given account\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function mint(address recipient, uint256 amount) external;\n}\n"
    },
    "contracts/bancor-portal/interfaces/IBancorPortal.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\nimport { Token } from \"../../token/Token.sol\";\n\nstruct UniswapV2PositionMigration {\n    uint256 amountA;\n    uint256 amountB;\n}\n\ninterface IBancorPortal is IUpgradeable {\n    /**\n     * @dev migrates funds from a Uniswap v2 pair into a bancor v3 pool\n     * - unsupported tokens will be transferred to the caller.\n     *\n     * - returns the deposited amount for each token in the same order as stored in\n     *   Uniswap's pair, 0 for unsupported tokens.\n     *\n     * requirements:\n     *\n     * - the caller must have approved the pair to transfer the liquidity on its behalf\n     */\n    function migrateUniswapV2Position(\n        Token token0,\n        Token token1,\n        uint256 amount\n    ) external returns (UniswapV2PositionMigration memory);\n\n    /**\n     * @dev migrates funds from a SushiSwap v1 pair into a bancor v3 pool\n     * - unsupported tokens will be transferred to the caller.\n     *\n     * - returns the deposited amount for each token in the same order as stored in\n     *   SushiSwap's pair, 0 for unsupported tokens.\n     *\n     * requirements:\n     *\n     * - the caller must have approved the pair to transfer the liquidity on its behalf\n     */\n    function migrateSushiSwapV1Position(\n        Token token0,\n        Token token1,\n        uint256 amount\n    ) external returns (UniswapV2PositionMigration memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/token/SafeERC20Ex.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @dev extends the SafeERC20 library with additional operations\n */\nlibrary SafeERC20Ex {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev ensures that the spender has sufficient allowance\n     */\n    function ensureApprove(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        uint256 allowance = token.allowance(address(this), spender);\n        if (allowance >= amount) {\n            return;\n        }\n\n        if (allowance > 0) {\n            token.safeApprove(spender, 0);\n        }\n        token.safeApprove(spender, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/utility/interfaces/IUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IVersioned } from \"./IVersioned.sol\";\n\nimport { IAccessControlEnumerableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\n\n/**\n * @dev this is the common interface for upgradeable contracts\n */\ninterface IUpgradeable is IAccessControlEnumerableUpgradeable, IVersioned {\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/utility/Constants.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nuint32 constant PPM_RESOLUTION = 1000000;\n"
    },
    "contracts/pools/interfaces/IPoolCollection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IVersioned } from \"../../utility/interfaces/IVersioned.sol\";\nimport { Fraction112 } from \"../../utility/FractionLibrary.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IPoolToken } from \"./IPoolToken.sol\";\n\nstruct PoolLiquidity {\n    uint128 bntTradingLiquidity; // the BNT trading liquidity\n    uint128 baseTokenTradingLiquidity; // the base token trading liquidity\n    uint256 stakedBalance; // the staked balance\n}\n\nstruct AverageRate {\n    uint32 blockNumber;\n    Fraction112 rate;\n}\n\nstruct Pool {\n    IPoolToken poolToken; // the pool token of the pool\n    uint32 tradingFeePPM; // the trading fee (in units of PPM)\n    bool tradingEnabled; // whether trading is enabled\n    bool depositingEnabled; // whether depositing is enabled\n    AverageRate averageRate; // the recent average rate\n    uint256 depositLimit; // the deposit limit\n    PoolLiquidity liquidity; // the overall liquidity in the pool\n}\n\nstruct WithdrawalAmounts {\n    uint256 totalAmount;\n    uint256 baseTokenAmount;\n    uint256 bntAmount;\n}\n\n// trading enabling/disabling reasons\nuint8 constant TRADING_STATUS_UPDATE_DEFAULT = 0;\nuint8 constant TRADING_STATUS_UPDATE_ADMIN = 1;\nuint8 constant TRADING_STATUS_UPDATE_MIN_LIQUIDITY = 2;\n\nstruct TradeAmountAndFee {\n    uint256 amount; // the source/target amount (depending on the context) resulting from the trade\n    uint256 tradingFeeAmount; // the trading fee amount\n    uint256 networkFeeAmount; // the network fee amount (always in units of BNT)\n}\n\n/**\n * @dev Pool Collection interface\n */\ninterface IPoolCollection is IVersioned {\n    /**\n     * @dev returns the type of the pool\n     */\n    function poolType() external pure returns (uint16);\n\n    /**\n     * @dev returns the default trading fee (in units of PPM)\n     */\n    function defaultTradingFeePPM() external view returns (uint32);\n\n    /**\n     * @dev returns all the pools which are managed by this pool collection\n     */\n    function pools() external view returns (Token[] memory);\n\n    /**\n     * @dev returns the number of all the pools which are managed by this pool collection\n     */\n    function poolCount() external view returns (uint256);\n\n    /**\n     * @dev returns whether a pool is valid\n     */\n    function isPoolValid(Token pool) external view returns (bool);\n\n    /**\n     * @dev returns specific pool's data\n     */\n    function poolData(Token pool) external view returns (Pool memory);\n\n    /**\n     * @dev returns the overall liquidity in the pool\n     */\n    function poolLiquidity(Token pool) external view returns (PoolLiquidity memory);\n\n    /**\n     * @dev returns the pool token of the pool\n     */\n    function poolToken(Token pool) external view returns (IPoolToken);\n\n    /**\n     * @dev converts the specified pool token amount to the underlying base token amount\n     */\n    function poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) external view returns (uint256);\n\n    /**\n     * @dev converts the specified underlying base token amount to pool token amount\n     */\n    function underlyingToPoolToken(Token pool, uint256 tokenAmount) external view returns (uint256);\n\n    /**\n     * @dev returns the number of pool token to burn in order to increase everyone's underlying value by the specified\n     * amount\n     */\n    function poolTokenAmountToBurn(\n        Token pool,\n        uint256 tokenAmountToDistribute,\n        uint256 protocolPoolTokenAmount\n    ) external view returns (uint256);\n\n    /**\n     * @dev creates a new pool\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     * - the pool should have been whitelisted\n     * - the pool isn't already defined in the collection\n     */\n    function createPool(Token token) external;\n\n    /**\n     * @dev deposits base token liquidity on behalf of a specific provider and returns the respective pool token amount\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     * - assumes that the base token has been already deposited in the vault\n     */\n    function depositFor(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 tokenAmount\n    ) external returns (uint256);\n\n    /**\n     * @dev handles some of the withdrawal-related actions and returns the withdrawn base token amount\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     * - the caller must have approved the collection to transfer/burn the pool token amount on its behalf\n     */\n    function withdraw(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 poolTokenAmount\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the amounts that would be returned if the position is currently withdrawn,\n     * along with the breakdown of the base token and the BNT compensation\n     */\n    function withdrawalAmounts(Token pool, uint256 poolTokenAmount) external view returns (WithdrawalAmounts memory);\n\n    /**\n     * @dev performs a trade by providing the source amount and returns the target amount and the associated fee\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     */\n    function tradeBySourceAmount(\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount\n    ) external returns (TradeAmountAndFee memory);\n\n    /**\n     * @dev performs a trade by providing the target amount and returns the required source amount and the associated fee\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     */\n    function tradeByTargetAmount(\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount\n    ) external returns (TradeAmountAndFee memory);\n\n    /**\n     * @dev returns the output amount and fee when trading by providing the source amount\n     */\n    function tradeOutputAndFeeBySourceAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount\n    ) external view returns (TradeAmountAndFee memory);\n\n    /**\n     * @dev returns the input amount and fee when trading by providing the target amount\n     */\n    function tradeInputAndFeeByTargetAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount\n    ) external view returns (TradeAmountAndFee memory);\n\n    /**\n     * @dev notifies the pool of accrued fees\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     */\n    function onFeesCollected(Token pool, uint256 feeAmount) external;\n\n    /**\n     * @dev migrates a pool to this pool collection\n     *\n     * requirements:\n     *\n     * - the caller must be the pool migrator contract\n     */\n    function migratePoolIn(Token pool, Pool calldata data) external;\n\n    /**\n     * @dev migrates a pool from this pool collection\n     *\n     * requirements:\n     *\n     * - the caller must be the pool migrator contract\n     */\n    function migratePoolOut(Token pool, IPoolCollection targetPoolCollection) external;\n}\n"
    },
    "contracts/utility/FractionLibrary.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Fraction, Fraction112 } from \"./Fraction.sol\";\nimport { MathEx } from \"./MathEx.sol\";\n\n// solhint-disable-next-line func-visibility\nfunction zeroFraction() pure returns (Fraction memory) {\n    return Fraction({ n: 0, d: 1 });\n}\n\n// solhint-disable-next-line func-visibility\nfunction zeroFraction112() pure returns (Fraction112 memory) {\n    return Fraction112({ n: 0, d: 1 });\n}\n\n/**\n * @dev this library provides a set of fraction operations\n */\nlibrary FractionLibrary {\n    /**\n     * @dev returns whether a standard fraction is valid\n     */\n    function isValid(Fraction memory fraction) internal pure returns (bool) {\n        return fraction.d != 0;\n    }\n\n    /**\n     * @dev returns whether a standard fraction is positive\n     */\n    function isPositive(Fraction memory fraction) internal pure returns (bool) {\n        return isValid(fraction) && fraction.n != 0;\n    }\n\n    /**\n     * @dev returns whether a 112-bit fraction is valid\n     */\n    function isValid(Fraction112 memory fraction) internal pure returns (bool) {\n        return fraction.d != 0;\n    }\n\n    /**\n     * @dev returns whether a 112-bit fraction is positive\n     */\n    function isPositive(Fraction112 memory fraction) internal pure returns (bool) {\n        return isValid(fraction) && fraction.n != 0;\n    }\n\n    /**\n     * @dev reduces a standard fraction to a 112-bit fraction\n     */\n    function toFraction112(Fraction memory fraction) internal pure returns (Fraction112 memory) {\n        Fraction memory reducedFraction = MathEx.reducedFraction(fraction, type(uint112).max);\n        return Fraction112({ n: uint112(reducedFraction.n), d: uint112(reducedFraction.d) });\n    }\n\n    /**\n     * @dev expands a 112-bit fraction to a standard fraction\n     */\n    function fromFraction112(Fraction112 memory fraction) internal pure returns (Fraction memory) {\n        return Fraction({ n: fraction.n, d: fraction.d });\n    }\n}\n"
    },
    "contracts/utility/Fraction.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nstruct Fraction {\n    uint256 n;\n    uint256 d;\n}\n\nstruct Fraction112 {\n    uint112 n;\n    uint112 d;\n}\n"
    },
    "contracts/utility/MathEx.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Fraction } from \"./Fraction.sol\";\n\nimport { PPM_RESOLUTION } from \"./Constants.sol\";\n\nuint256 constant ONE = 1 << 127;\n\nstruct Uint512 {\n    uint256 hi; // 256 most significant bits\n    uint256 lo; // 256 least significant bits\n}\n\nstruct Sint256 {\n    uint256 value;\n    bool isNeg;\n}\n\n/**\n * @dev this library provides a set of complex math operations\n */\nlibrary MathEx {\n    error Overflow();\n\n    /**\n     * @dev returns `e ^ f`, where `e` is Euler's number and `f` is the input exponent:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function exp(Fraction memory f) internal pure returns (Fraction memory) {\n        uint256 x = MathEx.mulDivF(ONE, f.n, f.d);\n        uint256 y;\n        uint256 z;\n        uint256 n;\n\n        if (x >= (ONE << 4)) {\n            revert Overflow();\n        }\n\n        unchecked {\n            z = y = x % (ONE >> 3); // get the input modulo 2^(-3)\n            z = (z * y) / ONE;\n            n += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n            z = (z * y) / ONE;\n            n += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n            z = (z * y) / ONE;\n            n += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n            z = (z * y) / ONE;\n            n += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n            z = (z * y) / ONE;\n            n += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n            z = (z * y) / ONE;\n            n += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n            z = (z * y) / ONE;\n            n += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n            z = (z * y) / ONE;\n            n += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n            z = (z * y) / ONE;\n            n += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n            z = (z * y) / ONE;\n            n += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n            z = (z * y) / ONE;\n            n += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n            n = n / 0x21c3677c82b40000 + y + ONE; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n            if ((x & (ONE >> 3)) != 0)\n                n = (n * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n            if ((x & (ONE >> 2)) != 0)\n                n = (n * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n            if ((x & (ONE >> 1)) != 0)\n                n = (n * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n            if ((x & (ONE << 0)) != 0)\n                n = (n * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n            if ((x & (ONE << 1)) != 0)\n                n = (n * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n            if ((x & (ONE << 2)) != 0)\n                n = (n * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n            if ((x & (ONE << 3)) != 0)\n                n = (n * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n        }\n\n        return Fraction({ n: n, d: ONE });\n    }\n\n    /**\n     * @dev returns a fraction with reduced components\n     */\n    function reducedFraction(Fraction memory fraction, uint256 max) internal pure returns (Fraction memory) {\n        uint256 scale = Math.ceilDiv(Math.max(fraction.n, fraction.d), max);\n        return Fraction({ n: fraction.n / scale, d: fraction.d / scale });\n    }\n\n    /**\n     * @dev returns the weighted average of two fractions\n     */\n    function weightedAverage(\n        Fraction memory fraction1,\n        Fraction memory fraction2,\n        uint256 weight1,\n        uint256 weight2\n    ) internal pure returns (Fraction memory) {\n        return\n            Fraction({\n                n: fraction1.n * fraction2.d * weight1 + fraction1.d * fraction2.n * weight2,\n                d: fraction1.d * fraction2.d * (weight1 + weight2)\n            });\n    }\n\n    /**\n     * @dev returns whether or not the deviation of an offset sample from a base sample is within a permitted range\n     * for example, if the maximum permitted deviation is 5%, then evaluate `95% * base <= offset <= 105% * base`\n     */\n    function isInRange(\n        Fraction memory baseSample,\n        Fraction memory offsetSample,\n        uint32 maxDeviationPPM\n    ) internal pure returns (bool) {\n        Uint512 memory min = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION - maxDeviationPPM));\n        Uint512 memory mid = mul512(baseSample.d, offsetSample.n * PPM_RESOLUTION);\n        Uint512 memory max = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION + maxDeviationPPM));\n        return lte512(min, mid) && lte512(mid, max);\n    }\n\n    /**\n     * @dev returns an `Sint256` positive representation of an unsigned integer\n     */\n    function toPos256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: false });\n    }\n\n    /**\n     * @dev returns an `Sint256` negative representation of an unsigned integer\n     */\n    function toNeg256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: true });\n    }\n\n    /**\n     * @dev returns the largest integer smaller than or equal to `x * y / z`\n     */\n    function mulDivF(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        Uint512 memory xy = mul512(x, y);\n\n        // if `x * y < 2 ^ 256`\n        if (xy.hi == 0) {\n            return xy.lo / z;\n        }\n\n        // assert `x * y / z < 2 ^ 256`\n        if (xy.hi >= z) {\n            revert Overflow();\n        }\n\n        uint256 m = _mulMod(x, y, z); // `m = x * y % z`\n        Uint512 memory n = _sub512(xy, m); // `n = x * y - m` hence `n / z = floor(x * y / z)`\n\n        // if `n < 2 ^ 256`\n        if (n.hi == 0) {\n            return n.lo / z;\n        }\n\n        uint256 p = _unsafeSub(0, z) & z; // `p` is the largest power of 2 which `z` is divisible by\n        uint256 q = _div512(n, p); // `n` is divisible by `p` because `n` is divisible by `z` and `z` is divisible by `p`\n        uint256 r = _inv256(z / p); // `z / p = 1 mod 2` hence `inverse(z / p) = 1 mod 2 ^ 256`\n        return _unsafeMul(q, r); // `q * r = (n / p) * inverse(z / p) = n / z`\n    }\n\n    /**\n     * @dev returns the smallest integer larger than or equal to `x * y / z`\n     */\n    function mulDivC(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        uint256 w = mulDivF(x, y, z);\n        if (_mulMod(x, y, z) > 0) {\n            if (w >= type(uint256).max) {\n                revert Overflow();\n            }\n\n            return w + 1;\n        }\n        return w;\n    }\n\n    /**\n     * @dev returns the maximum of `n1 - n2` and 0\n     */\n    function subMax0(uint256 n1, uint256 n2) internal pure returns (uint256) {\n        return n1 > n2 ? n1 - n2 : 0;\n    }\n\n    /**\n     * @dev returns the value of `x > y`\n     */\n    function gt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi > y.hi || (x.hi == y.hi && x.lo > y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x < y`\n     */\n    function lt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi < y.hi || (x.hi == y.hi && x.lo < y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x >= y`\n     */\n    function gte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !lt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x <= y`\n     */\n    function lte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !gt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x * y`\n     */\n    function mul512(uint256 x, uint256 y) internal pure returns (Uint512 memory) {\n        uint256 p = _mulModMax(x, y);\n        uint256 q = _unsafeMul(x, y);\n        if (p >= q) {\n            return Uint512({ hi: p - q, lo: q });\n        }\n        return Uint512({ hi: _unsafeSub(p, q) - 1, lo: q });\n    }\n\n    /**\n     * @dev returns the value of `x - y`, given that `x >= y`\n     */\n    function _sub512(Uint512 memory x, uint256 y) private pure returns (Uint512 memory) {\n        if (x.lo >= y) {\n            return Uint512({ hi: x.hi, lo: x.lo - y });\n        }\n        return Uint512({ hi: x.hi - 1, lo: _unsafeSub(x.lo, y) });\n    }\n\n    /**\n     * @dev returns the value of `x / pow2n`, given that `x` is divisible by `pow2n`\n     */\n    function _div512(Uint512 memory x, uint256 pow2n) private pure returns (uint256) {\n        uint256 pow2nInv = _unsafeAdd(_unsafeSub(0, pow2n) / pow2n, 1); // `1 << (256 - n)`\n        return _unsafeMul(x.hi, pow2nInv) | (x.lo / pow2n); // `(x.hi << (256 - n)) | (x.lo >> n)`\n    }\n\n    /**\n     * @dev returns the inverse of `d` modulo `2 ^ 256`, given that `d` is congruent to `1` modulo `2`\n     */\n    function _inv256(uint256 d) private pure returns (uint256) {\n        // approximate the root of `f(x) = 1 / x - d` using the newtonraphson convergence method\n        uint256 x = 1;\n        for (uint256 i = 0; i < 8; i++) {\n            x = _unsafeMul(x, _unsafeSub(2, _unsafeMul(x, d))); // `x = x * (2 - x * d) mod 2 ^ 256`\n        }\n        return x;\n    }\n\n    /**\n     * @dev returns `(x + y) % 2 ^ 256`\n     */\n    function _unsafeAdd(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x + y;\n        }\n    }\n\n    /**\n     * @dev returns `(x - y) % 2 ^ 256`\n     */\n    function _unsafeSub(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x - y;\n        }\n    }\n\n    /**\n     * @dev returns `(x * y) % 2 ^ 256`\n     */\n    function _unsafeMul(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x * y;\n        }\n    }\n\n    /**\n     * @dev returns `x * y % (2 ^ 256 - 1)`\n     */\n    function _mulModMax(uint256 x, uint256 y) private pure returns (uint256) {\n        return mulmod(x, y, type(uint256).max);\n    }\n\n    /**\n     * @dev returns `x * y % z`\n     */\n    function _mulMod(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return mulmod(x, y, z);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/token/interfaces/IERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\n/**\n * @dev burnable ERC20 interface\n */\ninterface IERC20Burnable {\n    /**\n     * @dev Destroys tokens from the caller.\n     */\n    function burn(uint256 amount) external;\n\n    /**\n     * @dev Destroys tokens from a recipient, deducting from the caller's allowance\n     *\n     * requirements:\n     *\n     * - the caller must have allowance for recipient's tokens of at least the specified amount\n     */\n    function burnFrom(address recipient, uint256 amount) external;\n}\n"
    },
    "contracts/utility/interfaces/IOwned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\n/**\n * @dev Owned interface\n */\ninterface IOwned {\n    /**\n     * @dev returns the address of the current owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @dev allows transferring the contract ownership\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     * - the new owner still needs to accept the transfer\n     */\n    function transferOwnership(address ownerCandidate) external;\n\n    /**\n     * @dev used by a new owner to accept an ownership transfer\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "contracts/vaults/MasterVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IMasterVault } from \"./interfaces/IMasterVault.sol\";\nimport { IVault, ROLE_ASSET_MANAGER } from \"./interfaces/IVault.sol\";\nimport { Vault } from \"./Vault.sol\";\n\n/**\n * @dev Master Vault contract\n */\ncontract MasterVault is IMasterVault, Vault {\n    using SafeERC20 for IERC20;\n    using TokenLibrary for Token;\n\n    // the BNT manager role is only required to access the BNT reserve\n    bytes32 private constant ROLE_BNT_MANAGER = keccak256(\"ROLE_BNT_MANAGER\");\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 0] private __gap;\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(ITokenGovernance initBNTGovernance, ITokenGovernance initVBNTGovernance)\n        Vault(initBNTGovernance, initVBNTGovernance)\n    {}\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __MasterVault_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __MasterVault_init() internal onlyInitializing {\n        __Vault_init();\n\n        __MasterVault_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __MasterVault_init_unchained() internal onlyInitializing {\n        // set up administrative roles\n        _setRoleAdmin(ROLE_ASSET_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_BNT_MANAGER, ROLE_ADMIN);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc Vault\n     */\n    function isPayable() public pure override(IVault, Vault) returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev returns the BNT manager role\n     */\n    function roleBNTManager() external pure returns (bytes32) {\n        return ROLE_BNT_MANAGER;\n    }\n\n    /**\n     * @dev authorize the right of a caller to withdraw a specific amount of a token to a target\n     *\n     * requirements:\n     *\n     * - BNT: the caller must have the ROLE_BNT_MANAGER or ROLE_ASSET_MANAGER role\n     * - other reserve token or the native token: the caller must have the ROLE_ASSET_MANAGER role\n     */\n    function isAuthorizedWithdrawal(\n        address caller,\n        Token token,\n        address, /* target */\n        uint256 /* amount */\n    ) internal view override returns (bool) {\n        return (token.isEqual(_bnt) && hasRole(ROLE_BNT_MANAGER, caller)) || hasRole(ROLE_ASSET_MANAGER, caller);\n    }\n}\n"
    },
    "@bancor/token-governance/contracts/ITokenGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"./IMintableToken.sol\";\n\n/// @title The interface for mintable/burnable token governance.\ninterface ITokenGovernance {\n    // The address of the mintable ERC20 token.\n    function token() external view returns (IMintableToken);\n\n    /// @dev Mints new tokens.\n    ///\n    /// @param to Account to receive the new amount.\n    /// @param amount Amount to increase the supply by.\n    ///\n    function mint(address to, uint256 amount) external;\n\n    /// @dev Burns tokens from the caller.\n    ///\n    /// @param amount Amount to decrease the supply by.\n    ///\n    function burn(uint256 amount) external;\n}\n"
    },
    "contracts/vaults/interfaces/IMasterVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IVault } from \"./IVault.sol\";\n\ninterface IMasterVault is IVault {}\n"
    },
    "contracts/vaults/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\n// the asset manager role is required to access all the funds\nbytes32 constant ROLE_ASSET_MANAGER = keccak256(\"ROLE_ASSET_MANAGER\");\n\ninterface IVault is IUpgradeable {\n    /**\n     * @dev triggered when tokens have been withdrawn from the vault\n     */\n    event FundsWithdrawn(Token indexed token, address indexed caller, address indexed target, uint256 amount);\n\n    /**\n     * @dev triggered when tokens have been burned from the vault\n     */\n    event FundsBurned(Token indexed token, address indexed caller, uint256 amount);\n\n    /**\n     * @dev tells whether the vault accepts native token deposits\n     */\n    function isPayable() external view returns (bool);\n\n    /**\n     * @dev withdraws funds held by the contract and sends them to an account\n     */\n    function withdrawFunds(\n        Token token,\n        address payable target,\n        uint256 amount\n    ) external;\n\n    /**\n     * @dev burns funds held by the contract\n     */\n    function burn(Token token, uint256 amount) external;\n}\n"
    },
    "contracts/vaults/Vault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IVault, ROLE_ASSET_MANAGER } from \"./interfaces/IVault.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { IERC20Burnable } from \"../token/interfaces/IERC20Burnable.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { Utils, AccessDenied, NotPayable, InvalidToken } from \"../utility/Utils.sol\";\n\nabstract contract Vault is IVault, Upgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable, Utils {\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n    using TokenLibrary for Token;\n\n    // the address of the BNT token\n    IERC20 internal immutable _bnt;\n\n    // the address of the BNT token governance\n    ITokenGovernance internal immutable _bntGovernance;\n\n    // the address of the VBNT token\n    IERC20 internal immutable _vbnt;\n\n    // the address of the VBNT token governance\n    ITokenGovernance internal immutable _vbntGovernance;\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(ITokenGovernance initBNTGovernance, ITokenGovernance initVBNTGovernance)\n        validAddress(address(initBNTGovernance))\n        validAddress(address(initVBNTGovernance))\n    {\n        _bntGovernance = initBNTGovernance;\n        _bnt = initBNTGovernance.token();\n        _vbntGovernance = initVBNTGovernance;\n        _vbnt = initVBNTGovernance.token();\n    }\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __Vault_init() internal onlyInitializing {\n        __Upgradeable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        __Vault_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __Vault_init_unchained() internal onlyInitializing {}\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @dev returns the asset manager role\n     */\n    function roleAssetManager() external pure returns (bytes32) {\n        return ROLE_ASSET_MANAGER;\n    }\n\n    // allows execution only by an authorized operation\n    modifier whenAuthorized(\n        address caller,\n        Token token,\n        address payable target,\n        uint256 amount\n    ) {\n        if (!isAuthorizedWithdrawal(caller, token, target, amount)) {\n            revert AccessDenied();\n        }\n\n        _;\n    }\n\n    /**\n     * @dev returns whether withdrawals are currently paused\n     */\n    function isPaused() external view returns (bool) {\n        return paused();\n    }\n\n    /**\n     * @dev pauses withdrawals\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_ADMIN privileges\n     */\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    /**\n     * @dev unpauses withdrawals\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_ADMIN privileges\n     */\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function withdrawFunds(\n        Token token,\n        address payable target,\n        uint256 amount\n    )\n        external\n        override\n        validAddress(target)\n        nonReentrant\n        whenNotPaused\n        whenAuthorized(msg.sender, token, target, amount)\n    {\n        if (amount == 0) {\n            return;\n        }\n\n        if (token.isNative()) {\n            // using a regular transfer here would revert due to exceeding the 2300 gas limit which is why we're using\n            // call instead (via sendValue), which the 2300 gas limit does not apply for\n            target.sendValue(amount);\n        } else {\n            token.safeTransfer(target, amount);\n        }\n\n        emit FundsWithdrawn({ token: token, caller: msg.sender, target: target, amount: amount });\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function burn(Token token, uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        whenAuthorized(msg.sender, token, payable(address(0)), amount)\n    {\n        if (amount == 0) {\n            return;\n        }\n\n        if (token.isNative()) {\n            revert InvalidToken();\n        }\n\n        // allow vaults to burn BNT and VBNT via their respective token governance modules\n        if (token.isEqual(_bnt)) {\n            _bntGovernance.burn(amount);\n        } else if (token.isEqual(_vbnt)) {\n            _vbntGovernance.burn(amount);\n        } else {\n            IERC20Burnable(address(token)).burn(amount);\n        }\n\n        emit FundsBurned({ token: token, caller: msg.sender, amount: amount });\n    }\n\n    /**\n     * @dev returns whether the given caller is allowed access to the given token\n     */\n    function isAuthorizedWithdrawal(\n        address caller,\n        Token token,\n        address target,\n        uint256 amount\n    ) internal view virtual returns (bool);\n\n    /**\n     * @inheritdoc IVault\n     */\n    function isPayable() public view virtual returns (bool);\n\n    /**\n     * @dev authorize the contract to receive the native token\n     *\n     * requirements:\n     *\n     * - isPayable must return true\n     */\n    receive() external payable {\n        if (!isPayable()) {\n            revert NotPayable();\n        }\n    }\n}\n"
    },
    "@bancor/token-governance/contracts/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IClaimable.sol\";\n\n/// @title Mintable Token interface\ninterface IMintableToken is IERC20, IClaimable {\n    function issue(address to, uint256 amount) external;\n\n    function destroy(address from, uint256 amount) external;\n}\n"
    },
    "@bancor/token-governance/contracts/IClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\n/// @title Claimable contract interface\ninterface IClaimable {\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n\n    function acceptOwnership() external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/vaults/ExternalRewardsVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { IExternalRewardsVault } from \"./interfaces/IExternalRewardsVault.sol\";\nimport { IVault, ROLE_ASSET_MANAGER } from \"./interfaces/IVault.sol\";\nimport { Vault } from \"./Vault.sol\";\n\n/**\n * @dev External Rewards Vault contract\n */\ncontract ExternalRewardsVault is IExternalRewardsVault, Vault {\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 0] private __gap;\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(ITokenGovernance initBNTGovernance, ITokenGovernance initVBNTGovernance)\n        Vault(initBNTGovernance, initVBNTGovernance)\n    {}\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __ExternalRewardsVault_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __ExternalRewardsVault_init() internal onlyInitializing {\n        __Vault_init();\n\n        __ExternalRewardsVault_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __ExternalRewardsVault_init_unchained() internal onlyInitializing {\n        // set up administrative roles\n        _setRoleAdmin(ROLE_ASSET_MANAGER, ROLE_ADMIN);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc Vault\n     */\n    function isPayable() public pure override(IVault, Vault) returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev returns whether the given caller is allowed access to the given token\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_ASSET_MANAGER role\n     */\n    function isAuthorizedWithdrawal(\n        address caller,\n        Token, /* Token */\n        address, /* target */\n        uint256 /* amount */\n    ) internal view override returns (bool) {\n        return hasRole(ROLE_ASSET_MANAGER, caller);\n    }\n}\n"
    },
    "contracts/vaults/interfaces/IExternalRewardsVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IVault } from \"./IVault.sol\";\n\ninterface IExternalRewardsVault is IVault {}\n"
    },
    "contracts/vaults/ExternalProtectionVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { IExternalProtectionVault } from \"./interfaces/IExternalProtectionVault.sol\";\nimport { IVault, ROLE_ASSET_MANAGER } from \"./interfaces/IVault.sol\";\nimport { Vault } from \"./Vault.sol\";\n\n/**\n * @dev External Protection Vault contract\n */\ncontract ExternalProtectionVault is IExternalProtectionVault, Vault {\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 0] private __gap;\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(ITokenGovernance initBNTGovernance, ITokenGovernance initVBNTGovernance)\n        Vault(initBNTGovernance, initVBNTGovernance)\n    {}\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __ExternalProtectionVault_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __ExternalProtectionVault_init() internal onlyInitializing {\n        __Vault_init();\n\n        __ExternalProtectionVault_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __ExternalProtectionVault_init_unchained() internal onlyInitializing {\n        // set up administrative roles\n        _setRoleAdmin(ROLE_ASSET_MANAGER, ROLE_ADMIN);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc Vault\n     */\n    function isPayable() public pure override(IVault, Vault) returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev returns whether the given caller is allowed access to the given token\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_ASSET_MANAGER role\n     */\n    function isAuthorizedWithdrawal(\n        address caller,\n        Token, /* Token */\n        address, /* target */\n        uint256 /* amount */\n    ) internal view override returns (bool) {\n        return hasRole(ROLE_ASSET_MANAGER, caller);\n    }\n}\n"
    },
    "contracts/vaults/interfaces/IExternalProtectionVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IVault } from \"./IVault.sol\";\n\ninterface IExternalProtectionVault is IVault {}\n"
    },
    "contracts/network/interfaces/IBancorNetworkInfo.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IMasterVault } from \"../../vaults/interfaces/IMasterVault.sol\";\nimport { IExternalProtectionVault } from \"../../vaults/interfaces/IExternalProtectionVault.sol\";\nimport { IExternalRewardsVault } from \"../../vaults/interfaces/IExternalRewardsVault.sol\";\n\nimport { IPoolToken } from \"../../pools/interfaces/IPoolToken.sol\";\nimport { WithdrawalAmounts } from \"../../pools/interfaces/IPoolCollection.sol\";\nimport { IPoolMigrator } from \"../../pools/interfaces/IPoolMigrator.sol\";\nimport { IBNTPool } from \"../../pools/interfaces/IBNTPool.sol\";\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IBancorNetworkInfo } from \"./IBancorNetworkInfo.sol\";\nimport { IBancorNetwork } from \"./IBancorNetwork.sol\";\nimport { INetworkSettings } from \"./INetworkSettings.sol\";\nimport { IPendingWithdrawals } from \"./IPendingWithdrawals.sol\";\n\n/**\n * @dev Bancor Network Information interface\n */\ninterface IBancorNetworkInfo is IUpgradeable {\n    /**\n     * @dev returns the network contract\n     */\n    function network() external view returns (IBancorNetwork);\n\n    /**\n     * @dev returns the BNT contract\n     */\n    function bnt() external view returns (IERC20);\n\n    /**\n     * @dev returns the BNT governance contract\n     */\n    function bntGovernance() external view returns (ITokenGovernance);\n\n    /**\n     * @dev returns the VBNT contract\n     */\n    function vbnt() external view returns (IERC20);\n\n    /**\n     * @dev returns the VBNT governance contract\n     */\n    function vbntGovernance() external view returns (ITokenGovernance);\n\n    /**\n     * @dev returns the network settings contract\n     */\n    function networkSettings() external view returns (INetworkSettings);\n\n    /**\n     * @dev returns the master vault contract\n     */\n    function masterVault() external view returns (IMasterVault);\n\n    /**\n     * @dev returns the address of the external protection vault\n     */\n    function externalProtectionVault() external view returns (IExternalProtectionVault);\n\n    /**\n     * @dev returns the address of the external rewards vault\n     */\n    function externalRewardsVault() external view returns (IExternalRewardsVault);\n\n    /**\n     * @dev returns the BNT pool contract\n     */\n    function bntPool() external view returns (IBNTPool);\n\n    /**\n     * @dev returns the pool token contract for a given pool\n     */\n    function poolToken(Token pool) external view returns (IPoolToken);\n\n    /**\n     * @dev returns the pending withdrawals contract\n     */\n    function pendingWithdrawals() external view returns (IPendingWithdrawals);\n\n    /**\n     * @dev returns the pool migrator contract\n     */\n    function poolMigrator() external view returns (IPoolMigrator);\n\n    /**\n     * @dev returns the output amount when trading by providing the source amount\n     */\n    function tradeOutputBySourceAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount\n    ) external view returns (uint256);\n\n    /**\n     * @dev returns the input amount when trading by providing the target amount\n     */\n    function tradeInputByTargetAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount\n    ) external view returns (uint256);\n\n    /**\n     * @dev returns whether the given request is ready for withdrawal\n     */\n    function isReadyForWithdrawal(uint256 id) external view returns (bool);\n\n    /**\n     * @dev converts the specified pool token amount to the underlying token amount\n     */\n    function poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) external view returns (uint256);\n\n    /**\n     * @dev converts the specified underlying base token amount to pool token amount\n     */\n    function underlyingToPoolToken(Token pool, uint256 tokenAmount) external view returns (uint256);\n\n    /**\n     * @dev returns the amounts that would be returned if the position is currently withdrawn,\n     * along with the breakdown of the base token and the BNT compensation\n     */\n    function withdrawalAmounts(Token pool, uint256 poolTokenAmount) external view returns (WithdrawalAmounts memory);\n}\n"
    },
    "contracts/pools/interfaces/IPoolMigrator.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IVersioned } from \"../../utility/interfaces/IVersioned.sol\";\n\nimport { IPoolCollection } from \"./IPoolCollection.sol\";\n\n/**\n * @dev Pool Migrator interface\n */\ninterface IPoolMigrator is IVersioned {\n    /**\n     * @dev migrates a pool and returns the new pool collection it exists in\n     *\n     * notes:\n     *\n     * - invalid or incompatible pools will be skipped gracefully\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     */\n    function migratePool(Token pool) external returns (IPoolCollection);\n}\n"
    },
    "contracts/pools/interfaces/IBNTPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IPoolToken } from \"./IPoolToken.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IVault } from \"../../vaults/interfaces/IVault.sol\";\n\n// the BNT pool token manager role is required to access the BNT pool tokens\nbytes32 constant ROLE_BNT_POOL_TOKEN_MANAGER = keccak256(\"ROLE_BNT_POOL_TOKEN_MANAGER\");\n\n// the BNT manager role is required to request the BNT pool to mint BNT\nbytes32 constant ROLE_BNT_MANAGER = keccak256(\"ROLE_BNT_MANAGER\");\n\n// the vault manager role is required to request the BNT pool to burn BNT from the master vault\nbytes32 constant ROLE_VAULT_MANAGER = keccak256(\"ROLE_VAULT_MANAGER\");\n\n// the funding manager role is required to request or renounce funding from the BNT pool\nbytes32 constant ROLE_FUNDING_MANAGER = keccak256(\"ROLE_FUNDING_MANAGER\");\n\n/**\n * @dev BNT Pool interface\n */\ninterface IBNTPool is IVault {\n    /**\n     * @dev returns the BNT pool token contract\n     */\n    function poolToken() external view returns (IPoolToken);\n\n    /**\n     * @dev returns the total staked BNT balance in the network\n     */\n    function stakedBalance() external view returns (uint256);\n\n    /**\n     * @dev returns the current funding of given pool\n     */\n    function currentPoolFunding(Token pool) external view returns (uint256);\n\n    /**\n     * @dev returns the available BNT funding for a given pool\n     */\n    function availableFunding(Token pool) external view returns (uint256);\n\n    /**\n     * @dev converts the specified pool token amount to the underlying BNT amount\n     */\n    function poolTokenToUnderlying(uint256 poolTokenAmount) external view returns (uint256);\n\n    /**\n     * @dev converts the specified underlying BNT amount to pool token amount\n     */\n    function underlyingToPoolToken(uint256 bntAmount) external view returns (uint256);\n\n    /**\n     * @dev returns the number of pool token to burn in order to increase everyone's underlying value by the specified\n     * amount\n     */\n    function poolTokenAmountToBurn(uint256 bntAmountToDistribute) external view returns (uint256);\n\n    /**\n     * @dev mints BNT to the recipient\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_BNT_MANAGER role\n     */\n    function mint(address recipient, uint256 bntAmount) external;\n\n    /**\n     * @dev burns BNT from the vault\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_VAULT_MANAGER role\n     */\n    function burnFromVault(uint256 bntAmount) external;\n\n    /**\n     * @dev deposits BNT liquidity on behalf of a specific provider and returns the respective pool token amount\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     * - BNT tokens must have been already deposited into the contract\n     */\n    function depositFor(\n        bytes32 contextId,\n        address provider,\n        uint256 bntAmount,\n        bool isMigrating,\n        uint256 originalVBNTAmount\n    ) external returns (uint256);\n\n    /**\n     * @dev withdraws BNT liquidity on behalf of a specific provider and returns the withdrawn BNT amount\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     * - VBNT token must have been already deposited into the contract\n     */\n    function withdraw(\n        bytes32 contextId,\n        address provider,\n        uint256 poolTokenAmount\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the withdrawn BNT amount\n     */\n    function withdrawalAmount(uint256 poolTokenAmount) external view returns (uint256);\n\n    /**\n     * @dev requests BNT funding\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_FUNDING_MANAGER role\n     * - the token must have been whitelisted\n     * - the request amount should be below the funding limit for a given pool\n     * - the average rate of the pool must not deviate too much from its spot rate\n     */\n    function requestFunding(\n        bytes32 contextId,\n        Token pool,\n        uint256 bntAmount\n    ) external;\n\n    /**\n     * @dev renounces BNT funding\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_FUNDING_MANAGER role\n     * - the token must have been whitelisted\n     * - the average rate of the pool must not deviate too much from its spot rate\n     */\n    function renounceFunding(\n        bytes32 contextId,\n        Token pool,\n        uint256 bntAmount\n    ) external;\n\n    /**\n     * @dev notifies the pool of accrued fees\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     */\n    function onFeesCollected(\n        Token pool,\n        uint256 feeAmount,\n        bool isTradeFee\n    ) external;\n}\n"
    },
    "contracts/network/interfaces/IPendingWithdrawals.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IPoolToken } from \"../../pools/interfaces/IPoolToken.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\n/**\n * @dev the data struct representing a pending withdrawal request\n */\nstruct WithdrawalRequest {\n    address provider; // the liquidity provider\n    IPoolToken poolToken; // the locked pool token\n    Token reserveToken; // the reserve token to withdraw\n    uint32 createdAt; // the time when the request was created (Unix timestamp))\n    uint256 poolTokenAmount; // the locked pool token amount\n    uint256 reserveTokenAmount; // the expected reserve token amount to withdraw\n}\n\n/**\n * @dev the data struct representing a completed withdrawal request\n */\nstruct CompletedWithdrawal {\n    IPoolToken poolToken; // the transferred pool token\n    uint256 poolTokenAmount; // the transferred pool token amount\n}\n\n/**\n * @dev Pending Withdrawals interface\n */\ninterface IPendingWithdrawals is IUpgradeable {\n    /**\n     * @dev returns the lock duration\n     */\n    function lockDuration() external view returns (uint32);\n\n    /**\n     * @dev returns the pending withdrawal requests count for a specific provider\n     */\n    function withdrawalRequestCount(address provider) external view returns (uint256);\n\n    /**\n     * @dev returns the pending withdrawal requests IDs for a specific provider\n     */\n    function withdrawalRequestIds(address provider) external view returns (uint256[] memory);\n\n    /**\n     * @dev returns the pending withdrawal request with the specified ID\n     */\n    function withdrawalRequest(uint256 id) external view returns (WithdrawalRequest memory);\n\n    /**\n     * @dev initiates liquidity withdrawal\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     */\n    function initWithdrawal(\n        address provider,\n        IPoolToken poolToken,\n        uint256 poolTokenAmount\n    ) external returns (uint256);\n\n    /**\n     * @dev cancels a withdrawal request\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     * - the provider must have already initiated a withdrawal and received the specified id\n     */\n    function cancelWithdrawal(address provider, uint256 id) external;\n\n    /**\n     * @dev completes a withdrawal request and returns the pool token and its transferred amount\n     *\n     * requirements:\n     *\n     * - the caller must be the network contract\n     * - the provider must have already initiated a withdrawal and received the specified id\n     * - the lock duration has ended\n     */\n    function completeWithdrawal(\n        bytes32 contextId,\n        address provider,\n        uint256 id\n    ) external returns (CompletedWithdrawal memory);\n\n    /**\n     * @dev returns whether the given request is ready for withdrawal\n     */\n    function isReadyForWithdrawal(uint256 id) external view returns (bool);\n}\n"
    },
    "contracts/network/BancorNetworkInfo.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\nimport { IExternalProtectionVault } from \"../vaults/interfaces/IExternalProtectionVault.sol\";\nimport { IExternalRewardsVault } from \"../vaults/interfaces/IExternalRewardsVault.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IPoolMigrator } from \"../pools/interfaces/IPoolMigrator.sol\";\nimport { IPoolCollection, WithdrawalAmounts } from \"../pools/interfaces/IPoolCollection.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, InvalidToken } from \"../utility/Utils.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IBancorNetworkInfo } from \"./interfaces/IBancorNetworkInfo.sol\";\nimport { IBancorNetwork } from \"./interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings } from \"./interfaces/INetworkSettings.sol\";\nimport { IPendingWithdrawals } from \"./interfaces/IPendingWithdrawals.sol\";\n\n/**\n * @dev Bancor Network Information contract\n */\ncontract BancorNetworkInfo is IBancorNetworkInfo, Upgradeable, Utils {\n    using TokenLibrary for Token;\n\n    // the address of the network\n    IBancorNetwork private immutable _network;\n\n    // the address of the BNT token\n    IERC20 private immutable _bnt;\n\n    // the address of the BNT token governance\n    ITokenGovernance private immutable _bntGovernance;\n\n    // the address of the VBNT token\n    IERC20 private immutable _vbnt;\n\n    // the address of the VBNT token governance\n    ITokenGovernance private immutable _vbntGovernance;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the master vault contract\n    IMasterVault private immutable _masterVault;\n\n    // the address of the external protection vault\n    IExternalProtectionVault private immutable _externalProtectionVault;\n\n    // the address of the external rewards vault\n    IExternalRewardsVault private immutable _externalRewardsVault;\n\n    // the BNT pool contract\n    IBNTPool private immutable _bntPool;\n\n    // the BNT pool token\n    IPoolToken private immutable _bntPoolToken;\n\n    // the pending withdrawals contract\n    IPendingWithdrawals private immutable _pendingWithdrawals;\n\n    // the pool migrator contract\n    IPoolMigrator private immutable _poolMigrator;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 0] private __gap;\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        ITokenGovernance initBNTGovernance,\n        ITokenGovernance initVBNTGovernance,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IExternalProtectionVault initExternalProtectionVault,\n        IExternalRewardsVault initExternalRewardsVault,\n        IBNTPool initBNTPool,\n        IPendingWithdrawals initPendingWithdrawals,\n        IPoolMigrator initPoolMigrator\n    ) {\n        _validAddress(address(initNetwork));\n        _validAddress(address(initBNTGovernance));\n        _validAddress(address(initVBNTGovernance));\n        _validAddress(address(initNetworkSettings));\n        _validAddress(address(initMasterVault));\n        _validAddress(address(initExternalProtectionVault));\n        _validAddress(address(initExternalRewardsVault));\n        _validAddress(address(initBNTPool));\n        _validAddress(address(initPendingWithdrawals));\n        _validAddress(address(initPoolMigrator));\n\n        _network = initNetwork;\n        _bntGovernance = initBNTGovernance;\n        _bnt = initBNTGovernance.token();\n        _vbntGovernance = initVBNTGovernance;\n        _vbnt = initVBNTGovernance.token();\n        _networkSettings = initNetworkSettings;\n        _masterVault = initMasterVault;\n        _externalProtectionVault = initExternalProtectionVault;\n        _externalRewardsVault = initExternalRewardsVault;\n        _bntPool = initBNTPool;\n        _bntPoolToken = initBNTPool.poolToken();\n        _pendingWithdrawals = initPendingWithdrawals;\n        _poolMigrator = initPoolMigrator;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __BancorNetworkInfo_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __BancorNetworkInfo_init() internal onlyInitializing {\n        __Upgradeable_init();\n\n        __BancorNetworkInfo_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __BancorNetworkInfo_init_unchained() internal onlyInitializing {}\n\n    // solhint-enable func-name-mixedcase\n\n    modifier validTokensForTrade(Token sourceToken, Token targetToken) {\n        _validTokensForTrade(sourceToken, targetToken);\n\n        _;\n    }\n\n    /**\n     * @dev validates that the provided tokens are valid and unique\n     */\n    function _validTokensForTrade(Token sourceToken, Token targetToken) internal pure {\n        _validAddress(address(sourceToken));\n        _validAddress(address(targetToken));\n\n        if (sourceToken == targetToken) {\n            revert InvalidToken();\n        }\n    }\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function network() external view returns (IBancorNetwork) {\n        return _network;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function bnt() external view returns (IERC20) {\n        return _bnt;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function bntGovernance() external view returns (ITokenGovernance) {\n        return _bntGovernance;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function vbnt() external view returns (IERC20) {\n        return _vbnt;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function vbntGovernance() external view returns (ITokenGovernance) {\n        return _vbntGovernance;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function networkSettings() external view returns (INetworkSettings) {\n        return _networkSettings;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function masterVault() external view returns (IMasterVault) {\n        return _masterVault;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function externalProtectionVault() external view returns (IExternalProtectionVault) {\n        return _externalProtectionVault;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function externalRewardsVault() external view returns (IExternalRewardsVault) {\n        return _externalRewardsVault;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function bntPool() external view returns (IBNTPool) {\n        return _bntPool;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function poolToken(Token pool) external view returns (IPoolToken) {\n        return pool.isEqual(_bnt) ? _bntPoolToken : _poolCollection(pool).poolToken(pool);\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function pendingWithdrawals() external view returns (IPendingWithdrawals) {\n        return _pendingWithdrawals;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function poolMigrator() external view returns (IPoolMigrator) {\n        return _poolMigrator;\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function tradeOutputBySourceAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount\n    ) external view validTokensForTrade(sourceToken, targetToken) greaterThanZero(sourceAmount) returns (uint256) {\n        return _tradeOutputAmount(sourceToken, targetToken, sourceAmount, true);\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function tradeInputByTargetAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount\n    ) external view validTokensForTrade(sourceToken, targetToken) greaterThanZero(targetAmount) returns (uint256) {\n        return _tradeOutputAmount(sourceToken, targetToken, targetAmount, false);\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function isReadyForWithdrawal(uint256 id) external view returns (bool) {\n        return _pendingWithdrawals.isReadyForWithdrawal(id);\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) external view returns (uint256) {\n        return\n            pool.isEqual(_bnt)\n                ? _bntPool.poolTokenToUnderlying(poolTokenAmount)\n                : _poolCollection(pool).poolTokenToUnderlying(pool, poolTokenAmount);\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function underlyingToPoolToken(Token pool, uint256 tokenAmount) external view returns (uint256) {\n        return\n            pool.isEqual(_bnt)\n                ? _bntPool.underlyingToPoolToken(tokenAmount)\n                : _poolCollection(pool).underlyingToPoolToken(pool, tokenAmount);\n    }\n\n    /**\n     * @inheritdoc IBancorNetworkInfo\n     */\n    function withdrawalAmounts(Token pool, uint256 poolTokenAmount)\n        external\n        view\n        validAddress(address(pool))\n        greaterThanZero(poolTokenAmount)\n        returns (WithdrawalAmounts memory)\n    {\n        if (pool.isEqual(_bnt)) {\n            uint256 amount = _bntPool.withdrawalAmount(poolTokenAmount);\n            return WithdrawalAmounts({ totalAmount: amount, baseTokenAmount: 0, bntAmount: amount });\n        }\n\n        IPoolCollection poolCollection = _poolCollection(pool);\n        return poolCollection.withdrawalAmounts(pool, poolTokenAmount);\n    }\n\n    /**\n     * @dev returns either the source amount or the target amount by providing the source and the target tokens\n     * and whether we're interested in the target or the source amount\n     */\n    function _tradeOutputAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 amount,\n        bool bySourceAmount\n    ) private view returns (uint256) {\n        bool isSourceBNT = sourceToken.isEqual(_bnt);\n        bool isTargetBNT = targetToken.isEqual(_bnt);\n\n        // return the trade amount when trading BNT\n        if (isSourceBNT || isTargetBNT) {\n            Token token = isSourceBNT ? targetToken : sourceToken;\n            IPoolCollection poolCollection = _poolCollection(token);\n\n            return\n                (\n                    bySourceAmount\n                        ? poolCollection.tradeOutputAndFeeBySourceAmount(sourceToken, targetToken, amount)\n                        : poolCollection.tradeInputAndFeeByTargetAmount(sourceToken, targetToken, amount)\n                ).amount;\n        }\n\n        // return the target amount by simulating double-hop trade from the source token to the target token via BNT\n        if (bySourceAmount) {\n            uint256 targetAmount = _poolCollection(sourceToken)\n                .tradeOutputAndFeeBySourceAmount(sourceToken, Token(address(_bnt)), amount)\n                .amount;\n\n            return\n                _poolCollection(targetToken)\n                    .tradeOutputAndFeeBySourceAmount(Token(address(_bnt)), targetToken, targetAmount)\n                    .amount;\n        }\n\n        // return the source amount by simulating a \"reverse\" double-hop trade from the source token to the target token\n        // via BNT\n        uint256 requireNetworkAmount = _poolCollection(targetToken)\n            .tradeInputAndFeeByTargetAmount(Token(address(_bnt)), targetToken, amount)\n            .amount;\n\n        return\n            _poolCollection(sourceToken)\n                .tradeInputAndFeeByTargetAmount(sourceToken, Token(address(_bnt)), requireNetworkAmount)\n                .amount;\n    }\n\n    /**\n     * @dev verifies that the specified pool is managed by a valid pool collection and returns it\n     */\n    function _poolCollection(Token token) private view returns (IPoolCollection) {\n        // verify that the pool is managed by a valid pool collection\n        IPoolCollection poolCollection = _network.collectionByPool(token);\n        if (address(poolCollection) == address(0)) {\n            revert InvalidToken();\n        }\n\n        return poolCollection;\n    }\n}\n"
    },
    "contracts/network/NetworkSettings.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { EnumerableSetUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, AlreadyExists, DoesNotExist, InvalidParam } from \"../utility/Utils.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { INetworkSettings, VortexRewards, NotWhitelisted } from \"./interfaces/INetworkSettings.sol\";\n\n/**\n * @dev Network Settings contract\n */\ncontract NetworkSettings is INetworkSettings, Upgradeable, Utils {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using TokenLibrary for Token;\n\n    uint32 private constant DEFAULT_FLASH_LOAN_FEE_PPM = 0; // 0%\n\n    struct FlashLoanFee {\n        bool initialized;\n        uint32 feePPM;\n    }\n\n    // the address of the BNT token\n    IERC20 private immutable _bnt;\n\n    // a set of tokens which are eligible for protection\n    EnumerableSetUpgradeable.AddressSet private _protectedTokenWhitelist;\n\n    // a mapping of BNT funding limits per pool\n    mapping(Token => uint256) private _poolFundingLimits;\n\n    // below that amount, trading is disabled and co-investments use the initial rate\n    uint256 private _minLiquidityForTrading;\n\n    // the fee (in units of PPM)\n    uint32 private _networkFeePPM;\n\n    // the withdrawal fee (in units of PPM)\n    uint32 private _withdrawalFeePPM;\n\n    // the default flash-loan fee (in units of PPM)\n    uint32 private _defaultFlashLoanFeePPM;\n\n    // the settings of the Vortex\n    VortexRewards private _vortexRewards;\n\n    // a mapping between pools and their flash-loan fees\n    mapping(Token => FlashLoanFee) private _flashLoanFees;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 8] private __gap;\n\n    /**\n     * @dev triggered when a token is added to the protection whitelist\n     */\n    event TokenAddedToWhitelist(Token indexed token);\n\n    /**\n     * @dev triggered when a token is removed from the protection whitelist\n     */\n    event TokenRemovedFromWhitelist(Token indexed token);\n\n    /**\n     * @dev triggered when a per-pool funding limit is updated\n     */\n    event FundingLimitUpdated(Token indexed pool, uint256 prevLimit, uint256 newLimit);\n\n    /**\n     * @dev triggered when the minimum liquidity for trading is updated\n     */\n    event MinLiquidityForTradingUpdated(uint256 prevLiquidity, uint256 newLiquidity);\n\n    /**\n     * @dev triggered when the network fee is updated\n     */\n    event NetworkFeePPMUpdated(uint32 prevFeePPM, uint32 newFeePPM);\n\n    /**\n     * @dev triggered when the withdrawal fee is updated\n     */\n    event WithdrawalFeePPMUpdated(uint32 prevFeePPM, uint32 newFeePPM);\n\n    /**\n     * @dev triggered when the settings of the Vortex are updated\n     */\n    event VortexBurnRewardUpdated(\n        uint32 prevBurnRewardPPM,\n        uint32 newBurnRewardPPM,\n        uint256 prevBurnRewardMaxAmount,\n        uint256 newBurnRewardMaxAmount\n    );\n\n    /**\n     * @dev triggered when the default flash-loan fee is updated\n     */\n    event DefaultFlashLoanFeePPMUpdated(uint32 prevFeePPM, uint32 newFeePPM);\n\n    /**\n     * @dev triggered when a specific pool's flash-loan fee is updated\n     */\n    event FlashLoanFeePPMUpdated(Token indexed pool, uint32 prevFeePPM, uint32 newFeePPM);\n\n    constructor(IERC20 initBnt) validAddress(address(initBnt)) {\n        _bnt = initBnt;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __NetworkSettings_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __NetworkSettings_init() internal onlyInitializing {\n        __Upgradeable_init();\n\n        __NetworkSettings_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __NetworkSettings_init_unchained() internal onlyInitializing {\n        _setDefaultFlashLoanFeePPM(DEFAULT_FLASH_LOAN_FEE_PPM);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 2;\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function protectedTokenWhitelist() external view returns (Token[] memory) {\n        uint256 length = _protectedTokenWhitelist.length();\n        Token[] memory list = new Token[](length);\n        for (uint256 i = 0; i < length; i++) {\n            list[i] = Token(_protectedTokenWhitelist.at(i));\n        }\n        return list;\n    }\n\n    /**\n     * @dev adds a token to the protected tokens whitelist\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function addTokenToWhitelist(Token token) external onlyAdmin {\n        _addTokenToWhitelist(token);\n    }\n\n    /**\n     * @dev adds tokens to the protected tokens whitelist\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function addTokensToWhitelist(Token[] calldata tokens) external onlyAdmin {\n        uint256 length = tokens.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            _addTokenToWhitelist(tokens[i]);\n        }\n    }\n\n    /**\n     * @dev adds a token to the protected tokens whitelist\n     */\n    function _addTokenToWhitelist(Token token) private validExternalAddress(address(token)) {\n        if (!_protectedTokenWhitelist.add(address(token))) {\n            revert AlreadyExists();\n        }\n\n        emit TokenAddedToWhitelist({ token: token });\n    }\n\n    /**\n     * @dev removes a token from the protected tokens whitelist\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function removeTokenFromWhitelist(Token token) external onlyAdmin {\n        if (!_protectedTokenWhitelist.remove(address(token))) {\n            revert DoesNotExist();\n        }\n\n        emit TokenRemovedFromWhitelist({ token: token });\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function isTokenWhitelisted(Token token) external view returns (bool) {\n        return _isTokenWhitelisted(token);\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function poolFundingLimit(Token pool) external view returns (uint256) {\n        return _poolFundingLimits[pool];\n    }\n\n    /**\n     * @dev updates the amount of BNT that the protocol can provide as funding for a specific pool\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     * - the token must have been whitelisted\n     */\n    function setFundingLimit(Token pool, uint256 amount) external onlyAdmin {\n        _setFundingLimit(pool, amount);\n    }\n\n    /**\n     * @dev updates the amounts of BNT that the protocol can provide as funding for specific pools\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     * - each one of the tokens must have been whitelisted\n     */\n    function setFundingLimits(Token[] calldata pools, uint256[] calldata amounts) external onlyAdmin {\n        uint256 length = pools.length;\n        if (length != amounts.length) {\n            revert InvalidParam();\n        }\n\n        for (uint256 i = 0; i < length; i++) {\n            _setFundingLimit(pools[i], amounts[i]);\n        }\n    }\n\n    /**\n     * @dev updates the amount of BNT that the protocol can provide as funding for a specific pool\n     */\n    function _setFundingLimit(Token pool, uint256 amount) private validAddress(address(pool)) {\n        if (!_isTokenWhitelisted(pool)) {\n            revert NotWhitelisted();\n        }\n\n        uint256 prevPoolFundingLimit = _poolFundingLimits[pool];\n        if (prevPoolFundingLimit == amount) {\n            return;\n        }\n\n        _poolFundingLimits[pool] = amount;\n\n        emit FundingLimitUpdated({ pool: pool, prevLimit: prevPoolFundingLimit, newLimit: amount });\n    }\n\n    /**\n     * @dev adds a token to the protected tokens whitelist,\n     * and sets the amount of BNT that the protocol can provide as funding for this pool\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function addTokenToWhitelistWithLimit(Token token, uint256 amount) external onlyAdmin {\n        _addTokenToWhitelist(token);\n        _setFundingLimit(token, amount);\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function minLiquidityForTrading() external view returns (uint256) {\n        return _minLiquidityForTrading;\n    }\n\n    /**\n     * @dev updates the minimum liquidity for trading amount\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setMinLiquidityForTrading(uint256 amount) external onlyAdmin {\n        uint256 prevMinLiquidityForTrading = _minLiquidityForTrading;\n        if (_minLiquidityForTrading == amount) {\n            return;\n        }\n\n        _minLiquidityForTrading = amount;\n\n        emit MinLiquidityForTradingUpdated({ prevLiquidity: prevMinLiquidityForTrading, newLiquidity: amount });\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function networkFeePPM() external view returns (uint32) {\n        return _networkFeePPM;\n    }\n\n    /**\n     * @dev sets the network fee (in units of PPM)\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setNetworkFeePPM(uint32 newNetworkFeePPM) external onlyAdmin validFee(newNetworkFeePPM) {\n        uint32 prevNetworkFeePPM = _networkFeePPM;\n        if (prevNetworkFeePPM == newNetworkFeePPM) {\n            return;\n        }\n\n        _networkFeePPM = newNetworkFeePPM;\n\n        emit NetworkFeePPMUpdated({ prevFeePPM: prevNetworkFeePPM, newFeePPM: newNetworkFeePPM });\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function withdrawalFeePPM() external view returns (uint32) {\n        return _withdrawalFeePPM;\n    }\n\n    /**\n     * @dev sets the withdrawal fee (in units of PPM)\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setWithdrawalFeePPM(uint32 newWithdrawalFeePPM) external onlyAdmin validFee(newWithdrawalFeePPM) {\n        uint32 prevWithdrawalFeePPM = _withdrawalFeePPM;\n        if (prevWithdrawalFeePPM == newWithdrawalFeePPM) {\n            return;\n        }\n\n        _withdrawalFeePPM = newWithdrawalFeePPM;\n\n        emit WithdrawalFeePPMUpdated({ prevFeePPM: prevWithdrawalFeePPM, newFeePPM: newWithdrawalFeePPM });\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function defaultFlashLoanFeePPM() external view returns (uint32) {\n        return _defaultFlashLoanFeePPM;\n    }\n\n    /**\n     * @dev sets the default flash-loan fee (in units of PPM)\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setDefaultFlashLoanFeePPM(uint32 newDefaultFlashLoanFeePPM)\n        external\n        onlyAdmin\n        validFee(newDefaultFlashLoanFeePPM)\n    {\n        _setDefaultFlashLoanFeePPM(newDefaultFlashLoanFeePPM);\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function flashLoanFeePPM(Token pool) external view returns (uint32) {\n        FlashLoanFee memory flashLoanFee = _flashLoanFees[pool];\n\n        return flashLoanFee.initialized ? flashLoanFee.feePPM : _defaultFlashLoanFeePPM;\n    }\n\n    /**\n     * @dev sets the flash-loan fee of a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     * - the token must have been whitelisted\n     */\n    function setFlashLoanFeePPM(Token pool, uint32 newFlashLoanFeePPM) external onlyAdmin validFee(newFlashLoanFeePPM) {\n        if (!pool.isEqual(_bnt) && !_isTokenWhitelisted(pool)) {\n            revert NotWhitelisted();\n        }\n\n        uint32 prevFlashLoanFeePPM = _flashLoanFees[pool].feePPM;\n        if (prevFlashLoanFeePPM == newFlashLoanFeePPM) {\n            return;\n        }\n\n        _flashLoanFees[pool] = FlashLoanFee({ initialized: true, feePPM: newFlashLoanFeePPM });\n\n        emit FlashLoanFeePPMUpdated({ pool: pool, prevFeePPM: prevFlashLoanFeePPM, newFeePPM: newFlashLoanFeePPM });\n    }\n\n    /**\n     * @inheritdoc INetworkSettings\n     */\n    function vortexRewards() external view returns (VortexRewards memory) {\n        return _vortexRewards;\n    }\n\n    /**\n     * @dev sets the settings of the Vortex\n     *\n     * requirements:\n     *s\n     * - the caller must be the admin of the contract\n     */\n    function setVortexRewards(VortexRewards calldata rewards)\n        external\n        onlyAdmin\n        validFee(rewards.burnRewardPPM)\n        greaterThanZero(rewards.burnRewardMaxAmount)\n    {\n        uint32 prevVortexBurnRewardPPM = _vortexRewards.burnRewardPPM;\n        uint256 prevVortexBurnRewardMaxAmount = _vortexRewards.burnRewardMaxAmount;\n\n        if (\n            prevVortexBurnRewardPPM == rewards.burnRewardPPM &&\n            prevVortexBurnRewardMaxAmount == rewards.burnRewardMaxAmount\n        ) {\n            return;\n        }\n\n        _vortexRewards = rewards;\n\n        emit VortexBurnRewardUpdated({\n            prevBurnRewardPPM: prevVortexBurnRewardPPM,\n            newBurnRewardPPM: rewards.burnRewardPPM,\n            prevBurnRewardMaxAmount: prevVortexBurnRewardMaxAmount,\n            newBurnRewardMaxAmount: rewards.burnRewardMaxAmount\n        });\n    }\n\n    /**\n     * @dev performs post-upgrade initialization\n     */\n    function _postUpgrade(\n        bytes calldata /* data */\n    ) internal virtual override {\n        _setDefaultFlashLoanFeePPM(DEFAULT_FLASH_LOAN_FEE_PPM);\n    }\n\n    /**\n     * @dev checks whether a given token is whitelisted\n     */\n    function _isTokenWhitelisted(Token token) private view returns (bool) {\n        return _protectedTokenWhitelist.contains(address(token));\n    }\n\n    /**\n     * @dev sets the default flash-loan fee (in units of PPM)\n     */\n    function _setDefaultFlashLoanFeePPM(uint32 newDefaultFlashLoanFeePPM) private {\n        uint32 prevDefaultFlashLoanFeePPM = _defaultFlashLoanFeePPM;\n        if (prevDefaultFlashLoanFeePPM == newDefaultFlashLoanFeePPM) {\n            return;\n        }\n\n        _defaultFlashLoanFeePPM = newDefaultFlashLoanFeePPM;\n\n        emit DefaultFlashLoanFeePPMUpdated({\n            prevFeePPM: prevDefaultFlashLoanFeePPM,\n            newFeePPM: newDefaultFlashLoanFeePPM\n        });\n    }\n}\n"
    },
    "contracts/pools/PoolTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils } from \"../utility/Utils.sol\";\n\nimport { IPoolTokenFactory } from \"./interfaces/IPoolTokenFactory.sol\";\nimport { IPoolToken } from \"./interfaces/IPoolToken.sol\";\nimport { PoolToken } from \"./PoolToken.sol\";\n\n/**\n * @dev Pool Token Factory contract\n */\ncontract PoolTokenFactory is IPoolTokenFactory, Upgradeable, Utils {\n    using TokenLibrary for Token;\n\n    string private constant POOL_TOKEN_SYMBOL_PREFIX = \"bn\";\n    string private constant POOL_TOKEN_NAME_PREFIX = \"Bancor\";\n    string private constant POOL_TOKEN_NAME_SUFFIX = \"Pool Token\";\n\n    // a mapping between tokens and custom symbol overrides (only needed for tokens with malformed symbol property)\n    mapping(Token => string) private _tokenSymbolOverrides;\n\n    // a mapping between tokens and custom token overrides (only needed for tokens with malformed decimals property)\n    mapping(Token => uint8) private _tokenDecimalsOverrides;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 2] private __gap;\n\n    /**\n     * @dev triggered when a pool token is created\n     */\n    event PoolTokenCreated(IPoolToken indexed poolToken, Token indexed token);\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __PoolTokenFactory_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __PoolTokenFactory_init() internal onlyInitializing {\n        __Upgradeable_init();\n\n        __PoolTokenFactory_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __PoolTokenFactory_init_unchained() internal onlyInitializing {}\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IPoolTokenFactory\n     */\n    function tokenSymbolOverride(Token token) external view returns (string memory) {\n        return _tokenSymbolOverrides[token];\n    }\n\n    /**\n     * @dev sets the custom symbol override for a given reserve token\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setTokenSymbolOverride(Token token, string calldata symbol) external onlyAdmin {\n        _tokenSymbolOverrides[token] = symbol;\n    }\n\n    /**\n     * @inheritdoc IPoolTokenFactory\n     */\n    function tokenDecimalsOverride(Token token) external view returns (uint8) {\n        return _tokenDecimalsOverrides[token];\n    }\n\n    /**\n     * @dev sets the decimals override for a given reserve token\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setTokenDecimalsOverride(Token token, uint8 decimals) external onlyAdmin {\n        _tokenDecimalsOverrides[token] = decimals;\n    }\n\n    /**\n     * @inheritdoc IPoolTokenFactory\n     */\n    function createPoolToken(Token token) external validAddress(address(token)) returns (IPoolToken) {\n        string memory customSymbol = _tokenSymbolOverrides[token];\n        string memory tokenSymbol = bytes(customSymbol).length != 0 ? customSymbol : token.symbol();\n\n        uint8 customDecimals = _tokenDecimalsOverrides[token];\n        uint8 tokenDecimals = customDecimals != 0 ? customDecimals : token.decimals();\n\n        string memory symbol = string.concat(POOL_TOKEN_SYMBOL_PREFIX, tokenSymbol);\n        string memory name = string.concat(POOL_TOKEN_NAME_PREFIX, \" \", tokenSymbol, \" \", POOL_TOKEN_NAME_SUFFIX);\n\n        PoolToken newPoolToken = new PoolToken(name, symbol, tokenDecimals, token);\n\n        // make sure to transfer the ownership to the caller\n        newPoolToken.transferOwnership(msg.sender);\n\n        emit PoolTokenCreated({ poolToken: newPoolToken, token: token });\n\n        return newPoolToken;\n    }\n}\n"
    },
    "contracts/pools/interfaces/IPoolTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Token } from \"../../token/Token.sol\";\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\nimport { IPoolToken } from \"./IPoolToken.sol\";\n\n/**\n * @dev Pool Token Factory interface\n */\ninterface IPoolTokenFactory is IUpgradeable {\n    /**\n     * @dev returns the custom symbol override for a given reserve token\n     */\n    function tokenSymbolOverride(Token token) external view returns (string memory);\n\n    /**\n     * @dev returns the custom decimals override for a given reserve token\n     */\n    function tokenDecimalsOverride(Token token) external view returns (uint8);\n\n    /**\n     * @dev creates a pool token for the specified token\n     */\n    function createPoolToken(Token token) external returns (IPoolToken);\n}\n"
    },
    "contracts/pools/PoolToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { ERC20Burnable } from \"../token/ERC20Burnable.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Owned } from \"../utility/Owned.sol\";\nimport { Utils } from \"../utility/Utils.sol\";\n\nimport { IPoolToken } from \"./interfaces/IPoolToken.sol\";\n\n/**\n * @dev Pool Token contract\n */\ncontract PoolToken is IPoolToken, ERC20Permit, ERC20Burnable, Owned, Utils {\n    Token private immutable _reserveToken;\n\n    uint8 private _decimals;\n\n    /**\n     * @dev initializes a new PoolToken contract\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 initDecimals,\n        Token initReserveToken\n    ) ERC20(name, symbol) ERC20Permit(name) validAddress(address(initReserveToken)) {\n        _decimals = initDecimals;\n        _reserveToken = initReserveToken;\n    }\n\n    /**\n     * @inheritdoc IVersioned\n     */\n    function version() external pure returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @dev returns the number of decimals used to get its user representation\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @inheritdoc IPoolToken\n     */\n    function reserveToken() external view returns (Token) {\n        return _reserveToken;\n    }\n\n    /**\n     * @inheritdoc IPoolToken\n     */\n    function mint(address recipient, uint256 amount) external onlyOwner validExternalAddress(recipient) {\n        _mint(recipient, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/token/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { IERC20Burnable } from \"./interfaces/IERC20Burnable.sol\";\n\n/**\n * @dev this is an adapted clone of the OZ's ERC20Burnable extension which is unfortunately required so that it can be\n * explicitly specified in interfaces via our new IERC20Burnable interface.\n *\n * We have also removed the explicit use of Context and updated the code to our style.\n */\nabstract contract ERC20Burnable is ERC20, IERC20Burnable {\n    /**\n     * @inheritdoc IERC20Burnable\n     */\n    function burn(uint256 amount) external virtual {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Burnable\n     */\n    function burnFrom(address recipient, uint256 amount) external virtual {\n        _approve(recipient, msg.sender, allowance(recipient, msg.sender) - amount);\n        _burn(recipient, amount);\n    }\n}\n"
    },
    "contracts/utility/Owned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IOwned } from \"./interfaces/IOwned.sol\";\nimport { AccessDenied } from \"./Utils.sol\";\n\n/**\n * @dev this contract provides support and utilities for contract ownership\n */\nabstract contract Owned is IOwned {\n    error SameOwner();\n\n    address private _owner;\n    address private _newOwner;\n\n    /**\n     * @dev triggered when the owner is updated\n     */\n    event OwnerUpdate(address indexed prevOwner, address indexed newOwner);\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract\n     */\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    // allows execution by the owner only\n    modifier onlyOwner() {\n        _onlyOwner();\n\n        _;\n    }\n\n    // error message binary size optimization\n    function _onlyOwner() private view {\n        if (msg.sender != _owner) {\n            revert AccessDenied();\n        }\n    }\n\n    /**\n     * @inheritdoc IOwned\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @inheritdoc IOwned\n     */\n    function transferOwnership(address ownerCandidate) public virtual onlyOwner {\n        if (ownerCandidate == _owner) {\n            revert SameOwner();\n        }\n\n        _newOwner = ownerCandidate;\n    }\n\n    /**\n     * @inheritdoc IOwned\n     */\n    function acceptOwnership() public virtual {\n        if (msg.sender != _newOwner) {\n            revert AccessDenied();\n        }\n\n        _transferOwnership(_newOwner);\n    }\n\n    /**\n     * @dev returns the address of the new owner candidate\n     */\n    function newOwner() external view returns (address) {\n        return _newOwner;\n    }\n\n    /**\n     * @dev sets the new owner internally\n     */\n    function _transferOwnership(address ownerCandidate) private {\n        address prevOwner = _owner;\n\n        _owner = ownerCandidate;\n        _newOwner = address(0);\n\n        emit OwnerUpdate({ prevOwner: prevOwner, newOwner: ownerCandidate });\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/network/BancorV1Migration.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Utils } from \"../utility/Utils.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IBancorNetwork } from \"./interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings } from \"./interfaces/INetworkSettings.sol\";\n\ninterface IBancorConverterV1 {\n    function reserveTokens() external view returns (Token[] memory);\n\n    function removeLiquidity(\n        uint256 amount,\n        Token[] memory reserveTokens,\n        uint256[] memory reserveMinReturnAmounts\n    ) external returns (uint256[] memory);\n}\n\n/**\n * @dev this contract supports V1 liquidity migration\n */\ncontract BancorV1Migration is IVersioned, ReentrancyGuard, Utils {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IPoolToken;\n    using TokenLibrary for Token;\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the address of the BNT token\n    IERC20 private immutable _bnt;\n\n    event PositionMigrated(\n        address indexed provider,\n        IPoolToken poolToken,\n        Token indexed tokenA,\n        Token indexed tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        bool migratedA,\n        bool migratedB\n    );\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        INetworkSettings initNetworkSettings,\n        IERC20 initBNT\n    ) validAddress(address(initNetwork)) validAddress(address(initNetworkSettings)) validAddress(address(initBNT)) {\n        _network = initNetwork;\n        _networkSettings = initNetworkSettings;\n        _bnt = initBNT;\n    }\n\n    /**\n     * @inheritdoc IVersioned\n     */\n    function version() public pure override(IVersioned) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @dev authorize the contract to receive the native token\n     */\n    receive() external payable {}\n\n    /**\n     * @dev migrates pool tokens from v1 to v3\n     *\n     * requirements:\n     *\n     * - the caller must have approved this contract to transfer the pool tokens on its behalf\n     */\n    function migratePoolTokens(IPoolToken poolToken, uint256 amount) external nonReentrant {\n        poolToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        IBancorConverterV1 converter = IBancorConverterV1(payable(poolToken.owner()));\n\n        Token[] memory reserveTokens = converter.reserveTokens();\n\n        uint256[] memory minReturnAmounts = new uint256[](2);\n        minReturnAmounts[0] = 1;\n        minReturnAmounts[1] = 1;\n\n        uint256[] memory reserveAmounts = converter.removeLiquidity(amount, reserveTokens, minReturnAmounts);\n\n        bool[2] memory isMigrated;\n\n        for (uint256 i = 0; i < 2; i++) {\n            isMigrated[i] = reserveTokens[i].isEqual(_bnt) || _networkSettings.isTokenWhitelisted(reserveTokens[i]);\n            if (isMigrated[i]) {\n                if (reserveTokens[i].isNative()) {\n                    _network.depositFor{ value: reserveAmounts[i] }(msg.sender, reserveTokens[i], reserveAmounts[i]);\n                } else {\n                    reserveTokens[i].safeApprove(address(_network), reserveAmounts[i]);\n                    _network.depositFor(msg.sender, reserveTokens[i], reserveAmounts[i]);\n                }\n            } else {\n                if (reserveTokens[i].isNative()) {\n                    payable(msg.sender).transfer(reserveAmounts[i]);\n                } else {\n                    reserveTokens[i].safeTransfer(msg.sender, reserveAmounts[i]);\n                }\n            }\n        }\n\n        emit PositionMigrated({\n            provider: msg.sender,\n            poolToken: poolToken,\n            tokenA: reserveTokens[0],\n            tokenB: reserveTokens[1],\n            amountA: reserveAmounts[0],\n            amountB: reserveAmounts[1],\n            migratedA: isMigrated[0],\n            migratedB: isMigrated[1]\n        });\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/rewards/StandardRewards.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { EnumerableSetUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, AccessDenied, DoesNotExist, AlreadyExists, InvalidParam } from \"../utility/Utils.sol\";\nimport { Time } from \"../utility/Time.sol\";\n\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary, Signature } from \"../token/TokenLibrary.sol\";\n\nimport { IExternalRewardsVault } from \"../vaults/interfaces/IExternalRewardsVault.sol\";\n\nimport { IStandardRewards, ProgramData, StakeAmounts } from \"./interfaces/IStandardRewards.sol\";\n\n/**\n * @dev Standard Rewards contract\n */\ncontract StandardRewards is IStandardRewards, ReentrancyGuardUpgradeable, Utils, Time, Upgradeable {\n    using Address for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using TokenLibrary for Token;\n\n    struct Rewards {\n        uint32 lastUpdateTime;\n        uint256 rewardPerToken;\n    }\n\n    struct ProviderRewards {\n        uint256 rewardPerTokenPaid;\n        uint256 pendingRewards;\n        uint256 claimedRewards;\n        uint256 stakedAmount;\n    }\n\n    struct RewardData {\n        Token rewardsToken;\n        uint256 amount;\n    }\n\n    struct ClaimData {\n        uint256 reward;\n        uint256 stakedAmount;\n    }\n\n    error ArrayNotUnique();\n    error InsufficientFunds();\n    error RewardsTooHigh();\n    error NativeTokenAmountMismatch();\n    error PoolMismatch();\n    error ProgramDisabled();\n    error ProgramInactive();\n    error RewardsTokenMismatch();\n\n    // since we will be dividing by the total amount of protected tokens in units of wei, we can encounter cases\n    // where the total amount in the denominator is higher than the product of the rewards rate and staking duration. In\n    // order to avoid this imprecision, we will amplify the reward rate by the units amount.\n    uint256 private constant REWARD_RATE_FACTOR = 1e18;\n\n    uint256 private constant INITIAL_PROGRAM_ID = 1;\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the address of the BNT token governance\n    ITokenGovernance internal immutable _bntGovernance;\n\n    // the BNT contract\n    IERC20 private immutable _bnt;\n\n    // the BNT pool token contract\n    IPoolToken private immutable _bntPoolToken;\n\n    // the address of the external rewards vault\n    IExternalRewardsVault private immutable _externalRewardsVault;\n\n    // the ID of the next created program\n    uint256 internal _nextProgramId;\n\n    // a mapping between providers and the program IDs of the program they are participating in\n    mapping(address => EnumerableSetUpgradeable.UintSet) private _programIdsByProvider;\n\n    // a mapping between program IDs and program data\n    mapping(uint256 => ProgramData) internal _programs;\n\n    // a mapping between pools and their latest programs\n    mapping(Token => uint256) private _latestProgramIdByPool;\n\n    // a mapping between programs and their respective rewards data\n    mapping(uint256 => Rewards) internal _programRewards;\n\n    // a mapping between providers, programs and their respective rewards data\n    mapping(address => mapping(uint256 => ProviderRewards)) internal _providerRewards;\n\n    // a mapping between programs and their total stakes\n    mapping(uint256 => uint256) private _programStakes;\n\n    // a mapping between reward tokens and total unclaimed rewards\n    mapping(Token => uint256) internal _unclaimedRewards;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 8] private __gap;\n\n    /**\n     * @dev triggered when a program is created\n     */\n    event ProgramCreated(\n        Token indexed pool,\n        uint256 indexed programId,\n        Token indexed rewardsToken,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 endTime\n    );\n\n    /**\n     * @dev triggered when a program is terminated prematurely\n     */\n    event ProgramTerminated(Token indexed pool, uint256 indexed programId, uint32 endTime, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when a program is enabled/disabled\n     */\n    event ProgramEnabled(Token indexed pool, uint256 indexed programId, bool status, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when a provider joins a program\n     */\n    event ProviderJoined(\n        Token indexed pool,\n        uint256 indexed programId,\n        address indexed provider,\n        uint256 poolTokenAmount,\n        uint256 prevStake\n    );\n\n    /**\n     * @dev triggered when a provider leaves a program (even if partially)\n     */\n    event ProviderLeft(\n        Token indexed pool,\n        uint256 indexed programId,\n        address indexed provider,\n        uint256 poolTokenAmount,\n        uint256 remainingStake\n    );\n\n    /**\n     * @dev triggered when pending rewards are being claimed\n     */\n    event RewardsClaimed(Token indexed pool, uint256 indexed programId, address indexed provider, uint256 amount);\n\n    /**\n     * @dev triggered when pending rewards are being staked\n     */\n    event RewardsStaked(Token indexed pool, uint256 indexed programId, address indexed provider, uint256 amount);\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        INetworkSettings initNetworkSettings,\n        ITokenGovernance initBNTGovernance,\n        IBNTPool initBNTPool,\n        IExternalRewardsVault initExternalRewardsVault\n    )\n        validAddress(address(initNetwork))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initBNTGovernance))\n        validAddress(address(initBNTPool))\n        validAddress(address(initExternalRewardsVault))\n    {\n        _network = initNetwork;\n        _networkSettings = initNetworkSettings;\n        _bntGovernance = initBNTGovernance;\n        _bnt = initBNTGovernance.token();\n        _bntPoolToken = initBNTPool.poolToken();\n        _externalRewardsVault = initExternalRewardsVault;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __StandardRewards_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __StandardRewards_init() internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __Upgradeable_init();\n\n        __StandardRewards_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __StandardRewards_init_unchained() internal onlyInitializing {\n        _nextProgramId = INITIAL_PROGRAM_ID;\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    modifier uniqueArray(uint256[] calldata ids) {\n        if (!_isArrayUnique(ids)) {\n            revert ArrayNotUnique();\n        }\n\n        _;\n    }\n\n    /**\n     * @dev authorize the contract to receive the native token\n     */\n    receive() external payable {}\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function programIds() external view returns (uint256[] memory) {\n        uint256 length = _nextProgramId - INITIAL_PROGRAM_ID;\n        uint256[] memory ids = new uint256[](length);\n        for (uint256 i = 0; i < length; i++) {\n            ids[i] = i + INITIAL_PROGRAM_ID;\n        }\n\n        return ids;\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function programs(uint256[] calldata ids) external view uniqueArray(ids) returns (ProgramData[] memory) {\n        uint256 length = ids.length;\n        ProgramData[] memory list = new ProgramData[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            list[i] = _programs[ids[i]];\n        }\n\n        return list;\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function providerProgramIds(address provider) external view returns (uint256[] memory) {\n        return _programIdsByProvider[provider].values();\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function programStake(uint256 id) external view returns (uint256) {\n        return _programStakes[id];\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function providerStake(address provider, uint256 id) external view returns (uint256) {\n        return _providerRewards[provider][id].stakedAmount;\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function isProgramActive(uint256 id) external view returns (bool) {\n        return _isProgramActive(_programs[id]);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function isProgramEnabled(uint256 id) external view returns (bool) {\n        return _isProgramEnabled(_programs[id]);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function latestProgramId(Token pool) external view returns (uint256) {\n        return _latestProgramIdByPool[pool];\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function createProgram(\n        Token pool,\n        Token rewardsToken,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 endTime\n    )\n        external\n        validAddress(address(pool))\n        validAddress(address(rewardsToken))\n        greaterThanZero(totalRewards)\n        onlyAdmin\n        nonReentrant\n        returns (uint256)\n    {\n        if (!(_time() <= startTime && startTime < endTime)) {\n            revert InvalidParam();\n        }\n\n        // ensure that no program exists for the specific pool\n        if (_isProgramActive(_programs[_latestProgramIdByPool[pool]])) {\n            revert AlreadyExists();\n        }\n\n        IPoolToken poolToken;\n        if (pool.isEqual(_bnt)) {\n            poolToken = _bntPoolToken;\n        } else {\n            if (!_networkSettings.isTokenWhitelisted(pool)) {\n                revert NotWhitelisted();\n            }\n\n            poolToken = _network.collectionByPool(pool).poolToken(pool);\n        }\n\n        // ensure that the rewards were already deposited to the rewards vault\n        uint256 unclaimedRewards = _unclaimedRewards[rewardsToken];\n        if (!rewardsToken.isEqual(_bnt)) {\n            if (rewardsToken.balanceOf(address(_externalRewardsVault)) < unclaimedRewards + totalRewards) {\n                revert InsufficientFunds();\n            }\n        }\n\n        uint256 id = _nextProgramId++;\n        uint256 rewardRate = totalRewards / (endTime - startTime);\n\n        _programs[id] = ProgramData({\n            id: id,\n            pool: pool,\n            poolToken: poolToken,\n            rewardsToken: rewardsToken,\n            isEnabled: true,\n            startTime: startTime,\n            endTime: endTime,\n            rewardRate: rewardRate,\n            remainingRewards: rewardRate * (endTime - startTime)\n        });\n\n        // set the program as the latest program of the pool\n        _latestProgramIdByPool[pool] = id;\n\n        // increase the unclaimed rewards for the token by the total rewards in the new program\n        _unclaimedRewards[rewardsToken] = unclaimedRewards + totalRewards;\n\n        emit ProgramCreated({\n            pool: pool,\n            programId: id,\n            rewardsToken: rewardsToken,\n            totalRewards: totalRewards,\n            startTime: startTime,\n            endTime: endTime\n        });\n\n        return id;\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function terminateProgram(uint256 id) external onlyAdmin {\n        ProgramData memory p = _programs[id];\n\n        _verifyProgramActive(p);\n\n        // unset the program from being the latest program of the pool\n        delete _latestProgramIdByPool[p.pool];\n\n        // reduce the unclaimed rewards for the token by the remaining rewards\n        uint256 remainingRewards = _remainingRewards(p);\n        _unclaimedRewards[p.rewardsToken] -= remainingRewards;\n\n        // stop rewards accumulation\n        _programs[id].endTime = _time();\n\n        emit ProgramTerminated(p.pool, id, p.endTime, remainingRewards);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function enableProgram(uint256 id, bool status) external onlyAdmin {\n        ProgramData storage p = _programs[id];\n\n        _verifyProgramExists(p);\n\n        bool prevStatus = p.isEnabled;\n        if (prevStatus == status) {\n            return;\n        }\n\n        p.isEnabled = status;\n\n        emit ProgramEnabled({ pool: p.pool, programId: id, status: status, remainingRewards: _remainingRewards(p) });\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function join(uint256 id, uint256 poolTokenAmount) external greaterThanZero(poolTokenAmount) nonReentrant {\n        ProgramData memory p = _programs[id];\n\n        _verifyProgramActiveAndEnabled(p);\n\n        _join(msg.sender, p, poolTokenAmount, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function joinPermitted(\n        uint256 id,\n        uint256 poolTokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external greaterThanZero(poolTokenAmount) nonReentrant {\n        ProgramData memory p = _programs[id];\n\n        _verifyProgramActiveAndEnabled(p);\n\n        // permit the amount the caller is trying to stake. Please note, that if the base token doesn't support\n        // EIP2612 permit - either this call or the inner transferFrom will revert\n        p.poolToken.permit(msg.sender, address(this), poolTokenAmount, deadline, v, r, s);\n\n        _join(msg.sender, p, poolTokenAmount, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function leave(uint256 id, uint256 poolTokenAmount) external greaterThanZero(poolTokenAmount) nonReentrant {\n        ProgramData memory p = _programs[id];\n\n        _verifyProgramExists(p);\n\n        _leave(msg.sender, p, poolTokenAmount);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function depositAndJoin(uint256 id, uint256 tokenAmount)\n        external\n        payable\n        greaterThanZero(tokenAmount)\n        nonReentrant\n    {\n        ProgramData memory p = _programs[id];\n\n        _verifyProgramActiveAndEnabled(p);\n\n        _depositAndJoin(msg.sender, p, tokenAmount);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function depositAndJoinPermitted(\n        uint256 id,\n        uint256 tokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external greaterThanZero(tokenAmount) nonReentrant {\n        ProgramData memory p = _programs[id];\n\n        _verifyProgramActiveAndEnabled(p);\n\n        p.pool.permit(msg.sender, address(this), tokenAmount, deadline, Signature({ v: v, r: r, s: s }));\n\n        _depositAndJoin(msg.sender, p, tokenAmount);\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function pendingRewards(address provider, uint256[] calldata ids) external view uniqueArray(ids) returns (uint256) {\n        uint256 reward = 0;\n        Token rewardsToken;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n\n            ProgramData memory p = _programs[id];\n\n            _verifyProgramExists(p);\n\n            if (i == 0) {\n                rewardsToken = p.rewardsToken;\n            }\n\n            if (p.rewardsToken != rewardsToken) {\n                revert RewardsTokenMismatch();\n            }\n\n            uint256 newRewardPerToken = _rewardPerToken(p, _programRewards[id]);\n            ProviderRewards memory providerRewards = _providerRewards[provider][id];\n\n            reward += _pendingRewards(newRewardPerToken, providerRewards);\n        }\n\n        return reward;\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function claimRewards(uint256[] calldata ids) external uniqueArray(ids) nonReentrant returns (uint256) {\n        RewardData memory rewardData = _claimRewards(msg.sender, ids, false);\n\n        if (rewardData.amount == 0) {\n            return 0;\n        }\n\n        _distributeRewards(msg.sender, rewardData);\n\n        return rewardData.amount;\n    }\n\n    /**\n     * @inheritdoc IStandardRewards\n     */\n    function stakeRewards(uint256[] calldata ids) external uniqueArray(ids) nonReentrant returns (StakeAmounts memory) {\n        RewardData memory rewardData = _claimRewards(msg.sender, ids, true);\n\n        if (rewardData.amount == 0) {\n            return StakeAmounts({ stakedRewardAmount: 0, poolTokenAmount: 0 });\n        }\n\n        _distributeRewards(address(this), rewardData);\n\n        // deposit provider's tokens to the network. Please note, that since we're staking rewards, then the deposit\n        // should come from the contract itself, but the pool tokens should be sent to the provider directly\n        uint256 poolTokenAmount = _deposit(msg.sender, rewardData.rewardsToken, rewardData.amount, address(this));\n\n        return StakeAmounts({ stakedRewardAmount: rewardData.amount, poolTokenAmount: poolTokenAmount });\n    }\n\n    /**\n     * @dev adds provider's stake to the program\n     */\n    function _join(\n        address provider,\n        ProgramData memory p,\n        uint256 poolTokenAmount,\n        address payer\n    ) private {\n        // take a snapshot of the existing rewards (before increasing the stake)\n        ProviderRewards storage data = _snapshotRewards(p, provider);\n\n        // update both program and provider stakes\n        _programStakes[p.id] += poolTokenAmount;\n\n        uint256 prevStake = data.stakedAmount;\n        data.stakedAmount = prevStake + poolTokenAmount;\n\n        // unless the payer is the contract itself (in which case, no additional transfer is required), transfer the\n        // tokens from the payer (we aren't using safeTransferFrom, since the PoolToken is a fully compliant ERC20 token\n        // contract)\n        if (payer != address(this)) {\n            p.poolToken.transferFrom(payer, address(this), poolTokenAmount);\n        }\n\n        // add the program to the provider's program list\n        _programIdsByProvider[provider].add(p.id);\n\n        emit ProviderJoined({\n            pool: p.pool,\n            programId: p.id,\n            provider: provider,\n            poolTokenAmount: poolTokenAmount,\n            prevStake: prevStake\n        });\n    }\n\n    /**\n     * @dev removes (some of) provider's stake from the program\n     */\n    function _leave(\n        address provider,\n        ProgramData memory p,\n        uint256 poolTokenAmount\n    ) private {\n        // take a snapshot of the existing rewards (before decreasing the stake)\n        ProviderRewards storage data = _snapshotRewards(p, provider);\n\n        // update both program and provider stakes\n        _programStakes[p.id] -= poolTokenAmount;\n\n        uint256 remainingStake = data.stakedAmount - poolTokenAmount;\n        data.stakedAmount = remainingStake;\n\n        // transfer the tokens to the provider (we aren't using safeTransfer, since the PoolToken is a fully\n        // compliant ERC20 token contract)\n        p.poolToken.transfer(provider, poolTokenAmount);\n\n        // if the provider has removed all of its stake and there are no pending rewards - remove the program from the\n        // provider's program list\n        if (remainingStake == 0 && data.pendingRewards == 0) {\n            _programIdsByProvider[provider].remove(p.id);\n        }\n\n        emit ProviderLeft({\n            pool: p.pool,\n            programId: p.id,\n            provider: provider,\n            poolTokenAmount: poolTokenAmount,\n            remainingStake: remainingStake\n        });\n    }\n\n    /**\n     * @dev deposits provider's stake to the network and returns the received pool token amount\n     */\n    function _deposit(\n        address provider,\n        Token pool,\n        uint256 tokenAmount,\n        address payer\n    ) private returns (uint256) {\n        uint256 poolTokenAmount;\n        bool externalPayer = payer != address(this);\n\n        if (pool.isNative()) {\n            // unless the payer is the contract itself (e.g., during the staking process), in which case the native token\n            // was already claimed and pending in the contract - verify and use the received native token from the sender\n            if (externalPayer) {\n                if (msg.value < tokenAmount) {\n                    revert NativeTokenAmountMismatch();\n                }\n            }\n\n            poolTokenAmount = _network.depositFor{ value: tokenAmount }(provider, pool, tokenAmount);\n\n            // refund the caller for the remaining native token amount\n            if (externalPayer && msg.value > tokenAmount) {\n                payable(address(payer)).sendValue(msg.value - tokenAmount);\n            }\n        } else {\n            if (msg.value > 0) {\n                revert NativeTokenAmountMismatch();\n            }\n\n            // unless the payer is the contract itself (e.g., during the staking process), in which case the tokens were\n            // already claimed and pending in the contract - get the tokens from the provider\n            if (externalPayer) {\n                pool.safeTransferFrom(payer, address(this), tokenAmount);\n            }\n            pool.ensureApprove(address(_network), tokenAmount);\n\n            poolTokenAmount = _network.depositFor(provider, pool, tokenAmount);\n        }\n\n        return poolTokenAmount;\n    }\n\n    /**\n     * @dev deposits and adds provider's stake to the program\n     */\n    function _depositAndJoin(\n        address provider,\n        ProgramData memory p,\n        uint256 tokenAmount\n    ) private {\n        // deposit provider's tokens to the network and let the contract itself to claim the pool tokens so that it can\n        // immediately add them to a program\n        uint256 poolTokenAmount = _deposit(address(this), p.pool, tokenAmount, provider);\n\n        // join the existing program, but ensure not to attempt to transfer the tokens from the provider by setting the\n        // payer as the contract itself\n        _join(provider, p, poolTokenAmount, address(this));\n    }\n\n    /**\n     * @dev claims rewards\n     */\n    function _claimRewards(\n        address provider,\n        uint256[] calldata ids,\n        bool stake\n    ) private returns (RewardData memory) {\n        RewardData memory rewardData = RewardData({ rewardsToken: Token(address(0)), amount: 0 });\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            ProgramData memory p = _programs[ids[i]];\n\n            _verifyProgramEnabled(p);\n\n            if (i == 0) {\n                rewardData.rewardsToken = p.rewardsToken;\n            }\n\n            if (p.rewardsToken != rewardData.rewardsToken) {\n                revert RewardsTokenMismatch();\n            }\n\n            ClaimData memory claimData = _claimRewards(provider, p);\n\n            if (claimData.reward > 0) {\n                uint256 remainingRewards = p.remainingRewards;\n\n                // a sanity check that the reward amount doesn't exceed the remaining rewards per program\n                if (remainingRewards < claimData.reward) {\n                    revert RewardsTooHigh();\n                }\n\n                // decrease the remaining rewards per program\n                _programs[ids[i]].remainingRewards = remainingRewards - claimData.reward;\n\n                // collect same-reward token rewards\n                rewardData.amount += claimData.reward;\n            }\n\n            // if the program is no longer active, has no stake left, and there are no pending rewards - remove the\n            // program from the provider's program list\n            if (!_isProgramActive(p) && claimData.stakedAmount == 0) {\n                _programIdsByProvider[provider].remove(p.id);\n            }\n\n            if (stake) {\n                emit RewardsStaked({ pool: p.pool, programId: p.id, provider: provider, amount: claimData.reward });\n            } else {\n                emit RewardsClaimed({ pool: p.pool, programId: p.id, provider: provider, amount: claimData.reward });\n            }\n        }\n\n        // decrease the unclaimed rewards for the token by the total claimed rewards\n        _unclaimedRewards[rewardData.rewardsToken] -= rewardData.amount;\n\n        return rewardData;\n    }\n\n    /**\n     * @dev claims rewards and returns the received and the pending reward amounts\n     */\n    function _claimRewards(address provider, ProgramData memory p) internal returns (ClaimData memory) {\n        ProviderRewards storage providerRewards = _snapshotRewards(p, provider);\n\n        uint256 reward = providerRewards.pendingRewards;\n\n        providerRewards.pendingRewards = 0;\n\n        return ClaimData({ reward: reward, stakedAmount: providerRewards.stakedAmount });\n    }\n\n    /**\n     * @dev returns whether the specified program is active\n     */\n    function _isProgramActive(ProgramData memory p) private view returns (bool) {\n        uint32 currTime = _time();\n\n        return\n            _doesProgramExist(p) &&\n            p.startTime <= currTime &&\n            currTime <= p.endTime &&\n            _latestProgramIdByPool[p.pool] == p.id;\n    }\n\n    /**\n     * @dev returns whether the specified program is active\n     */\n    function _isProgramEnabled(ProgramData memory p) private pure returns (bool) {\n        return p.isEnabled;\n    }\n\n    /**\n     * @dev returns whether or not a given program exists\n     */\n    function _doesProgramExist(ProgramData memory p) private pure returns (bool) {\n        return address(p.pool) != address(0);\n    }\n\n    /**\n     * @dev verifies that a program exists\n     */\n    function _verifyProgramExists(ProgramData memory p) private pure {\n        if (!_doesProgramExist(p)) {\n            revert DoesNotExist();\n        }\n    }\n\n    /**\n     * @dev verifies that a program exists, and active\n     */\n    function _verifyProgramActive(ProgramData memory p) private view {\n        _verifyProgramExists(p);\n\n        if (!_isProgramActive(p)) {\n            revert ProgramInactive();\n        }\n    }\n\n    /**\n     * @dev verifies that a program is enabled\n     */\n    function _verifyProgramEnabled(ProgramData memory p) private pure {\n        _verifyProgramExists(p);\n\n        if (!p.isEnabled) {\n            revert ProgramDisabled();\n        }\n    }\n\n    /**\n     * @dev verifies that a program exists, active, and enabled\n     */\n    function _verifyProgramActiveAndEnabled(ProgramData memory p) private view {\n        _verifyProgramActive(p);\n        _verifyProgramEnabled(p);\n    }\n\n    /**\n     * @dev returns the remaining rewards of given program\n     */\n    function _remainingRewards(ProgramData memory p) private view returns (uint256) {\n        uint32 currTime = _time();\n\n        return p.endTime > currTime ? p.rewardRate * (p.endTime - currTime) : 0;\n    }\n\n    /**\n     * @dev updates program and provider's rewards\n     */\n    function _snapshotRewards(ProgramData memory p, address provider) private returns (ProviderRewards storage) {\n        Rewards storage rewards = _programRewards[p.id];\n\n        uint256 newRewardPerToken = _rewardPerToken(p, rewards);\n        if (newRewardPerToken != rewards.rewardPerToken) {\n            rewards.rewardPerToken = newRewardPerToken;\n        }\n\n        uint32 newUpdateTime = uint32(Math.min(_time(), p.endTime));\n        if (rewards.lastUpdateTime < newUpdateTime) {\n            rewards.lastUpdateTime = newUpdateTime;\n        }\n\n        ProviderRewards storage providerRewards = _providerRewards[provider][p.id];\n\n        uint256 newPendingRewards = _pendingRewards(newRewardPerToken, providerRewards);\n        if (newPendingRewards != 0) {\n            providerRewards.rewardPerTokenPaid = newRewardPerToken;\n            providerRewards.pendingRewards = newPendingRewards;\n        }\n\n        return providerRewards;\n    }\n\n    /**\n     * @dev calculates current reward per-token amount\n     */\n    function _rewardPerToken(ProgramData memory p, Rewards memory rewards) private view returns (uint256) {\n        uint256 currTime = _time();\n        if (currTime < p.startTime) {\n            return 0;\n        }\n\n        uint256 totalStaked = _programStakes[p.id];\n        if (totalStaked == 0) {\n            return rewards.rewardPerToken;\n        }\n\n        uint256 stakingEndTime = Math.min(currTime, p.endTime);\n        uint256 stakingStartTime = Math.max(p.startTime, rewards.lastUpdateTime);\n\n        return\n            rewards.rewardPerToken +\n            (((stakingEndTime - stakingStartTime) * p.rewardRate * REWARD_RATE_FACTOR) / totalStaked);\n    }\n\n    /**\n     * @dev calculates provider's pending rewards\n     */\n    function _pendingRewards(uint256 updatedRewardPerToken, ProviderRewards memory providerRewards)\n        private\n        pure\n        returns (uint256)\n    {\n        return\n            providerRewards.pendingRewards +\n            (providerRewards.stakedAmount * (updatedRewardPerToken - providerRewards.rewardPerTokenPaid)) /\n            REWARD_RATE_FACTOR;\n    }\n\n    /**\n     * @dev distributes reward\n     */\n    function _distributeRewards(address recipient, RewardData memory rewardData) private {\n        if (rewardData.rewardsToken.isEqual(_bnt)) {\n            _bntGovernance.mint(recipient, rewardData.amount);\n        } else {\n            _externalRewardsVault.withdrawFunds(rewardData.rewardsToken, payable(recipient), rewardData.amount);\n        }\n    }\n\n    /**\n     * @dev returns whether the specified array has duplicates\n     */\n    function _isArrayUnique(uint256[] calldata ids) private pure returns (bool) {\n        for (uint256 i = 0; i < ids.length; i++) {\n            for (uint256 j = i + 1; j < ids.length; j++) {\n                if (ids[i] == ids[j]) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/utility/Time.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\n/**\n * @dev this contract abstracts the block timestamp in order to allow for more flexible control in tests\n */\ncontract Time {\n    /**\n     * @dev returns the current time\n     */\n    function _time() internal view virtual returns (uint32) {\n        return uint32(block.timestamp);\n    }\n}\n"
    },
    "contracts/rewards/interfaces/IStandardRewards.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\nimport { IPoolToken } from \"../../pools/interfaces/IPoolToken.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\nstruct ProgramData {\n    uint256 id;\n    Token pool;\n    IPoolToken poolToken;\n    Token rewardsToken;\n    bool isEnabled;\n    uint32 startTime;\n    uint32 endTime;\n    uint256 rewardRate;\n    uint256 remainingRewards;\n}\n\nstruct StakeAmounts {\n    uint256 stakedRewardAmount;\n    uint256 poolTokenAmount;\n}\n\ninterface IStandardRewards is IUpgradeable {\n    /**\n     * @dev returns all program ids\n     */\n    function programIds() external view returns (uint256[] memory);\n\n    /**\n     * @dev returns program data for each specified program id\n     */\n    function programs(uint256[] calldata ids) external view returns (ProgramData[] memory);\n\n    /**\n     * @dev returns all the program ids that the provider participates in\n     */\n    function providerProgramIds(address provider) external view returns (uint256[] memory);\n\n    /**\n     * @dev returns the total staked amount in a specific program\n     */\n    function programStake(uint256 id) external view returns (uint256);\n\n    /**\n     * @dev returns the total staked amount of a specific provider in a specific program\n     */\n    function providerStake(address provider, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev returns whether the specified program is active\n     */\n    function isProgramActive(uint256 id) external view returns (bool);\n\n    /**\n     * @dev returns whether the specified program is enabled\n     */\n    function isProgramEnabled(uint256 id) external view returns (bool);\n\n    /**\n     * @dev returns the ID of the latest program for a given pool (or 0 if no program is currently set)\n     */\n    function latestProgramId(Token pool) external view returns (uint256);\n\n    /**\n     * @dev creates a program for a pool and returns its ID\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     * - the pool must not have an active program\n     * - if the rewards token isn't the BNT token, then the rewards must have been deposited to the rewards vault\n     */\n    function createProgram(\n        Token pool,\n        Token rewardsToken,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 endTime\n    ) external returns (uint256);\n\n    /**\n     * @dev terminates a rewards program\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     * - the program must exist and be the active program for its pool\n     */\n    function terminateProgram(uint256 id) external;\n\n    /**\n     * @dev enables or disables a program\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function enableProgram(uint256 id, bool status) external;\n\n    /**\n     * @dev adds a provider to the program\n     *\n     * requirements:\n     *\n     * - the caller must have approved the contract to transfer pool tokens on its behalf\n     */\n    function join(uint256 id, uint256 poolTokenAmount) external;\n\n    /**\n     * @dev adds provider's stake to the program by providing an EIP712 typed signature for an EIP2612 permit request\n     *\n     * requirements:\n     *\n     * - the caller must have specified a valid and unused EIP712 typed signature\n     */\n    function joinPermitted(\n        uint256 id,\n        uint256 poolTokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev removes (some of) provider's stake from the program\n     *\n     * requirements:\n     *\n     * - the caller must have specified a valid and unused EIP712 typed signature\n     */\n    function leave(uint256 id, uint256 poolTokenAmount) external;\n\n    /**\n     * @dev deposits and adds provider's stake to the program\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network contract to transfer the tokens its behalf (except for in the\n     *   native token case)\n     */\n    function depositAndJoin(uint256 id, uint256 tokenAmount) external payable;\n\n    /**\n     * @dev deposits and adds provider's stake to the program by providing an EIP712 typed signature for an EIP2612\n     * permit request\n     *\n     * requirements:\n     *\n     * - the caller must have specified a valid and unused EIP712 typed signature\n     */\n    function depositAndJoinPermitted(\n        uint256 id,\n        uint256 tokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev returns provider's pending rewards\n     *\n     * requirements:\n     *\n     * - the specified program ids array needs to consist from unique and existing program ids with the same reward\n     *   token\n     */\n    function pendingRewards(address provider, uint256[] calldata ids) external view returns (uint256);\n\n    /**\n     * @dev claims rewards and returns the claimed reward amount\n     */\n    function claimRewards(uint256[] calldata ids) external returns (uint256);\n\n    /**\n     * @dev claims and stake rewards and returns the claimed reward amount and the received pool token amount\n     *\n     * requirements:\n     *\n     * - the specified program ids array needs to consist from unique and existing program ids with the same reward\n     *   token\n     * - the rewards token must have been whitelisted with an existing pool\n     */\n    function stakeRewards(uint256[] calldata ids) external returns (StakeAmounts memory);\n}\n"
    },
    "contracts/pools/PoolCollection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\nimport { IExternalProtectionVault } from \"../vaults/interfaces/IExternalProtectionVault.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\n\nimport { PPM_RESOLUTION } from \"../utility/Constants.sol\";\nimport { Owned } from \"../utility/Owned.sol\";\nimport { BlockNumber } from \"../utility/BlockNumber.sol\";\nimport { Fraction, Fraction112, FractionLibrary, zeroFraction, zeroFraction112 } from \"../utility/FractionLibrary.sol\";\nimport { Sint256, MathEx } from \"../utility/MathEx.sol\";\n\n// prettier-ignore\nimport {\n    Utils,\n    AlreadyExists,\n    DoesNotExist,\n    InvalidPoolCollection,\n    InvalidStakedBalance\n} from \"../utility/Utils.sol\";\n\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { IPoolToken } from \"./interfaces/IPoolToken.sol\";\nimport { IPoolTokenFactory } from \"./interfaces/IPoolTokenFactory.sol\";\nimport { IPoolMigrator } from \"./interfaces/IPoolMigrator.sol\";\n\n// prettier-ignore\nimport {\n    AverageRate,\n    IPoolCollection,\n    PoolLiquidity,\n    Pool,\n    TRADING_STATUS_UPDATE_DEFAULT,\n    TRADING_STATUS_UPDATE_ADMIN,\n    TRADING_STATUS_UPDATE_MIN_LIQUIDITY,\n    TradeAmountAndFee,\n    WithdrawalAmounts\n} from \"./interfaces/IPoolCollection.sol\";\n\nimport { IBNTPool } from \"./interfaces/IBNTPool.sol\";\n\nimport { PoolCollectionWithdrawal } from \"./PoolCollectionWithdrawal.sol\";\n\n// base token withdrawal output amounts\nstruct InternalWithdrawalAmounts {\n    uint256 baseTokensToTransferFromMasterVault; // base token amount to transfer from the master vault to the provider\n    uint256 bntToMintForProvider; // BNT amount to mint directly for the provider\n    uint256 baseTokensToTransferFromEPV; // base token amount to transfer from the external protection vault to the provider\n    Sint256 baseTokensTradingLiquidityDelta; // base token amount to add to the trading liquidity\n    Sint256 bntTradingLiquidityDelta; // BNT amount to add to the trading liquidity and to the master vault\n    Sint256 bntProtocolHoldingsDelta; // BNT amount add to the protocol equity\n    uint256 baseTokensWithdrawalFee; // base token amount to keep in the pool as a withdrawal fee\n    uint256 baseTokensWithdrawalAmount; // base token amount equivalent to the base pool token's withdrawal amount\n    uint256 poolTokenTotalSupply; // base pool token's total supply\n    uint256 newBaseTokenTradingLiquidity; // new base token trading liquidity\n    uint256 newBNTTradingLiquidity; // new BNT trading liquidity\n}\n\nstruct TradingLiquidityAction {\n    bool update;\n    uint256 newAmount;\n}\n\nenum PoolRateState {\n    Uninitialized,\n    Unstable,\n    Stable\n}\n\n/**\n * @dev Pool Collection contract\n *\n * notes:\n *\n * - the address of reserve token serves as the pool unique ID in both contract functions and events\n */\ncontract PoolCollection is IPoolCollection, Owned, BlockNumber, Utils {\n    using TokenLibrary for Token;\n    using FractionLibrary for Fraction;\n    using FractionLibrary for Fraction112;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    error AlreadyEnabled();\n    error DepositLimitExceeded();\n    error DepositingDisabled();\n    error InsufficientLiquidity();\n    error InsufficientSourceAmount();\n    error InsufficientTargetAmount();\n    error InvalidRate();\n    error RateUnstable();\n    error TradingDisabled();\n\n    uint16 private constant POOL_TYPE = 1;\n    uint256 private constant LIQUIDITY_GROWTH_FACTOR = 2;\n    uint256 private constant BOOTSTRAPPING_LIQUIDITY_BUFFER_FACTOR = 2;\n    uint32 private constant DEFAULT_TRADING_FEE_PPM = 2000; // 0.2%\n    uint32 private constant RATE_MAX_DEVIATION_PPM = 10000; // %1\n\n    // the average rate is recalculated based on the ratio between the weights of the rates the smaller the weights are,\n    // the larger the supported range of each one of the rates is\n    uint256 private constant EMA_AVERAGE_RATE_WEIGHT = 4;\n    uint256 private constant EMA_SPOT_RATE_WEIGHT = 1;\n\n    struct TradeIntermediateResult {\n        uint256 sourceAmount;\n        uint256 targetAmount;\n        uint256 limit;\n        uint256 tradingFeeAmount;\n        uint256 networkFeeAmount;\n        uint256 sourceBalance;\n        uint256 targetBalance;\n        uint256 stakedBalance;\n        Token pool;\n        bool isSourceBNT;\n        bool bySourceAmount;\n        uint32 tradingFeePPM;\n        bytes32 contextId;\n    }\n\n    struct TradeAmountAndTradingFee {\n        uint256 amount;\n        uint256 tradingFeeAmount;\n    }\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the address of the BNT token\n    IERC20 private immutable _bnt;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the master vault contract\n    IMasterVault private immutable _masterVault;\n\n    // the BNT pool contract\n    IBNTPool internal immutable _bntPool;\n\n    // the address of the external protection vault\n    IExternalProtectionVault private immutable _externalProtectionVault;\n\n    // the pool token factory contract\n    IPoolTokenFactory private immutable _poolTokenFactory;\n\n    // the pool migrator contract\n    IPoolMigrator private immutable _poolMigrator;\n\n    // a mapping between tokens and their pools\n    mapping(Token => Pool) internal _poolData;\n\n    // the set of all pools which are managed by this pool collection\n    EnumerableSet.AddressSet private _pools;\n\n    // the default trading fee (in units of PPM)\n    uint32 private _defaultTradingFeePPM;\n\n    /**\n     * @dev triggered when a pool is created\n     */\n    event PoolCreated(IPoolToken indexed poolToken, Token indexed token);\n\n    /**\n     * @dev triggered when a pool is migrated into this pool collection\n     */\n    event PoolMigratedIn(Token indexed token);\n\n    /**\n     * @dev triggered when a pool is migrated out of this pool collection\n     */\n    event PoolMigratedOut(Token indexed token);\n\n    /**\n     * @dev triggered when the default trading fee is updated\n     */\n    event DefaultTradingFeePPMUpdated(uint32 prevFeePPM, uint32 newFeePPM);\n\n    /**\n     * @dev triggered when a specific pool's trading fee is updated\n     */\n    event TradingFeePPMUpdated(Token indexed pool, uint32 prevFeePPM, uint32 newFeePPM);\n\n    /**\n     * @dev triggered when trading in a specific pool is enabled/disabled\n     */\n    event TradingEnabled(Token indexed pool, bool indexed newStatus, uint8 indexed reason);\n\n    /**\n     * @dev triggered when depositing into a specific pool is enabled/disabled\n     */\n    event DepositingEnabled(Token indexed pool, bool indexed newStatus);\n\n    /**\n     * @dev triggered when a pool's deposit limit is updated\n     */\n    event DepositLimitUpdated(Token indexed pool, uint256 prevDepositLimit, uint256 newDepositLimit);\n\n    /**\n     * @dev triggered when new liquidity is deposited into a pool\n     */\n    event TokensDeposited(\n        bytes32 indexed contextId,\n        address indexed provider,\n        Token indexed token,\n        uint256 tokenAmount,\n        uint256 poolTokenAmount\n    );\n\n    /**\n     * @dev triggered when existing liquidity is withdrawn from a pool\n     */\n    event TokensWithdrawn(\n        bytes32 indexed contextId,\n        address indexed provider,\n        Token indexed token,\n        uint256 tokenAmount,\n        uint256 poolTokenAmount,\n        uint256 externalProtectionBaseTokenAmount,\n        uint256 bntAmount,\n        uint256 withdrawalFeeAmount\n    );\n\n    /**\n     * @dev triggered when the trading liquidity in a pool is updated\n     */\n    event TradingLiquidityUpdated(\n        bytes32 indexed contextId,\n        Token indexed pool,\n        Token indexed token,\n        uint256 prevLiquidity,\n        uint256 newLiquidity\n    );\n\n    /**\n     * @dev triggered when the total liquidity in a pool is updated\n     */\n    event TotalLiquidityUpdated(\n        bytes32 indexed contextId,\n        Token indexed pool,\n        uint256 liquidity,\n        uint256 stakedBalance,\n        uint256 poolTokenSupply\n    );\n\n    /**\n     * @dev initializes a new PoolCollection contract\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        IERC20 initBNT,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IBNTPool initBNTPool,\n        IExternalProtectionVault initExternalProtectionVault,\n        IPoolTokenFactory initPoolTokenFactory,\n        IPoolMigrator initPoolMigrator\n    )\n        validAddress(address(initNetwork))\n        validAddress(address(initBNT))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initMasterVault))\n        validAddress(address(initBNTPool))\n        validAddress(address(initExternalProtectionVault))\n        validAddress(address(initPoolTokenFactory))\n        validAddress(address(initPoolMigrator))\n    {\n        _network = initNetwork;\n        _bnt = initBNT;\n        _networkSettings = initNetworkSettings;\n        _masterVault = initMasterVault;\n        _bntPool = initBNTPool;\n        _externalProtectionVault = initExternalProtectionVault;\n        _poolTokenFactory = initPoolTokenFactory;\n        _poolMigrator = initPoolMigrator;\n\n        _setDefaultTradingFeePPM(DEFAULT_TRADING_FEE_PPM);\n    }\n\n    /**\n     * @inheritdoc IVersioned\n     */\n    function version() external view virtual returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolType() external pure returns (uint16) {\n        return POOL_TYPE;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function defaultTradingFeePPM() external view returns (uint32) {\n        return _defaultTradingFeePPM;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function pools() external view returns (Token[] memory) {\n        uint256 length = _pools.length();\n        Token[] memory list = new Token[](length);\n        for (uint256 i = 0; i < length; i++) {\n            list[i] = Token(_pools.at(i));\n        }\n        return list;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolCount() external view returns (uint256) {\n        return _pools.length();\n    }\n\n    /**\n     * @dev sets the default trading fee (in units of PPM)\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function setDefaultTradingFeePPM(uint32 newDefaultTradingFeePPM)\n        external\n        onlyOwner\n        validFee(newDefaultTradingFeePPM)\n    {\n        _setDefaultTradingFeePPM(newDefaultTradingFeePPM);\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function createPool(Token token) external only(address(_network)) {\n        if (!_networkSettings.isTokenWhitelisted(token)) {\n            revert NotWhitelisted();\n        }\n\n        IPoolToken newPoolToken = IPoolToken(_poolTokenFactory.createPoolToken(token));\n\n        newPoolToken.acceptOwnership();\n\n        Pool memory newPool = Pool({\n            poolToken: newPoolToken,\n            tradingFeePPM: _defaultTradingFeePPM,\n            tradingEnabled: false,\n            depositingEnabled: true,\n            averageRate: AverageRate({ blockNumber: 0, rate: zeroFraction112() }),\n            depositLimit: 0,\n            liquidity: PoolLiquidity({ bntTradingLiquidity: 0, baseTokenTradingLiquidity: 0, stakedBalance: 0 })\n        });\n\n        _addPool(token, newPool);\n\n        emit PoolCreated({ poolToken: newPoolToken, token: token });\n\n        emit TradingEnabled({ pool: token, newStatus: false, reason: TRADING_STATUS_UPDATE_DEFAULT });\n        emit TradingFeePPMUpdated({ pool: token, prevFeePPM: 0, newFeePPM: newPool.tradingFeePPM });\n        emit DepositingEnabled({ pool: token, newStatus: newPool.depositingEnabled });\n        emit DepositLimitUpdated({ pool: token, prevDepositLimit: 0, newDepositLimit: newPool.depositLimit });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function isPoolValid(Token pool) external view returns (bool) {\n        return address(_poolData[pool].poolToken) != address(0);\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolData(Token pool) external view returns (Pool memory) {\n        return _poolData[pool];\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolLiquidity(Token pool) external view returns (PoolLiquidity memory) {\n        return _poolData[pool].liquidity;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolToken(Token pool) external view returns (IPoolToken) {\n        return _poolData[pool].poolToken;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) external view returns (uint256) {\n        Pool storage data = _poolData[pool];\n\n        return _poolTokenToUnderlying(poolTokenAmount, data.poolToken.totalSupply(), data.liquidity.stakedBalance);\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function underlyingToPoolToken(Token pool, uint256 tokenAmount) external view returns (uint256) {\n        Pool storage data = _poolData[pool];\n\n        return _underlyingToPoolToken(tokenAmount, data.poolToken.totalSupply(), data.liquidity.stakedBalance);\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolTokenAmountToBurn(\n        Token pool,\n        uint256 tokenAmountToDistribute,\n        uint256 protocolPoolTokenAmount\n    ) external view returns (uint256) {\n        if (tokenAmountToDistribute == 0) {\n            return 0;\n        }\n\n        Pool storage data = _poolData[pool];\n\n        uint256 poolTokenSupply = data.poolToken.totalSupply();\n        uint256 val = tokenAmountToDistribute * poolTokenSupply;\n\n        return\n            MathEx.mulDivF(\n                val,\n                poolTokenSupply,\n                val + data.liquidity.stakedBalance * (poolTokenSupply - protocolPoolTokenAmount)\n            );\n    }\n\n    /**\n     * @dev sets the trading fee of a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function setTradingFeePPM(Token pool, uint32 newTradingFeePPM) external onlyOwner validFee(newTradingFeePPM) {\n        Pool storage data = _poolStorage(pool);\n\n        uint32 prevTradingFeePPM = data.tradingFeePPM;\n        if (prevTradingFeePPM == newTradingFeePPM) {\n            return;\n        }\n\n        data.tradingFeePPM = newTradingFeePPM;\n\n        emit TradingFeePPMUpdated({ pool: pool, prevFeePPM: prevTradingFeePPM, newFeePPM: newTradingFeePPM });\n    }\n\n    /**\n     * @dev enables trading in a given pool, by providing the funding rate as two virtual balances, and updates its\n     * trading liquidity\n     *\n     * please note that the virtual balances should be derived from token prices, normalized to the smallest unit of\n     * tokens. For example:\n     *\n     * - if the price of one (10**18 wei) BNT is $X and the price of one (10**18 wei) TKN is $Y, then the virtual balances\n     *   should represent a ratio of X to Y\n     * - if the price of one (10**18 wei) BNT is $X and the price of one (10**6 wei) USDC is $Y, then the virtual balances\n     *   should represent a ratio of X to Y*10**12\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function enableTrading(\n        Token pool,\n        uint256 bntVirtualBalance,\n        uint256 baseTokenVirtualBalance\n    ) external onlyOwner {\n        Fraction memory fundingRate = Fraction({ n: bntVirtualBalance, d: baseTokenVirtualBalance });\n        _validRate(fundingRate);\n\n        Pool storage data = _poolStorage(pool);\n\n        if (data.tradingEnabled) {\n            revert AlreadyEnabled();\n        }\n\n        // adjust the trading liquidity based on the base token vault balance and funding limits\n        uint256 minLiquidityForTrading = _networkSettings.minLiquidityForTrading();\n        _updateTradingLiquidity(bytes32(0), pool, data, data.liquidity, fundingRate, minLiquidityForTrading);\n\n        // verify that the BNT trading liquidity is equal or greater than the minimum liquidity for trading\n        if (data.liquidity.bntTradingLiquidity < minLiquidityForTrading) {\n            revert InsufficientLiquidity();\n        }\n\n        data.averageRate = AverageRate({ blockNumber: _blockNumber(), rate: fundingRate.toFraction112() });\n\n        data.tradingEnabled = true;\n\n        emit TradingEnabled({ pool: pool, newStatus: true, reason: TRADING_STATUS_UPDATE_ADMIN });\n    }\n\n    /**\n     * @dev disables trading in a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function disableTrading(Token pool) external onlyOwner {\n        Pool storage data = _poolStorage(pool);\n\n        _resetTradingLiquidity(bytes32(0), pool, data, TRADING_STATUS_UPDATE_ADMIN);\n    }\n\n    /**\n     * @dev enables/disables depositing into a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function enableDepositing(Token pool, bool status) external onlyOwner {\n        Pool storage data = _poolStorage(pool);\n\n        if (data.depositingEnabled == status) {\n            return;\n        }\n\n        data.depositingEnabled = status;\n\n        emit DepositingEnabled({ pool: pool, newStatus: status });\n    }\n\n    /**\n     * @dev sets the deposit limit of a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function setDepositLimit(Token pool, uint256 newDepositLimit) external onlyOwner {\n        Pool storage data = _poolStorage(pool);\n\n        uint256 prevDepositLimit = data.depositLimit;\n        if (prevDepositLimit == newDepositLimit) {\n            return;\n        }\n\n        data.depositLimit = newDepositLimit;\n\n        emit DepositLimitUpdated({ pool: pool, prevDepositLimit: prevDepositLimit, newDepositLimit: newDepositLimit });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function depositFor(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 tokenAmount\n    ) external only(address(_network)) validAddress(provider) greaterThanZero(tokenAmount) returns (uint256) {\n        Pool storage data = _poolStorage(pool);\n\n        if (!data.depositingEnabled) {\n            revert DepositingDisabled();\n        }\n\n        // calculate the pool token amount to mint\n        uint256 currentStakedBalance = data.liquidity.stakedBalance;\n        uint256 prevPoolTokenTotalSupply = data.poolToken.totalSupply();\n        uint256 poolTokenAmount = _underlyingToPoolToken(tokenAmount, prevPoolTokenTotalSupply, currentStakedBalance);\n\n        // verify that the staked balance and the newly deposited amount isn't higher than the deposit limit\n        uint256 newStakedBalance = currentStakedBalance + tokenAmount;\n        if (newStakedBalance > data.depositLimit) {\n            revert DepositLimitExceeded();\n        }\n\n        PoolLiquidity memory prevLiquidity = data.liquidity;\n\n        // update the staked balance with the full base token amount\n        data.liquidity.stakedBalance = newStakedBalance;\n\n        // mint pool tokens to the provider\n        data.poolToken.mint(provider, poolTokenAmount);\n\n        // adjust the trading liquidity based on the base token vault balance and funding limits\n        _updateTradingLiquidity(\n            contextId,\n            pool,\n            data,\n            data.liquidity,\n            data.averageRate.rate.fromFraction112(),\n            _networkSettings.minLiquidityForTrading()\n        );\n\n        emit TokensDeposited({\n            contextId: contextId,\n            provider: provider,\n            token: pool,\n            tokenAmount: tokenAmount,\n            poolTokenAmount: poolTokenAmount\n        });\n\n        _dispatchTradingLiquidityEvents(\n            contextId,\n            pool,\n            prevPoolTokenTotalSupply + poolTokenAmount,\n            prevLiquidity,\n            data.liquidity\n        );\n\n        return poolTokenAmount;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function withdraw(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 poolTokenAmount\n    ) external only(address(_network)) validAddress(provider) greaterThanZero(poolTokenAmount) returns (uint256) {\n        Pool storage data = _poolStorage(pool);\n\n        // obtain the withdrawal amounts\n        InternalWithdrawalAmounts memory amounts = _poolWithdrawalAmounts(pool, data, poolTokenAmount);\n\n        // execute the actual withdrawal\n        _executeWithdrawal(contextId, provider, pool, data, poolTokenAmount, amounts);\n\n        return amounts.baseTokensToTransferFromMasterVault;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function withdrawalAmounts(Token pool, uint256 poolTokenAmount)\n        external\n        view\n        validAddress(address(pool))\n        greaterThanZero(poolTokenAmount)\n        returns (WithdrawalAmounts memory)\n    {\n        InternalWithdrawalAmounts memory amounts = _poolWithdrawalAmounts(pool, _poolStorage(pool), poolTokenAmount);\n\n        return\n            WithdrawalAmounts({\n                totalAmount: amounts.baseTokensWithdrawalAmount - amounts.baseTokensWithdrawalFee,\n                baseTokenAmount: amounts.baseTokensToTransferFromMasterVault + amounts.baseTokensToTransferFromEPV,\n                bntAmount: amounts.bntToMintForProvider\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeBySourceAmount(\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount\n    )\n        external\n        only(address(_network))\n        greaterThanZero(sourceAmount)\n        greaterThanZero(minReturnAmount)\n        returns (TradeAmountAndFee memory)\n    {\n        TradeIntermediateResult memory result = _initTrade(\n            contextId,\n            sourceToken,\n            targetToken,\n            sourceAmount,\n            minReturnAmount,\n            true\n        );\n\n        _performTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.targetAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeByTargetAmount(\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount\n    )\n        external\n        only(address(_network))\n        greaterThanZero(targetAmount)\n        greaterThanZero(maxSourceAmount)\n        returns (TradeAmountAndFee memory)\n    {\n        TradeIntermediateResult memory result = _initTrade(\n            contextId,\n            sourceToken,\n            targetToken,\n            targetAmount,\n            maxSourceAmount,\n            false\n        );\n\n        _performTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.sourceAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeOutputAndFeeBySourceAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount\n    ) external view greaterThanZero(sourceAmount) returns (TradeAmountAndFee memory) {\n        TradeIntermediateResult memory result = _initTrade(bytes32(0), sourceToken, targetToken, sourceAmount, 1, true);\n\n        _processTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.targetAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeInputAndFeeByTargetAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount\n    ) external view greaterThanZero(targetAmount) returns (TradeAmountAndFee memory) {\n        TradeIntermediateResult memory result = _initTrade(\n            bytes32(0),\n            sourceToken,\n            targetToken,\n            targetAmount,\n            type(uint256).max,\n            false\n        );\n\n        _processTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.sourceAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function onFeesCollected(Token pool, uint256 feeAmount) external only(address(_network)) {\n        if (feeAmount == 0) {\n            return;\n        }\n\n        Pool storage data = _poolStorage(pool);\n\n        // increase the staked balance by the given amount\n        data.liquidity.stakedBalance += feeAmount;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function migratePoolIn(Token pool, Pool calldata data)\n        external\n        validAddress(address(pool))\n        only(address(_poolMigrator))\n    {\n        _addPool(pool, data);\n\n        data.poolToken.acceptOwnership();\n\n        emit PoolMigratedIn({ token: pool });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function migratePoolOut(Token pool, IPoolCollection targetPoolCollection)\n        external\n        validAddress(address(targetPoolCollection))\n        only(address(_poolMigrator))\n    {\n        if (_network.latestPoolCollection(POOL_TYPE) != targetPoolCollection) {\n            revert InvalidPoolCollection();\n        }\n\n        IPoolToken cachedPoolToken = _poolData[pool].poolToken;\n\n        _removePool(pool);\n\n        cachedPoolToken.transferOwnership(address(targetPoolCollection));\n\n        emit PoolMigratedOut({ token: pool });\n    }\n\n    /**\n     * @dev adds a pool\n     */\n    function _addPool(Token pool, Pool memory data) private {\n        if (!_pools.add(address(pool))) {\n            revert AlreadyExists();\n        }\n\n        _poolData[pool] = data;\n    }\n\n    /**\n     * @dev removes a pool\n     */\n    function _removePool(Token pool) private {\n        if (!_pools.remove(address(pool))) {\n            revert DoesNotExist();\n        }\n\n        delete _poolData[pool];\n    }\n\n    /**\n     * @dev returns withdrawal amounts\n     */\n    function _poolWithdrawalAmounts(\n        Token pool,\n        Pool memory data,\n        uint256 poolTokenAmount\n    ) internal view returns (InternalWithdrawalAmounts memory) {\n        // the base token trading liquidity of a given pool can never be higher than the base token balance of the vault\n        // whenever the base token trading liquidity is updated, it is set to at most the base token balance of the vault\n        uint256 baseTokenExcessAmount = pool.balanceOf(address(_masterVault)) -\n            data.liquidity.baseTokenTradingLiquidity;\n\n        uint256 poolTokenTotalSupply = data.poolToken.totalSupply();\n\n        uint256 baseTokensWithdrawalAmount = _poolTokenToUnderlying(\n            poolTokenAmount,\n            poolTokenTotalSupply,\n            data.liquidity.stakedBalance\n        );\n\n        PoolCollectionWithdrawal.Output memory output = PoolCollectionWithdrawal.calculateWithdrawalAmounts(\n            data.liquidity.bntTradingLiquidity,\n            data.liquidity.baseTokenTradingLiquidity,\n            baseTokenExcessAmount,\n            data.liquidity.stakedBalance,\n            pool.balanceOf(address(_externalProtectionVault)),\n            data.tradingFeePPM,\n            _networkSettings.withdrawalFeePPM(),\n            baseTokensWithdrawalAmount\n        );\n\n        return\n            InternalWithdrawalAmounts({\n                baseTokensToTransferFromMasterVault: output.s,\n                bntToMintForProvider: output.t,\n                baseTokensToTransferFromEPV: output.u,\n                baseTokensTradingLiquidityDelta: output.r,\n                bntTradingLiquidityDelta: output.p,\n                bntProtocolHoldingsDelta: output.q,\n                baseTokensWithdrawalFee: output.v,\n                baseTokensWithdrawalAmount: baseTokensWithdrawalAmount,\n                poolTokenTotalSupply: poolTokenTotalSupply,\n                newBaseTokenTradingLiquidity: output.r.isNeg\n                    ? data.liquidity.baseTokenTradingLiquidity - output.r.value\n                    : data.liquidity.baseTokenTradingLiquidity + output.r.value,\n                newBNTTradingLiquidity: output.p.isNeg\n                    ? data.liquidity.bntTradingLiquidity - output.p.value\n                    : data.liquidity.bntTradingLiquidity + output.p.value\n            });\n    }\n\n    /**\n     * @dev executes the following actions:\n     *\n     * - burn the network's base pool tokens\n     * - update the pool's base token staked balance\n     * - update the pool's base token trading liquidity\n     * - update the pool's BNT trading liquidity\n     * - update the pool's trading liquidity product\n     * - emit an event if the pool's BNT trading liquidity has crossed the minimum threshold\n     *   (either above the threshold or below the threshold)\n     */\n    function _executeWithdrawal(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        Pool storage data,\n        uint256 poolTokenAmount,\n        InternalWithdrawalAmounts memory amounts\n    ) private {\n        PoolLiquidity storage liquidity = data.liquidity;\n        PoolLiquidity memory prevLiquidity = liquidity;\n        AverageRate memory averageRate = data.averageRate;\n\n        if (_poolRateState(prevLiquidity, averageRate) == PoolRateState.Unstable) {\n            revert RateUnstable();\n        }\n\n        data.poolToken.burnFrom(address(_network), poolTokenAmount);\n        uint256 newPoolTokenTotalSupply = amounts.poolTokenTotalSupply - poolTokenAmount;\n\n        liquidity.stakedBalance = MathEx.mulDivF(\n            liquidity.stakedBalance,\n            newPoolTokenTotalSupply,\n            amounts.poolTokenTotalSupply\n        );\n\n        // trading liquidity is assumed to never exceed 128 bits (the cast below will revert otherwise)\n        liquidity.baseTokenTradingLiquidity = SafeCast.toUint128(amounts.newBaseTokenTradingLiquidity);\n        liquidity.bntTradingLiquidity = SafeCast.toUint128(amounts.newBNTTradingLiquidity);\n\n        if (amounts.bntProtocolHoldingsDelta.value > 0) {\n            assert(amounts.bntProtocolHoldingsDelta.isNeg); // currently no support for requesting funding here\n\n            _bntPool.renounceFunding(contextId, pool, amounts.bntProtocolHoldingsDelta.value);\n        }\n\n        if (amounts.bntTradingLiquidityDelta.value > 0) {\n            if (amounts.bntTradingLiquidityDelta.isNeg) {\n                _bntPool.burnFromVault(amounts.bntTradingLiquidityDelta.value);\n            } else {\n                _bntPool.mint(address(_masterVault), amounts.bntTradingLiquidityDelta.value);\n            }\n        }\n\n        // if the provider should receive some BNT - ask the BNT pool to mint BNT to the provider\n        if (amounts.bntToMintForProvider > 0) {\n            _bntPool.mint(address(provider), amounts.bntToMintForProvider);\n        }\n\n        // if the provider should receive some base tokens from the external protection vault - remove the tokens from\n        // the external protection vault and send them to the master vault\n        if (amounts.baseTokensToTransferFromEPV > 0) {\n            _externalProtectionVault.withdrawFunds(\n                pool,\n                payable(address(_masterVault)),\n                amounts.baseTokensToTransferFromEPV\n            );\n            amounts.baseTokensToTransferFromMasterVault += amounts.baseTokensToTransferFromEPV;\n        }\n\n        // if the provider should receive some base tokens from the master vault - remove the tokens from the master\n        // vault and send them to the provider\n        if (amounts.baseTokensToTransferFromMasterVault > 0) {\n            _masterVault.withdrawFunds(pool, payable(provider), amounts.baseTokensToTransferFromMasterVault);\n        }\n\n        // ensure that the average rate is reset when the pool is being emptied\n        if (amounts.newBaseTokenTradingLiquidity == 0) {\n            data.averageRate.rate = zeroFraction112();\n        }\n\n        // if the new BNT trading liquidity is below the minimum liquidity for trading - reset the liquidity\n        if (amounts.newBNTTradingLiquidity < _networkSettings.minLiquidityForTrading()) {\n            _resetTradingLiquidity(\n                contextId,\n                pool,\n                data,\n                amounts.newBNTTradingLiquidity,\n                TRADING_STATUS_UPDATE_MIN_LIQUIDITY\n            );\n        }\n\n        emit TokensWithdrawn({\n            contextId: contextId,\n            provider: provider,\n            token: pool,\n            tokenAmount: amounts.baseTokensToTransferFromMasterVault,\n            poolTokenAmount: poolTokenAmount,\n            externalProtectionBaseTokenAmount: amounts.baseTokensToTransferFromEPV,\n            bntAmount: amounts.bntToMintForProvider,\n            withdrawalFeeAmount: amounts.baseTokensWithdrawalFee\n        });\n\n        _dispatchTradingLiquidityEvents(contextId, pool, newPoolTokenTotalSupply, prevLiquidity, data.liquidity);\n    }\n\n    /**\n     * @dev sets the default trading fee (in units of PPM)\n     */\n    function _setDefaultTradingFeePPM(uint32 newDefaultTradingFeePPM) private {\n        uint32 prevDefaultTradingFeePPM = _defaultTradingFeePPM;\n        if (prevDefaultTradingFeePPM == newDefaultTradingFeePPM) {\n            return;\n        }\n\n        _defaultTradingFeePPM = newDefaultTradingFeePPM;\n\n        emit DefaultTradingFeePPMUpdated({ prevFeePPM: prevDefaultTradingFeePPM, newFeePPM: newDefaultTradingFeePPM });\n    }\n\n    /**\n     * @dev returns a storage reference to pool data\n     */\n    function _poolStorage(Token pool) private view returns (Pool storage) {\n        Pool storage data = _poolData[pool];\n        if (address(data.poolToken) == address(0)) {\n            revert DoesNotExist();\n        }\n\n        return data;\n    }\n\n    /**\n     * @dev calculates base tokens amount\n     */\n    function _poolTokenToUnderlying(\n        uint256 poolTokenAmount,\n        uint256 poolTokenSupply,\n        uint256 stakedBalance\n    ) private pure returns (uint256) {\n        if (poolTokenSupply == 0) {\n            // if this is the initial liquidity provision - use a one-to-one pool token to base token rate\n            if (stakedBalance > 0) {\n                revert InvalidStakedBalance();\n            }\n\n            return poolTokenAmount;\n        }\n\n        return MathEx.mulDivF(poolTokenAmount, stakedBalance, poolTokenSupply);\n    }\n\n    /**\n     * @dev calculates pool tokens amount\n     */\n    function _underlyingToPoolToken(\n        uint256 tokenAmount,\n        uint256 poolTokenSupply,\n        uint256 stakedBalance\n    ) private pure returns (uint256) {\n        if (poolTokenSupply == 0) {\n            // if this is the initial liquidity provision - use a one-to-one pool token to base token rate\n            if (stakedBalance > 0) {\n                revert InvalidStakedBalance();\n            }\n\n            return tokenAmount;\n        }\n\n        return MathEx.mulDivC(tokenAmount, poolTokenSupply, stakedBalance);\n    }\n\n    /**\n     * @dev returns the target BNT trading liquidity, and whether or not it needs to be updated\n     */\n    function _calcTargetBNTTradingLiquidity(\n        uint256 tokenReserveAmount,\n        uint256 availableFunding,\n        PoolLiquidity memory liquidity,\n        Fraction memory fundingRate,\n        uint256 minLiquidityForTrading\n    ) private pure returns (TradingLiquidityAction memory) {\n        // calculate the target BNT trading liquidity based on the smaller between the following:\n        // - BNT liquidity required to match previously deposited based token liquidity\n        // - maximum available BNT trading liquidity (current amount + available funding)\n        uint256 targetBNTTradingLiquidity = Math.min(\n            MathEx.mulDivF(tokenReserveAmount, fundingRate.n, fundingRate.d),\n            liquidity.bntTradingLiquidity + availableFunding\n        );\n\n        // ensure that the target is above the minimum liquidity for trading\n        if (targetBNTTradingLiquidity < minLiquidityForTrading) {\n            return TradingLiquidityAction({ update: true, newAmount: 0 });\n        }\n\n        // calculate the new BNT trading liquidity and cap it by the growth factor\n        if (liquidity.bntTradingLiquidity == 0) {\n            // if the current BNT trading liquidity is 0, set it to the minimum liquidity for trading (with an\n            // additional buffer so that initial trades will be less likely to trigger disabling of trading)\n            uint256 newTargetBNTTradingLiquidity = minLiquidityForTrading * BOOTSTRAPPING_LIQUIDITY_BUFFER_FACTOR;\n\n            // ensure that we're not allocating more than the previously established limits\n            if (newTargetBNTTradingLiquidity > targetBNTTradingLiquidity) {\n                return TradingLiquidityAction({ update: false, newAmount: 0 });\n            }\n\n            targetBNTTradingLiquidity = newTargetBNTTradingLiquidity;\n        } else if (targetBNTTradingLiquidity >= liquidity.bntTradingLiquidity) {\n            // if the target is above the current trading liquidity, limit it by factoring the current value up. Please\n            // note that if the target is below the current trading liquidity - it will be reduced to it immediately\n            targetBNTTradingLiquidity = Math.min(\n                targetBNTTradingLiquidity,\n                liquidity.bntTradingLiquidity * LIQUIDITY_GROWTH_FACTOR\n            );\n        }\n\n        return TradingLiquidityAction({ update: true, newAmount: targetBNTTradingLiquidity });\n    }\n\n    /**\n     * @dev adjusts the trading liquidity based on the base token vault balance and funding limits\n     */\n    function _updateTradingLiquidity(\n        bytes32 contextId,\n        Token pool,\n        Pool storage data,\n        PoolLiquidity memory liquidity,\n        Fraction memory fundingRate,\n        uint256 minLiquidityForTrading\n    ) private {\n        // ensure that the base token reserve isn't empty\n        uint256 tokenReserveAmount = pool.balanceOf(address(_masterVault));\n        if (tokenReserveAmount == 0) {\n            _resetTradingLiquidity(contextId, pool, data, TRADING_STATUS_UPDATE_MIN_LIQUIDITY);\n\n            return;\n        }\n\n        if (_poolRateState(liquidity, data.averageRate) == PoolRateState.Unstable) {\n            return;\n        }\n\n        if (!fundingRate.isPositive()) {\n            _resetTradingLiquidity(contextId, pool, data, TRADING_STATUS_UPDATE_MIN_LIQUIDITY);\n\n            return;\n        }\n\n        TradingLiquidityAction memory action = _calcTargetBNTTradingLiquidity(\n            tokenReserveAmount,\n            _bntPool.availableFunding(pool),\n            liquidity,\n            fundingRate,\n            minLiquidityForTrading\n        );\n\n        if (!action.update) {\n            return;\n        }\n\n        if (action.newAmount == 0) {\n            _resetTradingLiquidity(contextId, pool, data, TRADING_STATUS_UPDATE_MIN_LIQUIDITY);\n\n            return;\n        }\n\n        // update funding from the BNT pool\n        if (action.newAmount > liquidity.bntTradingLiquidity) {\n            _bntPool.requestFunding(contextId, pool, action.newAmount - liquidity.bntTradingLiquidity);\n        } else if (action.newAmount < liquidity.bntTradingLiquidity) {\n            _bntPool.renounceFunding(contextId, pool, liquidity.bntTradingLiquidity - action.newAmount);\n        }\n\n        // calculate the base token trading liquidity based on the new BNT trading liquidity and the effective\n        // funding rate (please note that the effective funding rate is always the rate between BNT and the base token)\n        uint256 baseTokenTradingLiquidity = MathEx.mulDivF(action.newAmount, fundingRate.d, fundingRate.n);\n\n        // trading liquidity is assumed to never exceed 128 bits (the cast below will revert otherwise)\n        PoolLiquidity memory newLiquidity = PoolLiquidity({\n            bntTradingLiquidity: SafeCast.toUint128(action.newAmount),\n            baseTokenTradingLiquidity: SafeCast.toUint128(baseTokenTradingLiquidity),\n            stakedBalance: liquidity.stakedBalance\n        });\n\n        // update the liquidity data of the pool\n        data.liquidity = newLiquidity;\n\n        _dispatchTradingLiquidityEvents(contextId, pool, data.poolToken.totalSupply(), liquidity, newLiquidity);\n    }\n\n    function _dispatchTradingLiquidityEvents(\n        bytes32 contextId,\n        Token pool,\n        PoolLiquidity memory prevLiquidity,\n        PoolLiquidity memory newLiquidity\n    ) private {\n        if (newLiquidity.bntTradingLiquidity != prevLiquidity.bntTradingLiquidity) {\n            emit TradingLiquidityUpdated({\n                contextId: contextId,\n                pool: pool,\n                token: Token(address(_bnt)),\n                prevLiquidity: prevLiquidity.bntTradingLiquidity,\n                newLiquidity: newLiquidity.bntTradingLiquidity\n            });\n        }\n\n        if (newLiquidity.baseTokenTradingLiquidity != prevLiquidity.baseTokenTradingLiquidity) {\n            emit TradingLiquidityUpdated({\n                contextId: contextId,\n                pool: pool,\n                token: pool,\n                prevLiquidity: prevLiquidity.baseTokenTradingLiquidity,\n                newLiquidity: newLiquidity.baseTokenTradingLiquidity\n            });\n        }\n    }\n\n    function _dispatchTradingLiquidityEvents(\n        bytes32 contextId,\n        Token pool,\n        uint256 poolTokenTotalSupply,\n        PoolLiquidity memory prevLiquidity,\n        PoolLiquidity memory newLiquidity\n    ) private {\n        _dispatchTradingLiquidityEvents(contextId, pool, prevLiquidity, newLiquidity);\n\n        if (newLiquidity.stakedBalance != prevLiquidity.stakedBalance) {\n            emit TotalLiquidityUpdated({\n                contextId: contextId,\n                pool: pool,\n                liquidity: pool.balanceOf(address(_masterVault)),\n                stakedBalance: newLiquidity.stakedBalance,\n                poolTokenSupply: poolTokenTotalSupply\n            });\n        }\n    }\n\n    /**\n     * @dev resets trading liquidity and renounces any remaining BNT funding\n     */\n    function _resetTradingLiquidity(\n        bytes32 contextId,\n        Token pool,\n        Pool storage data,\n        uint8 reason\n    ) private {\n        _resetTradingLiquidity(contextId, pool, data, data.liquidity.bntTradingLiquidity, reason);\n    }\n\n    /**\n     * @dev resets trading liquidity and renounces any remaining BNT funding\n     */\n    function _resetTradingLiquidity(\n        bytes32 contextId,\n        Token pool,\n        Pool storage data,\n        uint256 currentBNTTradingLiquidity,\n        uint8 reason\n    ) private {\n        // reset the network and base token trading liquidities\n        data.liquidity.bntTradingLiquidity = 0;\n        data.liquidity.baseTokenTradingLiquidity = 0;\n\n        // reset the recent average rage\n        data.averageRate = AverageRate({ blockNumber: 0, rate: zeroFraction112() });\n\n        // ensure that trading is disabled\n        if (data.tradingEnabled) {\n            data.tradingEnabled = false;\n\n            emit TradingEnabled({ pool: pool, newStatus: false, reason: reason });\n        }\n\n        // renounce all network liquidity\n        if (currentBNTTradingLiquidity > 0) {\n            _bntPool.renounceFunding(contextId, pool, currentBNTTradingLiquidity);\n        }\n    }\n\n    /**\n     * @dev returns initial trading params\n     */\n    function _initTrade(\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 amount,\n        uint256 limit,\n        bool bySourceAmount\n    ) private view returns (TradeIntermediateResult memory result) {\n        // ensure that BNT is either the source or the target token\n        bool isSourceBNT = sourceToken.isEqual(_bnt);\n        bool isTargetBNT = targetToken.isEqual(_bnt);\n\n        if (isSourceBNT && !isTargetBNT) {\n            result.isSourceBNT = true;\n            result.pool = targetToken;\n        } else if (!isSourceBNT && isTargetBNT) {\n            result.isSourceBNT = false;\n            result.pool = sourceToken;\n        } else {\n            // BNT isn't one of the tokens or is both of them\n            revert DoesNotExist();\n        }\n\n        Pool storage data = _poolStorage(result.pool);\n\n        // verify that trading is enabled\n        if (!data.tradingEnabled) {\n            revert TradingDisabled();\n        }\n\n        result.contextId = contextId;\n        result.bySourceAmount = bySourceAmount;\n\n        if (result.bySourceAmount) {\n            result.sourceAmount = amount;\n        } else {\n            result.targetAmount = amount;\n        }\n\n        result.limit = limit;\n        result.tradingFeePPM = data.tradingFeePPM;\n\n        PoolLiquidity memory liquidity = data.liquidity;\n        if (result.isSourceBNT) {\n            result.sourceBalance = liquidity.bntTradingLiquidity;\n            result.targetBalance = liquidity.baseTokenTradingLiquidity;\n        } else {\n            result.sourceBalance = liquidity.baseTokenTradingLiquidity;\n            result.targetBalance = liquidity.bntTradingLiquidity;\n        }\n\n        result.stakedBalance = liquidity.stakedBalance;\n    }\n\n    /**\n     * @dev returns trade amount and fee by providing the source amount\n     */\n    function _tradeAmountAndFeeBySourceAmount(\n        uint256 sourceBalance,\n        uint256 targetBalance,\n        uint32 tradingFeePPM,\n        uint256 sourceAmount\n    ) private pure returns (TradeAmountAndTradingFee memory) {\n        if (sourceBalance == 0 || targetBalance == 0) {\n            revert InsufficientLiquidity();\n        }\n\n        uint256 targetAmount = MathEx.mulDivF(targetBalance, sourceAmount, sourceBalance + sourceAmount);\n        uint256 tradingFeeAmount = MathEx.mulDivF(targetAmount, tradingFeePPM, PPM_RESOLUTION);\n\n        return\n            TradeAmountAndTradingFee({ amount: targetAmount - tradingFeeAmount, tradingFeeAmount: tradingFeeAmount });\n    }\n\n    /**\n     * @dev returns trade amount and fee by providing either the target amount\n     */\n    function _tradeAmountAndFeeByTargetAmount(\n        uint256 sourceBalance,\n        uint256 targetBalance,\n        uint32 tradingFeePPM,\n        uint256 targetAmount\n    ) private pure returns (TradeAmountAndTradingFee memory) {\n        if (sourceBalance == 0) {\n            revert InsufficientLiquidity();\n        }\n\n        uint256 tradingFeeAmount = MathEx.mulDivF(targetAmount, tradingFeePPM, PPM_RESOLUTION - tradingFeePPM);\n        uint256 fullTargetAmount = targetAmount + tradingFeeAmount;\n        uint256 sourceAmount = MathEx.mulDivF(sourceBalance, fullTargetAmount, targetBalance - fullTargetAmount);\n\n        return TradeAmountAndTradingFee({ amount: sourceAmount, tradingFeeAmount: tradingFeeAmount });\n    }\n\n    /**\n     * @dev processes a trade by providing either the source or the target amount and updates the in-memory intermediate\n     * result\n     */\n    function _processTrade(TradeIntermediateResult memory result) private view {\n        TradeAmountAndTradingFee memory tradeAmountAndFee;\n\n        if (result.bySourceAmount) {\n            tradeAmountAndFee = _tradeAmountAndFeeBySourceAmount(\n                result.sourceBalance,\n                result.targetBalance,\n                result.tradingFeePPM,\n                result.sourceAmount\n            );\n\n            result.targetAmount = tradeAmountAndFee.amount;\n\n            // ensure that the target amount is above the requested minimum return amount\n            if (result.targetAmount < result.limit) {\n                revert InsufficientTargetAmount();\n            }\n        } else {\n            tradeAmountAndFee = _tradeAmountAndFeeByTargetAmount(\n                result.sourceBalance,\n                result.targetBalance,\n                result.tradingFeePPM,\n                result.targetAmount\n            );\n\n            result.sourceAmount = tradeAmountAndFee.amount;\n\n            // ensure that the user has provided enough tokens to make the trade\n            if (result.sourceAmount > result.limit) {\n                revert InsufficientSourceAmount();\n            }\n        }\n\n        result.tradingFeeAmount = tradeAmountAndFee.tradingFeeAmount;\n\n        // sync the trading and staked balance\n        result.sourceBalance += result.sourceAmount;\n        result.targetBalance -= result.targetAmount;\n\n        if (result.isSourceBNT) {\n            result.stakedBalance += result.tradingFeeAmount;\n        }\n\n        _processNetworkFee(result);\n    }\n\n    /**\n     * @dev processes the network fee and updates the in-memory intermediate result\n     */\n    function _processNetworkFee(TradeIntermediateResult memory result) private view {\n        uint32 networkFeePPM = _networkSettings.networkFeePPM();\n        if (networkFeePPM == 0) {\n            return;\n        }\n\n        // calculate the target network fee amount\n        uint256 targetNetworkFeeAmount = MathEx.mulDivF(result.tradingFeeAmount, networkFeePPM, PPM_RESOLUTION);\n\n        // update the target balance (but don't deduct it from the full trading fee amount)\n        result.targetBalance -= targetNetworkFeeAmount;\n\n        if (!result.isSourceBNT) {\n            result.networkFeeAmount = targetNetworkFeeAmount;\n\n            return;\n        }\n\n        // trade the network fee (taken from the base token) to BNT\n        result.networkFeeAmount = _tradeAmountAndFeeBySourceAmount(\n            result.targetBalance,\n            result.sourceBalance,\n            0,\n            targetNetworkFeeAmount\n        ).amount;\n\n        // since we have received the network fee in base tokens and have traded them for BNT (so that the network fee\n        // is always kept in BNT), we'd need to adapt the trading liquidity and the staked balance accordingly\n        result.targetBalance += targetNetworkFeeAmount;\n        result.sourceBalance -= result.networkFeeAmount;\n        result.stakedBalance -= targetNetworkFeeAmount;\n    }\n\n    /**\n     * @dev performs a trade\n     */\n    function _performTrade(TradeIntermediateResult memory result) private {\n        Pool storage data = _poolData[result.pool];\n        PoolLiquidity memory prevLiquidity = data.liquidity;\n\n        // update the recent average rate\n        _updateAverageRate(\n            data,\n            Fraction({ n: prevLiquidity.bntTradingLiquidity, d: prevLiquidity.baseTokenTradingLiquidity })\n        );\n\n        _processTrade(result);\n\n        // trading liquidity is assumed to never exceed 128 bits (the cast below will revert otherwise)\n        PoolLiquidity memory newLiquidity = PoolLiquidity({\n            bntTradingLiquidity: SafeCast.toUint128(result.isSourceBNT ? result.sourceBalance : result.targetBalance),\n            baseTokenTradingLiquidity: SafeCast.toUint128(\n                result.isSourceBNT ? result.targetBalance : result.sourceBalance\n            ),\n            stakedBalance: result.stakedBalance\n        });\n\n        _dispatchTradingLiquidityEvents(result.contextId, result.pool, prevLiquidity, newLiquidity);\n\n        // update the liquidity data of the pool\n        data.liquidity = newLiquidity;\n    }\n\n    /**\n     * @dev returns the state of a pool's rate\n     */\n    function _poolRateState(PoolLiquidity memory liquidity, AverageRate memory averageRateInfo)\n        internal\n        view\n        returns (PoolRateState)\n    {\n        Fraction memory spotRate = Fraction({\n            n: liquidity.bntTradingLiquidity,\n            d: liquidity.baseTokenTradingLiquidity\n        });\n\n        Fraction112 memory averageRate = averageRateInfo.rate;\n\n        if (!spotRate.isPositive() || !averageRate.isPositive()) {\n            return PoolRateState.Uninitialized;\n        }\n\n        if (averageRateInfo.blockNumber != _blockNumber()) {\n            averageRate = _calcAverageRate(averageRate, spotRate);\n        }\n\n        if (MathEx.isInRange(averageRate.fromFraction112(), spotRate, RATE_MAX_DEVIATION_PPM)) {\n            return PoolRateState.Stable;\n        }\n\n        return PoolRateState.Unstable;\n    }\n\n    /**\n     * @dev updates the average rate\n     */\n    function _updateAverageRate(Pool storage data, Fraction memory spotRate) private {\n        uint32 blockNumber = _blockNumber();\n\n        if (data.averageRate.blockNumber != blockNumber) {\n            data.averageRate = AverageRate({\n                blockNumber: blockNumber,\n                rate: _calcAverageRate(data.averageRate.rate, spotRate)\n            });\n        }\n    }\n\n    /**\n     * @dev calculates the average rate\n     */\n    function _calcAverageRate(Fraction112 memory averageRate, Fraction memory spotRate)\n        private\n        pure\n        returns (Fraction112 memory)\n    {\n        return\n            MathEx\n                .weightedAverage(averageRate.fromFraction112(), spotRate, EMA_AVERAGE_RATE_WEIGHT, EMA_SPOT_RATE_WEIGHT)\n                .toFraction112();\n    }\n\n    /**\n     * @dev verifies if the provided rate is valid\n     */\n    function _validRate(Fraction memory rate) internal pure {\n        if (!rate.isPositive()) {\n            revert InvalidRate();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/utility/BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\n/**\n * @dev this contract abstracts the block number in order to allow for more flexible control in tests\n */\ncontract BlockNumber {\n    /**\n     * @dev returns the current block-number\n     */\n    function _blockNumber() internal view virtual returns (uint32) {\n        return uint32(block.number);\n    }\n}\n"
    },
    "contracts/pools/PoolCollectionWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { PPM_RESOLUTION as M } from \"../utility/Constants.sol\";\nimport { Sint256, Uint512, MathEx } from \"../utility/MathEx.sol\";\n\nerror PoolCollectionWithdrawalInputInvalid();\n\n/**\n * @dev This library implements the mathematics behind base-token withdrawal.\n * It exposes a single function which takes the following input values:\n * `a` - BNT trading liquidity\n * `b` - base token trading liquidity\n * `c` - base token excess amount\n * `e` - base token staked amount\n * `w` - base token external protection vault balance\n * `m` - trading fee in PPM units\n * `n` - withdrawal fee in PPM units\n * `x` - base token withdrawal amount\n * And returns the following output values:\n * `p` - BNT amount to add to the trading liquidity and to the master vault\n * `q` - BNT amount to add to the protocol equity\n * `r` - base token amount to add to the trading liquidity\n * `s` - base token amount to transfer from the master vault to the provider\n * `t` - BNT amount to mint directly for the provider\n * `u` - base token amount to transfer from the external protection vault to the provider\n * `v` - base token amount to keep in the pool as a withdrawal fee\n * The following table depicts the actual formulae based on the current state of the system:\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\n * |           |                         Deficit                         |                       Surplus                            |\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\n * |           | p = a*x*(e*(1-n)-b-c)*(1-m)/(b*e-x*(e*(1-n)-b-c)*(1-m)) | p = -a*x*(b+c-e*(1-n))/(b*e*(1-m)+x*(b+c-e*(1-n))*(1-m)) |\n * |           | q = 0                                                   | q = 0                                                    |\n * |           | r = -x*(e*(1-n)-b-c)/e                                  | r = x*(b+c-e*(1-n))/e                                    |\n * | Arbitrage | s = x*(1-n)                                             | s = x*(1-n)                                              |\n * |           | t = 0                                                   | t = 0                                                    |\n * |           | u = 0                                                   | u = 0                                                    |\n * |           | v = x*n                                                 | v = x*n                                                  |\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\n * |           | p = -a*z/(b*e) where z = max(x*(1-n)*b-c*(e-x*(1-n)),0) | p = -a*z/b where z = max(x*(1-n)-c,0)                    |\n * |           | q = -a*z/(b*e) where z = max(x*(1-n)*b-c*(e-x*(1-n)),0) | q = -a*z/b where z = max(x*(1-n)-c,0)                    |\n * |           | r = -z/e       where z = max(x*(1-n)*b-c*(e-x*(1-n)),0) | r = -z     where z = max(x*(1-n)-c,0)                    |\n * | Default   | s = x*(1-n)*(b+c)/e                                     | s = x*(1-n)                                              |\n * |           | t = see function `externalProtection`                   | t = 0                                                    |\n * |           | u = see function `externalProtection`                   | u = 0                                                    |\n * |           | v = x*n                                                 | v = x*n                                                  |\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\n * |           | p = 0                                                   | p = 0                                                    |\n * |           | q = 0                                                   | q = 0                                                    |\n * |           | r = 0                                                   | r = 0                                                    |\n * | Bootstrap | s = x*(1-n)*c/e                                         | s = x*(1-n)                                              |\n * |           | t = see function `externalProtection`                   | t = 0                                                    |\n * |           | u = see function `externalProtection`                   | u = 0                                                    |\n * |           | v = x*n                                                 | v = x*n                                                  |\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\n * Note that for the sake of illustration, both `m` and `n` are assumed normalized (between 0 and 1).\n * During runtime, it is taken into account that they are given in PPM units (between 0 and 1000000).\n */\nlibrary PoolCollectionWithdrawal {\n    using MathEx for uint256;\n\n    struct Output {\n        Sint256 p;\n        Sint256 q;\n        Sint256 r;\n        uint256 s;\n        uint256 t;\n        uint256 u;\n        uint256 v;\n    }\n\n    /**\n     * @dev returns `p`, `q`, `r`, `s`, `t`, `u` and `v` according to the current state:\n     * +-------------------+-----------------------------------------------------------+\n     * | `e > (b+c)/(1-n)` | bootstrap deficit or default deficit or arbitrage deficit |\n     * +-------------------+-----------------------------------------------------------+\n     * | `e < (b+c)`       | bootstrap surplus or default surplus or arbitrage surplus |\n     * +-------------------+-----------------------------------------------------------+\n     * | otherwise         | bootstrap surplus or default surplus                      |\n     * +-------------------+-----------------------------------------------------------+\n     */\n    function calculateWithdrawalAmounts(\n        uint256 a, // <= 2**128-1\n        uint256 b, // <= 2**128-1\n        uint256 c, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 w, // <= 2**128-1\n        uint256 m, // <= M == 1000000\n        uint256 n, // <= M == 1000000\n        uint256 x /// <= e <= 2**128-1\n    ) internal pure returns (Output memory output) {\n        // given the restrictions above, everything below can be declared `unchecked`\n\n        if (\n            a > type(uint128).max ||\n            b > type(uint128).max ||\n            c > type(uint128).max ||\n            e > type(uint128).max ||\n            w > type(uint128).max ||\n            m > M ||\n            n > M ||\n            x > e\n        ) {\n            revert PoolCollectionWithdrawalInputInvalid();\n        }\n\n        uint256 y = (x * (M - n)) / M;\n\n        if ((e * (M - n)) / M > b + c) {\n            uint256 f = (e * (M - n)) / M - (b + c);\n            uint256 g = e - (b + c);\n            if (isStable(b, c, e, x) && affordableDeficit(b, e, f, g, m, n, x)) {\n                output = arbitrageDeficit(a, b, e, f, m, x, y);\n            } else if (a > 0) {\n                output = defaultDeficit(a, b, c, e, y);\n                (output.t, output.u) = externalProtection(a, b, e, g, y, w);\n            } else {\n                output.s = (y * c) / e;\n                (output.t, output.u) = externalProtection(a, b, e, g, y, w);\n            }\n        } else {\n            uint256 f = MathEx.subMax0(b + c, e);\n            if (f > 0 && isStable(b, c, e, x) && affordableSurplus(b, e, f, m, n, x)) {\n                output = arbitrageSurplus(a, b, e, f, m, n, x, y);\n            } else if (a > 0) {\n                output = defaultSurplus(a, b, c, y);\n            } else {\n                output.s = y;\n            }\n        }\n\n        output.v = x - y;\n    }\n\n    /**\n     * @dev returns `x < e*c/(b+c)`\n     */\n    function isStable(\n        uint256 b, // <= 2**128-1\n        uint256 c, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 x /// <= e <= 2**128-1\n    ) private pure returns (bool) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        return b * x < c * (e - x);\n    }\n\n    /**\n     * @dev returns `b*e*((e*(1-n)-b-c)*m+e*n) > (e*(1-n)-b-c)*x*(e-b-c)*(1-m)`\n     */\n    function affordableDeficit(\n        uint256 b, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 f, // == e*(1-n)-b-c <= e <= 2**128-1\n        uint256 g, // == e-b-c <= e <= 2**128-1\n        uint256 m, // <= M == 1000000\n        uint256 n, // <= M == 1000000\n        uint256 x /// <  e*c/(b+c) <= e <= 2**128-1\n    ) private pure returns (bool) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        Uint512 memory lhs = MathEx.mul512(b * e, f * m + e * n);\n        Uint512 memory rhs = MathEx.mul512(f * x, g * (M - m));\n        return MathEx.gt512(lhs, rhs);\n    }\n\n    /**\n     * @dev returns `b*e*((b+c-e)*m+e*n) > (b+c-e)*x*(b+c-e*(1-n))*(1-m)`\n     */\n    function affordableSurplus(\n        uint256 b, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 f, // == b+c-e <= 2**129-2\n        uint256 m, // <= M == 1000000\n        uint256 n, // <= M == 1000000\n        uint256 x /// <  e*c/(b+c) <= e <= 2**128-1\n    ) private pure returns (bool) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        Uint512 memory lhs = MathEx.mul512(b * e, (f * m + e * n) * M);\n        Uint512 memory rhs = MathEx.mul512(f * x, (f * M + e * n) * (M - m));\n        return MathEx.gt512(lhs, rhs); // `x < e*c/(b+c)` --> `f*x < e*c*(b+c-e)/(b+c) <= e*c <= 2**256-1`\n    }\n\n    /**\n     * @dev returns:\n     * `p = a*x*(e*(1-n)-b-c)*(1-m)/(b*e-x*(e*(1-n)-b-c)*(1-m))`\n     * `q = 0`\n     * `r = -x*(e*(1-n)-b-c)/e`\n     * `s = x*(1-n)`\n     */\n    function arbitrageDeficit(\n        uint256 a, // <= 2**128-1\n        uint256 b, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 f, // == e*(1-n)-b-c <= e <= 2**128-1\n        uint256 m, // <= M == 1000000\n        uint256 x, // <= e <= 2**128-1\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\n    ) private pure returns (Output memory output) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        uint256 i = f * (M - m);\n        uint256 j = mulSubMulDivF(b, e * M, x, i, 1);\n        output.p = MathEx.mulDivF(a * x, i, j).toPos256();\n        output.r = MathEx.mulDivF(x, f, e).toNeg256();\n        output.s = y;\n    }\n\n    /**\n     * @dev returns:\n     * `p = -a*x*(b+c-e*(1-n))/(b*e*(1-m)+x*(b+c-e*(1-n))*(1-m))`\n     * `q = 0`\n     * `r = x*(b+c-e*(1-n))/e`\n     * `s = x*(1-n)`\n     */\n    function arbitrageSurplus(\n        uint256 a, // <= 2**128-1\n        uint256 b, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 f, // == b+c-e <= 2**129-2\n        uint256 m, // <= M == 1000000\n        uint256 n, // <= M == 1000000\n        uint256 x, // <= e <= 2**128-1\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\n    ) private pure returns (Output memory output) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        uint256 i = f * M + e * n;\n        uint256 j = mulAddMulDivF(b, e * (M - m), x, i * (M - m), M);\n        output.p = MathEx.mulDivF(a * x, i, j).toNeg256();\n        output.r = MathEx.mulDivF(x, i, e * M).toPos256();\n        output.s = y;\n    }\n\n    /**\n     * @dev returns:\n     * `p = -a*z/(b*e)` where `z = max(x*(1-n)*b-c*(e-x*(1-n)),0)`\n     * `q = -a*z/(b*e)` where `z = max(x*(1-n)*b-c*(e-x*(1-n)),0)`\n     * `r = -z/e` where `z = max(x*(1-n)*b-c*(e-x*(1-n)),0)`\n     * `s = x*(1-n)*(b+c)/e`\n     */\n    function defaultDeficit(\n        uint256 a, // <= 2**128-1\n        uint256 b, // <= 2**128-1\n        uint256 c, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\n    ) private pure returns (Output memory output) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        uint256 z = MathEx.subMax0(y * b, c * (e - y));\n        output.p = MathEx.mulDivF(a, z, b * e).toNeg256();\n        output.q = output.p;\n        output.r = (z / e).toNeg256();\n        output.s = MathEx.mulDivF(y, b + c, e);\n    }\n\n    /**\n     * @dev returns:\n     * `p = -a*z/b` where `z = max(x*(1-n)-c,0)`\n     * `q = -a*z/b` where `z = max(x*(1-n)-c,0)`\n     * `r = -z` where `z = max(x*(1-n)-c,0)`\n     * `s = x*(1-n)`\n     */\n    function defaultSurplus(\n        uint256 a, // <= 2**128-1\n        uint256 b, // <= 2**128-1\n        uint256 c, // <= 2**128-1\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\n    ) private pure returns (Output memory output) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        uint256 z = MathEx.subMax0(y, c);\n        output.p = MathEx.mulDivF(a, z, b).toNeg256();\n        output.q = output.p;\n        output.r = z.toNeg256();\n        output.s = y;\n    }\n\n    /**\n     * @dev returns `t` and `u` according to the current state:\n     * +-----------------------+-------+---------------------------+-------------------+\n     * | x*(1-n)*(e-b-c)/e > w | a > 0 | t                         | u                 |\n     * +-----------------------+-------+---------------------------+-------------------+\n     * | true                  | true  | a*(x*(1-n)*(e-b-c)/e-w)/b | w                 |\n     * +-----------------------+-------+---------------------------+-------------------+\n     * | true                  | false | 0                         | w                 |\n     * +-----------------------+-------+---------------------------+-------------------+\n     * | false                 | true  | 0                         | x*(1-n)*(e-b-c)/e |\n     * +-----------------------+-------+---------------------------+-------------------+\n     * | false                 | false | 0                         | x*(1-n)*(e-b-c)/e |\n     * +-----------------------+-------+---------------------------+-------------------+\n     */\n    function externalProtection(\n        uint256 a, // <= 2**128-1\n        uint256 b, // <= 2**128-1\n        uint256 e, // <= 2**128-1\n        uint256 g, // == e-b-c <= e <= 2**128-1\n        uint256 y, // == x*(1-n) <= x <= e <= 2**128-1\n        uint256 w /// <= 2**128-1\n    ) private pure returns (uint256 t, uint256 u) {\n        // given the restrictions above, everything below can be declared `unchecked`\n        uint256 yg = y * g;\n        uint256 we = w * e;\n        if (yg > we) {\n            t = a > 0 ? MathEx.mulDivF(a, yg - we, b * e) : 0;\n            u = w;\n        } else {\n            t = 0;\n            u = yg / e;\n        }\n    }\n\n    /**\n     * @dev returns `a*b+x*y/z`\n     */\n    function mulAddMulDivF(\n        uint256 a,\n        uint256 b,\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return a * b + MathEx.mulDivF(x, y, z);\n    }\n\n    /**\n     * @dev returns `a*b-x*y/z`\n     */\n    function mulSubMulDivF(\n        uint256 a,\n        uint256 b,\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return a * b - MathEx.mulDivF(x, y, z);\n    }\n}\n"
    },
    "contracts/helpers/TestPoolCollectionWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { PoolCollectionWithdrawal } from \"../pools/PoolCollectionWithdrawal.sol\";\n\ncontract TestPoolCollectionWithdrawal {\n    function calculateWithdrawalAmountsT(\n        uint256 a,\n        uint256 b,\n        uint256 c,\n        uint256 e,\n        uint256 w,\n        uint256 m,\n        uint256 n,\n        uint256 x\n    ) external pure returns (PoolCollectionWithdrawal.Output memory) {\n        return PoolCollectionWithdrawal.calculateWithdrawalAmounts(a, b, c, e, w, m, n, x);\n    }\n}\n"
    },
    "contracts/network/PendingWithdrawals.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { EnumerableSetUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, AccessDenied, AlreadyExists, DoesNotExist, InvalidPool } from \"../utility/Utils.sol\";\nimport { Time } from \"../utility/Time.sol\";\nimport { MathEx } from \"../utility/MathEx.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { IBancorNetwork } from \"./interfaces/IBancorNetwork.sol\";\nimport { IPendingWithdrawals, WithdrawalRequest, CompletedWithdrawal } from \"./interfaces/IPendingWithdrawals.sol\";\n\n/**\n * @dev Pending Withdrawals contract\n */\ncontract PendingWithdrawals is IPendingWithdrawals, Upgradeable, Time, Utils {\n    using SafeERC20 for IPoolToken;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using TokenLibrary for Token;\n\n    error WithdrawalNotAllowed();\n\n    uint32 private constant DEFAULT_LOCK_DURATION = 7 days;\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the BNT contract\n    IERC20 private immutable _bnt;\n\n    // the BNT pool contract\n    IBNTPool private immutable _bntPool;\n\n    // the lock duration\n    uint32 private _lockDuration;\n\n    // a mapping between accounts and their pending withdrawal requests\n    uint256 private _nextWithdrawalRequestId;\n    mapping(address => EnumerableSetUpgradeable.UintSet) private _withdrawalRequestIdsByProvider;\n    mapping(uint256 => WithdrawalRequest) private _withdrawalRequests;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 4] private __gap;\n\n    /**\n     * @dev triggered when the lock duration is updated\n     */\n    event LockDurationUpdated(uint32 prevLockDuration, uint32 newLockDuration);\n\n    /**\n     * @dev triggered when a provider requests to initiate a liquidity withdrawal\n     */\n    event WithdrawalInitiated(\n        Token indexed pool,\n        address indexed provider,\n        uint256 indexed requestId,\n        uint256 poolTokenAmount,\n        uint256 reserveTokenAmount\n    );\n\n    /**\n     * @dev triggered when a provider cancels a liquidity withdrawal request\n     */\n    event WithdrawalCancelled(\n        Token indexed pool,\n        address indexed provider,\n        uint256 indexed requestId,\n        uint256 poolTokenAmount,\n        uint256 reserveTokenAmount,\n        uint32 timeElapsed\n    );\n\n    /**\n     * @dev triggered when a liquidity withdrawal request has been completed\n     */\n    event WithdrawalCompleted(\n        bytes32 indexed contextId,\n        Token indexed pool,\n        address indexed provider,\n        uint256 requestId,\n        uint256 poolTokenAmount,\n        uint256 reserveTokenAmount,\n        uint32 timeElapsed\n    );\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        IERC20 initBNT,\n        IBNTPool initBNTPool\n    ) validAddress(address(initNetwork)) validAddress(address(initBNT)) validAddress(address(initBNTPool)) {\n        _network = initNetwork;\n        _bnt = initBNT;\n        _bntPool = initBNTPool;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __PendingWithdrawals_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __PendingWithdrawals_init() internal onlyInitializing {\n        __Upgradeable_init();\n\n        __PendingWithdrawals_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __PendingWithdrawals_init_unchained() internal onlyInitializing {\n        _setLockDuration(DEFAULT_LOCK_DURATION);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function lockDuration() external view returns (uint32) {\n        return _lockDuration;\n    }\n\n    /**\n     * @dev sets the lock duration\n     *\n     * notes:\n     *\n     * - updating it will affect existing locked positions retroactively\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setLockDuration(uint32 newLockDuration) external onlyAdmin {\n        _setLockDuration(newLockDuration);\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function withdrawalRequestCount(address provider) external view returns (uint256) {\n        return _withdrawalRequestIdsByProvider[provider].length();\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function withdrawalRequestIds(address provider) external view returns (uint256[] memory) {\n        return _withdrawalRequestIdsByProvider[provider].values();\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function withdrawalRequest(uint256 id) external view returns (WithdrawalRequest memory) {\n        return _withdrawalRequests[id];\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function initWithdrawal(\n        address provider,\n        IPoolToken poolToken,\n        uint256 poolTokenAmount\n    )\n        external\n        validAddress(address(poolToken))\n        greaterThanZero(poolTokenAmount)\n        only(address(_network))\n        returns (uint256)\n    {\n        return _initWithdrawal(provider, poolToken, poolTokenAmount);\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function cancelWithdrawal(address provider, uint256 id) external only(address(_network)) {\n        WithdrawalRequest memory request = _withdrawalRequests[id];\n\n        if (request.provider != provider) {\n            revert AccessDenied();\n        }\n\n        _cancelWithdrawal(request, id);\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function completeWithdrawal(\n        bytes32 contextId,\n        address provider,\n        uint256 id\n    ) external only(address(_network)) returns (CompletedWithdrawal memory) {\n        WithdrawalRequest memory request = _withdrawalRequests[id];\n\n        if (provider != request.provider) {\n            revert AccessDenied();\n        }\n\n        uint32 currentTime = _time();\n        if (!_canWithdrawAt(currentTime, request.createdAt)) {\n            revert WithdrawalNotAllowed();\n        }\n\n        // remove the withdrawal request and its id from the storage\n        _removeWithdrawalRequest(provider, id);\n\n        // get the pool token value in reserve/pool tokens\n        uint256 currentReserveTokenAmount = _poolTokenToUnderlying(request.reserveToken, request.poolTokenAmount);\n\n        // note that since pool token value can only go up - the current underlying amount can't be lower than at the time\n        // of the request\n        assert(currentReserveTokenAmount >= request.reserveTokenAmount);\n\n        // burn the delta between the recorded pool token amount and the amount represented by the reserve token value\n        uint256 currentPoolTokenAmount = request.reserveTokenAmount == currentReserveTokenAmount\n            ? request.poolTokenAmount\n            : MathEx.mulDivF(request.poolTokenAmount, request.reserveTokenAmount, currentReserveTokenAmount);\n\n        // since pool token value can only go up, theres usually burning\n        if (request.poolTokenAmount > currentPoolTokenAmount) {\n            request.poolToken.burn(request.poolTokenAmount - currentPoolTokenAmount);\n        }\n\n        // transfer the locked pool tokens back to the caller\n        request.poolToken.safeTransfer(msg.sender, currentPoolTokenAmount);\n\n        emit WithdrawalCompleted({\n            contextId: contextId,\n            pool: request.reserveToken,\n            provider: provider,\n            requestId: id,\n            poolTokenAmount: currentPoolTokenAmount,\n            reserveTokenAmount: currentReserveTokenAmount,\n            timeElapsed: currentTime - request.createdAt\n        });\n\n        return CompletedWithdrawal({ poolToken: request.poolToken, poolTokenAmount: currentPoolTokenAmount });\n    }\n\n    /**\n     * @inheritdoc IPendingWithdrawals\n     */\n    function isReadyForWithdrawal(uint256 id) external view returns (bool) {\n        WithdrawalRequest storage request = _withdrawalRequests[id];\n\n        return request.provider != address(0) && _canWithdrawAt(_time(), request.createdAt);\n    }\n\n    /**\n     * @dev sets the lock duration\n     *\n     * notes:\n     *\n     * - updating it will affect existing locked positions retroactively\n     *\n     */\n    function _setLockDuration(uint32 newLockDuration) private {\n        uint32 prevLockDuration = _lockDuration;\n        if (prevLockDuration == newLockDuration) {\n            return;\n        }\n\n        _lockDuration = newLockDuration;\n\n        emit LockDurationUpdated({ prevLockDuration: prevLockDuration, newLockDuration: newLockDuration });\n    }\n\n    /**\n     * @dev initiates liquidity withdrawal\n     */\n    function _initWithdrawal(\n        address provider,\n        IPoolToken poolToken,\n        uint256 poolTokenAmount\n    ) private returns (uint256) {\n        // make sure that the pool is valid\n        Token pool = poolToken.reserveToken();\n        if (!_network.isPoolValid(pool)) {\n            revert InvalidPool();\n        }\n\n        // record the current withdrawal request alongside previous pending withdrawal requests\n        uint256 id = _nextWithdrawalRequestId++;\n\n        // get the pool token value in reserve/pool tokens\n        uint256 reserveTokenAmount = _poolTokenToUnderlying(pool, poolTokenAmount);\n        _withdrawalRequests[id] = WithdrawalRequest({\n            provider: provider,\n            poolToken: poolToken,\n            reserveToken: pool,\n            poolTokenAmount: poolTokenAmount,\n            reserveTokenAmount: reserveTokenAmount,\n            createdAt: _time()\n        });\n\n        if (!_withdrawalRequestIdsByProvider[provider].add(id)) {\n            revert AlreadyExists();\n        }\n\n        emit WithdrawalInitiated({\n            pool: pool,\n            provider: provider,\n            requestId: id,\n            poolTokenAmount: poolTokenAmount,\n            reserveTokenAmount: reserveTokenAmount\n        });\n\n        return id;\n    }\n\n    /**\n     * @dev returns the pool token value in tokens\n     */\n    function _poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) private view returns (uint256) {\n        if (pool.isEqual(_bnt)) {\n            return _bntPool.poolTokenToUnderlying(poolTokenAmount);\n        }\n\n        return _network.collectionByPool(pool).poolTokenToUnderlying(pool, poolTokenAmount);\n    }\n\n    /**\n     * @dev cancels a withdrawal request\n     */\n    function _cancelWithdrawal(WithdrawalRequest memory request, uint256 id) private {\n        // remove the withdrawal request and its id from the storage\n        _removeWithdrawalRequest(request.provider, id);\n\n        // transfer the locked pool tokens back to the provider\n        request.poolToken.safeTransfer(request.provider, request.poolTokenAmount);\n\n        emit WithdrawalCancelled({\n            pool: request.reserveToken,\n            provider: request.provider,\n            requestId: id,\n            poolTokenAmount: request.poolTokenAmount,\n            reserveTokenAmount: request.reserveTokenAmount,\n            timeElapsed: _time() - request.createdAt\n        });\n    }\n\n    /**\n     * @dev removes withdrawal request\n     */\n    function _removeWithdrawalRequest(address provider, uint256 id) private {\n        if (!_withdrawalRequestIdsByProvider[provider].remove(id)) {\n            revert DoesNotExist();\n        }\n\n        delete _withdrawalRequests[id];\n    }\n\n    /**\n     * @dev returns whether it's possible to withdraw a request at the provided time\n     */\n    function _canWithdrawAt(uint32 time, uint32 createdAt) private view returns (bool) {\n        return createdAt + _lockDuration <= time;\n    }\n}\n"
    },
    "contracts/helpers/TestStandardRewards.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { Time } from \"../utility/Time.sol\";\n\nimport { ProgramData } from \"../rewards/interfaces/IStandardRewards.sol\";\nimport { StandardRewards } from \"../rewards/StandardRewards.sol\";\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings } from \"../network/interfaces/INetworkSettings.sol\";\n\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { IExternalRewardsVault } from \"../vaults/interfaces/IExternalRewardsVault.sol\";\n\nimport { TestTime } from \"./TestTime.sol\";\n\ncontract TestStandardRewards is StandardRewards, TestTime {\n    constructor(\n        IBancorNetwork initNetwork,\n        INetworkSettings initNetworkSettings,\n        ITokenGovernance initBNTGovernance,\n        IBNTPool initBNTPool,\n        IExternalRewardsVault initExternalRewardsVault\n    ) StandardRewards(initNetwork, initNetworkSettings, initBNTGovernance, initBNTPool, initExternalRewardsVault) {}\n\n    function nextProgramId() external view returns (uint256) {\n        return _nextProgramId;\n    }\n\n    function unclaimedRewards(Token rewardsToken) external view returns (uint256) {\n        return _unclaimedRewards[rewardsToken];\n    }\n\n    function programRewards(uint256 id) external view returns (Rewards memory) {\n        return _programRewards[id];\n    }\n\n    function providerRewards(address provider, uint256 id) external view returns (ProviderRewards memory) {\n        return _providerRewards[provider][id];\n    }\n\n    function claimRewardsWithAmounts(uint256[] calldata ids) external returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](ids.length);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n\n            ProgramData memory p = _programs[id];\n\n            amounts[i] = _claimRewards(msg.sender, p).reward;\n        }\n\n        return amounts;\n    }\n\n    function setRemainingRewards(uint256 id, uint256 remainingRewards) external {\n        _programs[id].remainingRewards = remainingRewards;\n    }\n\n    function _time() internal view virtual override(Time, TestTime) returns (uint32) {\n        return TestTime._time();\n    }\n}\n"
    },
    "contracts/helpers/TestTime.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Time } from \"../utility/Time.sol\";\n\ncontract TestTime is Time {\n    uint32 private _currentTime = 1;\n\n    function _time() internal view virtual override returns (uint32) {\n        return _currentTime;\n    }\n\n    function setTime(uint32 newTime) external {\n        _currentTime = newTime;\n    }\n\n    function currentTime() external view returns (uint32) {\n        return _currentTime;\n    }\n}\n"
    },
    "contracts/helpers/TestPendingWithdrawals.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { PendingWithdrawals } from \"../network/PendingWithdrawals.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { Time } from \"../utility/Time.sol\";\n\nimport { TestTime } from \"./TestTime.sol\";\n\ncontract TestPendingWithdrawals is PendingWithdrawals, TestTime {\n    constructor(\n        IBancorNetwork initNetwork,\n        IERC20 initBNT,\n        IBNTPool initBNTPool\n    ) PendingWithdrawals(initNetwork, initBNT, initBNTPool) {}\n\n    function _time() internal view virtual override(Time, TestTime) returns (uint32) {\n        return TestTime._time();\n    }\n}\n"
    },
    "contracts/network/BancorNetwork.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { EnumerableSetUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { PPM_RESOLUTION } from \"../utility/Constants.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Time } from \"../utility/Time.sol\";\nimport { MathEx } from \"../utility/MathEx.sol\";\n\n// prettier-ignore\nimport {\n    Utils,\n    AlreadyExists,\n    DoesNotExist,\n    InvalidToken,\n    InvalidType,\n    InvalidPoolCollection,\n    NotEmpty\n} from \"../utility/Utils.sol\";\n\nimport { ROLE_ASSET_MANAGER } from \"../vaults/interfaces/IVault.sol\";\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\nimport { IExternalProtectionVault } from \"../vaults/interfaces/IExternalProtectionVault.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary, Signature } from \"../token/TokenLibrary.sol\";\n\nimport { IPoolCollection, TradeAmountAndFee } from \"../pools/interfaces/IPoolCollection.sol\";\nimport { IPoolMigrator } from \"../pools/interfaces/IPoolMigrator.sol\";\n\n// prettier-ignore\nimport {\n    IBNTPool,\n    ROLE_BNT_MANAGER,\n    ROLE_VAULT_MANAGER,\n    ROLE_FUNDING_MANAGER\n} from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\n\nimport { INetworkSettings, NotWhitelisted } from \"./interfaces/INetworkSettings.sol\";\nimport { IPendingWithdrawals, WithdrawalRequest, CompletedWithdrawal } from \"./interfaces/IPendingWithdrawals.sol\";\nimport { IBancorNetwork, IFlashLoanRecipient } from \"./interfaces/IBancorNetwork.sol\";\n\n/**\n * @dev Bancor Network contract\n */\ncontract BancorNetwork is IBancorNetwork, Upgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable, Time, Utils {\n    using Address for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using TokenLibrary for Token;\n    using SafeERC20 for IPoolToken;\n\n    error DeadlineExpired();\n    error NativeTokenAmountMismatch();\n    error InsufficientFlashLoanReturn();\n\n    struct TradeParams {\n        uint256 amount;\n        uint256 limit;\n        bool bySourceAmount;\n    }\n\n    struct TradeResult {\n        uint256 sourceAmount;\n        uint256 targetAmount;\n        uint256 tradingFeeAmount;\n        uint256 networkFeeAmount;\n    }\n\n    struct TradeTokens {\n        Token sourceToken;\n        Token targetToken;\n    }\n\n    struct TraderInfo {\n        address trader;\n        address beneficiary;\n    }\n\n    // the migration manager role is required for migrating liquidity\n    bytes32 private constant ROLE_MIGRATION_MANAGER = keccak256(\"ROLE_MIGRATION_MANAGER\");\n\n    // the emergency manager role is required to pause/unpause the network\n    bytes32 private constant ROLE_EMERGENCY_STOPPER = keccak256(\"ROLE_EMERGENCY_STOPPER\");\n\n    // the network fee manager role is required to pull the accumulated pending network fees\n    bytes32 private constant ROLE_NETWORK_FEE_MANAGER = keccak256(\"ROLE_NETWORK_FEE_MANAGER\");\n\n    // the address of the BNT token\n    IERC20 private immutable _bnt;\n\n    // the address of the BNT token governance\n    ITokenGovernance private immutable _bntGovernance;\n\n    // the address of the VBNT token\n    IERC20 private immutable _vbnt;\n\n    // the address of the VBNT token governance\n    ITokenGovernance private immutable _vbntGovernance;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the master vault contract\n    IMasterVault private immutable _masterVault;\n\n    // the address of the external protection vault\n    IExternalProtectionVault private immutable _externalProtectionVault;\n\n    // the BNT pool token\n    IPoolToken internal immutable _bntPoolToken;\n\n    // the BNT pool contract\n    IBNTPool internal _bntPool;\n\n    // the pending withdrawals contract\n    IPendingWithdrawals internal _pendingWithdrawals;\n\n    // the pool migrator contract\n    IPoolMigrator internal _poolMigrator;\n\n    // the set of all valid pool collections\n    EnumerableSetUpgradeable.AddressSet private _poolCollections;\n\n    // a mapping between the last pool collection that was added to the pool collections set and its type\n    mapping(uint16 => IPoolCollection) private _latestPoolCollections;\n\n    // the set of all pools\n    EnumerableSetUpgradeable.AddressSet private _liquidityPools;\n\n    // a mapping between pools and their respective pool collections\n    mapping(Token => IPoolCollection) private _collectionByPool;\n\n    // the pending network fee amount to be burned by the vortex\n    uint256 internal _pendingNetworkFeeAmount;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 10] private __gap;\n\n    /**\n     * @dev triggered when a new pool collection is added\n     */\n    event PoolCollectionAdded(uint16 indexed poolType, IPoolCollection indexed poolCollection);\n\n    /**\n     * @dev triggered when an existing pool collection is removed\n     */\n    event PoolCollectionRemoved(uint16 indexed poolType, IPoolCollection indexed poolCollection);\n\n    /**\n     * @dev triggered when the latest pool collection, for a specific type, is replaced\n     */\n    event LatestPoolCollectionReplaced(\n        uint16 indexed poolType,\n        IPoolCollection indexed prevPoolCollection,\n        IPoolCollection indexed newPoolCollection\n    );\n\n    /**\n     * @dev triggered when a new pool is added\n     */\n    event PoolAdded(Token indexed pool, IPoolCollection indexed poolCollection);\n\n    /**\n     * @dev triggered when funds are migrated\n     */\n    event FundsMigrated(\n        bytes32 indexed contextId,\n        Token indexed token,\n        address indexed provider,\n        uint256 amount,\n        uint256 availableAmount,\n        uint256 originalAmount\n    );\n\n    /**\n     * @dev triggered on a successful trade\n     */\n    event TokensTraded(\n        bytes32 indexed contextId,\n        Token indexed sourceToken,\n        Token indexed targetToken,\n        uint256 sourceAmount,\n        uint256 targetAmount,\n        uint256 bntAmount,\n        uint256 targetFeeAmount,\n        uint256 bntFeeAmount,\n        address trader\n    );\n\n    /**\n     * @dev triggered when a flash-loan is completed\n     */\n    event FlashLoanCompleted(Token indexed token, address indexed borrower, uint256 amount, uint256 feeAmount);\n\n    /**\n     * @dev triggered when network fees are withdrawn\n     */\n    event NetworkFeesWithdrawn(address indexed caller, address indexed recipient, uint256 amount);\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        ITokenGovernance initBNTGovernance,\n        ITokenGovernance initVBNTGovernance,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IExternalProtectionVault initExternalProtectionVault,\n        IPoolToken initBNTPoolToken\n    )\n        validAddress(address(initBNTGovernance))\n        validAddress(address(initVBNTGovernance))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initMasterVault))\n        validAddress(address(initExternalProtectionVault))\n        validAddress(address(initBNTPoolToken))\n    {\n        _bntGovernance = initBNTGovernance;\n        _bnt = initBNTGovernance.token();\n        _vbntGovernance = initVBNTGovernance;\n        _vbnt = initVBNTGovernance.token();\n\n        _networkSettings = initNetworkSettings;\n        _masterVault = initMasterVault;\n        _externalProtectionVault = initExternalProtectionVault;\n        _bntPoolToken = initBNTPoolToken;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize(\n        IBNTPool initBNTPool,\n        IPendingWithdrawals initPendingWithdrawals,\n        IPoolMigrator initPoolMigrator\n    )\n        external\n        validAddress(address(initBNTPool))\n        validAddress(address(initPendingWithdrawals))\n        validAddress(address(initPoolMigrator))\n        initializer\n    {\n        __BancorNetwork_init(initBNTPool, initPendingWithdrawals, initPoolMigrator);\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __BancorNetwork_init(\n        IBNTPool initBNTPool,\n        IPendingWithdrawals initPendingWithdrawals,\n        IPoolMigrator initPoolMigrator\n    ) internal onlyInitializing {\n        __Upgradeable_init();\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        __BancorNetwork_init_unchained(initBNTPool, initPendingWithdrawals, initPoolMigrator);\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __BancorNetwork_init_unchained(\n        IBNTPool initBNTPool,\n        IPendingWithdrawals initPendingWithdrawals,\n        IPoolMigrator initPoolMigrator\n    ) internal onlyInitializing {\n        _bntPool = initBNTPool;\n        _pendingWithdrawals = initPendingWithdrawals;\n        _poolMigrator = initPoolMigrator;\n\n        // set up administrative roles\n        _setRoleAdmin(ROLE_MIGRATION_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_EMERGENCY_STOPPER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_NETWORK_FEE_MANAGER, ROLE_ADMIN);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    receive() external payable {}\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 2;\n    }\n\n    /**\n     * @dev returns the migration manager role\n     */\n    function roleMigrationManager() external pure returns (bytes32) {\n        return ROLE_MIGRATION_MANAGER;\n    }\n\n    /**\n     * @dev returns the emergency stopper role\n     */\n    function roleEmergencyStopper() external pure returns (bytes32) {\n        return ROLE_EMERGENCY_STOPPER;\n    }\n\n    /**\n     * @dev returns the network fee manager role\n     */\n    function roleNetworkFeeManager() external pure returns (bytes32) {\n        return ROLE_NETWORK_FEE_MANAGER;\n    }\n\n    /**\n     * @dev returns the pending network fee amount to be burned by the vortex\n     */\n    function pendingNetworkFeeAmount() external view returns (uint256) {\n        return _pendingNetworkFeeAmount;\n    }\n\n    /**\n     * @dev adds new pool collection to the network\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function addPoolCollection(IPoolCollection poolCollection)\n        external\n        validAddress(address(poolCollection))\n        onlyAdmin\n        nonReentrant\n    {\n        if (!_poolCollections.add(address(poolCollection))) {\n            revert AlreadyExists();\n        }\n\n        // ensure that we're not adding a pool collection with the same type and version\n        uint16 poolType = poolCollection.poolType();\n        IPoolCollection prevLatestPoolCollection = _latestPoolCollections[poolType];\n        if (\n            address(prevLatestPoolCollection) != address(0) &&\n            prevLatestPoolCollection.version() == poolCollection.version()\n        ) {\n            revert AlreadyExists();\n        }\n\n        _setLatestPoolCollection(poolType, poolCollection);\n        _setAccessRoles(poolCollection, true);\n\n        emit PoolCollectionAdded({ poolType: poolType, poolCollection: poolCollection });\n    }\n\n    /**\n     * @dev removes an existing pool collection from the pool\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function removePoolCollection(IPoolCollection poolCollection, IPoolCollection newLatestPoolCollection)\n        external\n        validAddress(address(poolCollection))\n        onlyAdmin\n        nonReentrant\n    {\n        if (poolCollection == newLatestPoolCollection) {\n            revert InvalidPoolCollection();\n        }\n\n        // verify that a pool collection is a valid latest pool collection (e.g., it either exists or a reset to zero)\n        _verifyLatestPoolCollectionCandidate(newLatestPoolCollection);\n\n        // verify that no pools are associated with the specified pool collection\n        if (poolCollection.poolCount() != 0) {\n            revert NotEmpty();\n        }\n\n        if (!_poolCollections.remove(address(poolCollection))) {\n            revert DoesNotExist();\n        }\n\n        uint16 poolType = poolCollection.poolType();\n        if (address(newLatestPoolCollection) != address(0)) {\n            uint16 newLatestPoolCollectionType = newLatestPoolCollection.poolType();\n            if (poolType != newLatestPoolCollectionType) {\n                revert InvalidType();\n            }\n        }\n\n        _setLatestPoolCollection(poolType, newLatestPoolCollection);\n        _setAccessRoles(poolCollection, false);\n\n        emit PoolCollectionRemoved({ poolType: poolType, poolCollection: poolCollection });\n    }\n\n    /**\n     * @dev sets the new latest pool collection for the given type\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setLatestPoolCollection(IPoolCollection poolCollection)\n        external\n        validAddress(address(poolCollection))\n        onlyAdmin\n        nonReentrant\n    {\n        _verifyLatestPoolCollectionCandidate(poolCollection);\n\n        _setLatestPoolCollection(poolCollection.poolType(), poolCollection);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function poolCollections() external view returns (IPoolCollection[] memory) {\n        uint256 length = _poolCollections.length();\n        IPoolCollection[] memory list = new IPoolCollection[](length);\n        for (uint256 i = 0; i < length; i++) {\n            list[i] = IPoolCollection(_poolCollections.at(i));\n        }\n        return list;\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function latestPoolCollection(uint16 poolType) external view returns (IPoolCollection) {\n        return _latestPoolCollections[poolType];\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function liquidityPools() external view returns (Token[] memory) {\n        uint256 length = _liquidityPools.length();\n        Token[] memory list = new Token[](length);\n        for (uint256 i = 0; i < length; i++) {\n            list[i] = Token(_liquidityPools.at(i));\n        }\n        return list;\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function collectionByPool(Token pool) external view returns (IPoolCollection) {\n        return _collectionByPool[pool];\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function isPoolValid(Token pool) external view returns (bool) {\n        return address(pool) == address(_bnt) || _liquidityPools.contains(address(pool));\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function createPool(uint16 poolType, Token token) external onlyAdmin nonReentrant {\n        _createPool(poolType, token);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function createPools(uint16 poolType, Token[] calldata tokens) external onlyAdmin nonReentrant {\n        uint256 length = tokens.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            _createPool(poolType, tokens[i]);\n        }\n    }\n\n    /**\n     * @dev creates a new pool\n     */\n    function _createPool(uint16 poolType, Token token) private validAddress(address(token)) {\n        if (token.isEqual(_bnt)) {\n            revert InvalidToken();\n        }\n\n        if (!_liquidityPools.add(address(token))) {\n            revert AlreadyExists();\n        }\n\n        // get the latest pool collection, corresponding to the requested type of the new pool, and use it to create the\n        // pool\n        IPoolCollection poolCollection = _latestPoolCollections[poolType];\n        if (address(poolCollection) == address(0)) {\n            revert InvalidType();\n        }\n\n        // this is where the magic happens...\n        poolCollection.createPool(token);\n\n        // add the pool collection to the reverse pool collection lookup\n        _collectionByPool[token] = poolCollection;\n\n        emit PoolAdded({ pool: token, poolCollection: poolCollection });\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function migratePools(Token[] calldata pools) external nonReentrant {\n        uint256 length = pools.length;\n        for (uint256 i = 0; i < length; i++) {\n            Token pool = pools[i];\n\n            // request the pool migrator to migrate the pool and get the new pool collection it exists in\n            IPoolCollection newPoolCollection = _poolMigrator.migratePool(pool);\n            if (newPoolCollection == IPoolCollection(address(0))) {\n                continue;\n            }\n\n            // update the mapping between pools and their respective pool collections\n            _collectionByPool[pool] = newPoolCollection;\n        }\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function depositFor(\n        address provider,\n        Token pool,\n        uint256 tokenAmount\n    )\n        external\n        payable\n        validAddress(provider)\n        validAddress(address(pool))\n        greaterThanZero(tokenAmount)\n        whenNotPaused\n        nonReentrant\n        returns (uint256)\n    {\n        return _depositFor(provider, pool, tokenAmount, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function deposit(Token pool, uint256 tokenAmount)\n        external\n        payable\n        validAddress(address(pool))\n        greaterThanZero(tokenAmount)\n        whenNotPaused\n        nonReentrant\n        returns (uint256)\n    {\n        return _depositFor(msg.sender, pool, tokenAmount, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function depositForPermitted(\n        address provider,\n        Token pool,\n        uint256 tokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        validAddress(provider)\n        validAddress(address(pool))\n        greaterThanZero(tokenAmount)\n        whenNotPaused\n        nonReentrant\n        returns (uint256)\n    {\n        return _depositBaseTokenForPermitted(provider, pool, tokenAmount, deadline, Signature({ v: v, r: r, s: s }));\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function depositPermitted(\n        Token pool,\n        uint256 tokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external validAddress(address(pool)) greaterThanZero(tokenAmount) whenNotPaused nonReentrant returns (uint256) {\n        return _depositBaseTokenForPermitted(msg.sender, pool, tokenAmount, deadline, Signature({ v: v, r: r, s: s }));\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function initWithdrawal(IPoolToken poolToken, uint256 poolTokenAmount)\n        external\n        validAddress(address(poolToken))\n        greaterThanZero(poolTokenAmount)\n        whenNotPaused\n        nonReentrant\n        returns (uint256)\n    {\n        return _initWithdrawal(msg.sender, poolToken, poolTokenAmount);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function initWithdrawalPermitted(\n        IPoolToken poolToken,\n        uint256 poolTokenAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        validAddress(address(poolToken))\n        greaterThanZero(poolTokenAmount)\n        whenNotPaused\n        nonReentrant\n        returns (uint256)\n    {\n        Token(address(poolToken)).permit(\n            msg.sender,\n            address(this),\n            poolTokenAmount,\n            deadline,\n            Signature({ v: v, r: r, s: s })\n        );\n\n        return _initWithdrawal(msg.sender, poolToken, poolTokenAmount);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function cancelWithdrawal(uint256 id) external whenNotPaused nonReentrant {\n        _pendingWithdrawals.cancelWithdrawal(msg.sender, id);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function withdraw(uint256 id) external whenNotPaused nonReentrant returns (uint256) {\n        address provider = msg.sender;\n        bytes32 contextId = _withdrawContextId(id, provider);\n\n        // complete the withdrawal and claim the locked pool tokens\n        CompletedWithdrawal memory completedRequest = _pendingWithdrawals.completeWithdrawal(contextId, provider, id);\n\n        if (completedRequest.poolToken == _bntPoolToken) {\n            return _withdrawBNT(contextId, provider, completedRequest);\n        }\n\n        return _withdrawBaseToken(contextId, provider, completedRequest);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function tradeBySourceAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount,\n        uint256 deadline,\n        address beneficiary\n    ) external payable whenNotPaused nonReentrant {\n        _verifyTradeParams(sourceToken, targetToken, sourceAmount, minReturnAmount, deadline);\n\n        _trade(\n            TradeTokens({ sourceToken: sourceToken, targetToken: targetToken }),\n            TradeParams({ bySourceAmount: true, amount: sourceAmount, limit: minReturnAmount }),\n            TraderInfo({ trader: msg.sender, beneficiary: beneficiary }),\n            deadline\n        );\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function tradeBySourceAmountPermitted(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount,\n        uint256 deadline,\n        address beneficiary,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused nonReentrant {\n        _verifyTradeParams(sourceToken, targetToken, sourceAmount, minReturnAmount, deadline);\n\n        sourceToken.permit(msg.sender, address(this), sourceAmount, deadline, Signature({ v: v, r: r, s: s }));\n\n        _trade(\n            TradeTokens({ sourceToken: sourceToken, targetToken: targetToken }),\n            TradeParams({ bySourceAmount: true, amount: sourceAmount, limit: minReturnAmount }),\n            TraderInfo({ trader: msg.sender, beneficiary: beneficiary }),\n            deadline\n        );\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function tradeByTargetAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount,\n        uint256 deadline,\n        address beneficiary\n    ) external payable whenNotPaused nonReentrant {\n        _verifyTradeParams(sourceToken, targetToken, targetAmount, maxSourceAmount, deadline);\n\n        _trade(\n            TradeTokens({ sourceToken: sourceToken, targetToken: targetToken }),\n            TradeParams({ bySourceAmount: false, amount: targetAmount, limit: maxSourceAmount }),\n            TraderInfo({ trader: msg.sender, beneficiary: beneficiary }),\n            deadline\n        );\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function tradeByTargetAmountPermitted(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount,\n        uint256 deadline,\n        address beneficiary,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused nonReentrant {\n        _verifyTradeParams(sourceToken, targetToken, targetAmount, maxSourceAmount, deadline);\n\n        sourceToken.permit(msg.sender, address(this), maxSourceAmount, deadline, Signature({ v: v, r: r, s: s }));\n\n        _trade(\n            TradeTokens({ sourceToken: sourceToken, targetToken: targetToken }),\n            TradeParams({ bySourceAmount: false, amount: targetAmount, limit: maxSourceAmount }),\n            TraderInfo({ trader: msg.sender, beneficiary: beneficiary }),\n            deadline\n        );\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function flashLoan(\n        Token token,\n        uint256 amount,\n        IFlashLoanRecipient recipient,\n        bytes calldata data\n    )\n        external\n        validAddress(address(token))\n        greaterThanZero(amount)\n        validAddress(address(recipient))\n        whenNotPaused\n        nonReentrant\n    {\n        if (!token.isEqual(_bnt) && !_networkSettings.isTokenWhitelisted(token)) {\n            revert NotWhitelisted();\n        }\n\n        uint256 feeAmount = MathEx.mulDivF(amount, _networkSettings.flashLoanFeePPM(token), PPM_RESOLUTION);\n\n        // save the current balance\n        uint256 prevBalance = token.balanceOf(address(this));\n\n        // transfer the amount from the master vault to the recipient\n        _masterVault.withdrawFunds(token, payable(address(recipient)), amount);\n\n        // invoke the recipient's callback\n        recipient.onFlashLoan(msg.sender, token.toIERC20(), amount, feeAmount, data);\n\n        // ensure that the tokens + fee have been deposited back to the network\n        uint256 returnedAmount = token.balanceOf(address(this)) - prevBalance;\n        if (returnedAmount < amount + feeAmount) {\n            revert InsufficientFlashLoanReturn();\n        }\n\n        // transfer the amount and the fee back to the vault\n        if (token.isNative()) {\n            payable(address(_masterVault)).sendValue(returnedAmount);\n        } else {\n            token.safeTransfer(payable(address(_masterVault)), returnedAmount);\n        }\n\n        // notify the pool of accrued fees\n        if (token.isEqual(_bnt)) {\n            IBNTPool cachedBNTPool = _bntPool;\n\n            cachedBNTPool.onFeesCollected(token, feeAmount, false);\n        } else {\n            // get the pool and verify that it exists\n            IPoolCollection poolCollection = _poolCollection(token);\n            poolCollection.onFeesCollected(token, feeAmount);\n        }\n\n        emit FlashLoanCompleted({ token: token, borrower: msg.sender, amount: amount, feeAmount: feeAmount });\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function migrateLiquidity(\n        Token token,\n        address provider,\n        uint256 amount,\n        uint256 availableAmount,\n        uint256 originalAmount\n    ) external payable whenNotPaused onlyRoleMember(ROLE_MIGRATION_MANAGER) nonReentrant {\n        bytes32 contextId = keccak256(\n            abi.encodePacked(msg.sender, _time(), token, provider, amount, availableAmount, originalAmount)\n        );\n\n        if (token.isEqual(_bnt)) {\n            _depositBNTFor(contextId, provider, amount, msg.sender, true, originalAmount);\n        } else {\n            _depositBaseTokenFor(contextId, provider, token, amount, msg.sender, availableAmount);\n        }\n\n        emit FundsMigrated(contextId, token, provider, amount, availableAmount, originalAmount);\n    }\n\n    /**\n     * @inheritdoc IBancorNetwork\n     */\n    function withdrawNetworkFees(address recipient)\n        external\n        whenNotPaused\n        onlyRoleMember(ROLE_NETWORK_FEE_MANAGER)\n        validAddress(recipient)\n    {\n        uint256 currentPendingNetworkFeeAmount = _pendingNetworkFeeAmount;\n        if (currentPendingNetworkFeeAmount == 0) {\n            return;\n        }\n\n        _pendingNetworkFeeAmount = 0;\n\n        _masterVault.withdrawFunds(Token(address(_bnt)), payable(recipient), currentPendingNetworkFeeAmount);\n\n        emit NetworkFeesWithdrawn(msg.sender, recipient, currentPendingNetworkFeeAmount);\n    }\n\n    /**\n     * @dev returns whether the network is currently paused\n     */\n    function isPaused() external view returns (bool) {\n        return paused();\n    }\n\n    /**\n     * @dev pauses the network\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_EMERGENCY_STOPPER privilege\n     */\n    function pause() external onlyRoleMember(ROLE_EMERGENCY_STOPPER) {\n        _pause();\n    }\n\n    /**\n     * @dev resumes the network\n     *\n     * requirements:\n     *\n     * - the caller must have the ROLE_EMERGENCY_STOPPER privilege\n     */\n    function resume() external onlyRoleMember(ROLE_EMERGENCY_STOPPER) {\n        _unpause();\n    }\n\n    /**\n     * @dev sets the new latest pool collection for the given type\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function _setLatestPoolCollection(uint16 poolType, IPoolCollection poolCollection) private {\n        IPoolCollection prevLatestPoolCollection = _latestPoolCollections[poolType];\n        if (prevLatestPoolCollection == poolCollection) {\n            return;\n        }\n\n        _latestPoolCollections[poolType] = poolCollection;\n\n        emit LatestPoolCollectionReplaced({\n            poolType: poolType,\n            prevPoolCollection: prevLatestPoolCollection,\n            newPoolCollection: poolCollection\n        });\n    }\n\n    /**\n     * @dev verifies that a pool collection is a valid latest pool collection (e.g., it either exists or a reset to zero)\n     */\n    function _verifyLatestPoolCollectionCandidate(IPoolCollection poolCollection) private view {\n        if (address(poolCollection) != address(0) && !_poolCollections.contains(address(poolCollection))) {\n            revert DoesNotExist();\n        }\n    }\n\n    /**\n     * @dev generates context ID for a deposit request\n     */\n    function _depositContextId(\n        address provider,\n        Token pool,\n        uint256 tokenAmount,\n        address caller\n    ) private view returns (bytes32) {\n        return keccak256(abi.encodePacked(caller, _time(), provider, pool, tokenAmount));\n    }\n\n    /**\n     * @dev generates context ID for a withdraw request\n     */\n    function _withdrawContextId(uint256 id, address caller) private view returns (bytes32) {\n        return keccak256(abi.encodePacked(caller, _time(), id));\n    }\n\n    /**\n     * @dev deposits liquidity for the specified provider from caller\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer the liquidity tokens on its behalf\n     */\n    function _depositFor(\n        address provider,\n        Token pool,\n        uint256 tokenAmount,\n        address caller\n    ) private returns (uint256) {\n        bytes32 contextId = _depositContextId(provider, pool, tokenAmount, caller);\n\n        if (pool.isEqual(_bnt)) {\n            return _depositBNTFor(contextId, provider, tokenAmount, caller, false, 0);\n        }\n\n        return _depositBaseTokenFor(contextId, provider, pool, tokenAmount, caller, tokenAmount);\n    }\n\n    /**\n     * @dev deposits BNT liquidity for the specified provider from caller\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer BNT on its behalf\n     */\n    function _depositBNTFor(\n        bytes32 contextId,\n        address provider,\n        uint256 bntAmount,\n        address caller,\n        bool isMigrating,\n        uint256 originalAmount\n    ) private returns (uint256) {\n        IBNTPool cachedBNTPool = _bntPool;\n\n        // transfer the tokens from the caller to the BNT pool\n        _bnt.transferFrom(caller, address(cachedBNTPool), bntAmount);\n\n        // process BNT pool deposit\n        return cachedBNTPool.depositFor(contextId, provider, bntAmount, isMigrating, originalAmount);\n    }\n\n    /**\n     * @dev deposits base token liquidity for the specified provider from sender\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer base tokens to on its behalf\n     */\n    function _depositBaseTokenFor(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 tokenAmount,\n        address caller,\n        uint256 availableAmount\n    ) private returns (uint256) {\n        // transfer the tokens from the sender to the vault\n        _depositToMasterVault(pool, caller, availableAmount);\n\n        // get the pool collection that managed this pool\n        IPoolCollection poolCollection = _poolCollection(pool);\n\n        // process deposit to the base token pool (includes the native token pool)\n        return poolCollection.depositFor(contextId, provider, pool, tokenAmount);\n    }\n\n    /**\n     * @dev deposits liquidity for the specified provider by providing an EIP712 typed signature for an EIP2612 permit\n     * request\n     *\n     * requirements:\n     *\n     * - the caller must have provided a valid and unused EIP712 typed signature\n     */\n    function _depositBaseTokenForPermitted(\n        address provider,\n        Token pool,\n        uint256 tokenAmount,\n        uint256 deadline,\n        Signature memory signature\n    ) private returns (uint256) {\n        address caller = msg.sender;\n\n        pool.permit(caller, address(this), tokenAmount, deadline, signature);\n\n        return\n            _depositBaseTokenFor(\n                _depositContextId(provider, pool, tokenAmount, caller),\n                provider,\n                pool,\n                tokenAmount,\n                caller,\n                tokenAmount\n            );\n    }\n\n    /**\n     * @dev handles BNT withdrawal\n     */\n    function _withdrawBNT(\n        bytes32 contextId,\n        address provider,\n        CompletedWithdrawal memory completedRequest\n    ) private returns (uint256) {\n        IBNTPool cachedBNTPool = _bntPool;\n\n        // approve the BNT pool to transfer pool tokens, which we have received from the completion of the\n        // pending withdrawal, on behalf of the network\n        completedRequest.poolToken.approve(address(cachedBNTPool), completedRequest.poolTokenAmount);\n\n        // transfer VBNT from the caller to the BNT pool\n        _vbnt.transferFrom(provider, address(cachedBNTPool), completedRequest.poolTokenAmount);\n\n        // call withdraw on the BNT pool\n        return cachedBNTPool.withdraw(contextId, provider, completedRequest.poolTokenAmount);\n    }\n\n    /**\n     * @dev handles base token withdrawal\n     */\n    function _withdrawBaseToken(\n        bytes32 contextId,\n        address provider,\n        CompletedWithdrawal memory completedRequest\n    ) private returns (uint256) {\n        Token pool = completedRequest.poolToken.reserveToken();\n\n        // get the pool collection that manages this pool\n        IPoolCollection poolCollection = _poolCollection(pool);\n\n        // approve the pool collection to transfer pool tokens, which we have received from the completion of the\n        // pending withdrawal, on behalf of the network\n        completedRequest.poolToken.approve(address(poolCollection), completedRequest.poolTokenAmount);\n\n        // call withdraw on the base token pool - returns the amounts/breakdown\n        return poolCollection.withdraw(contextId, provider, pool, completedRequest.poolTokenAmount);\n    }\n\n    /**\n     * @dev verifies that the provided trade params are valid\n     */\n    function _verifyTradeParams(\n        Token sourceToken,\n        Token targetToken,\n        uint256 amount,\n        uint256 limit,\n        uint256 deadline\n    ) internal view {\n        _validAddress(address(sourceToken));\n        _validAddress(address(targetToken));\n\n        if (sourceToken == targetToken) {\n            revert InvalidToken();\n        }\n\n        _greaterThanZero(amount);\n        _greaterThanZero(limit);\n\n        if (deadline < _time()) {\n            revert DeadlineExpired();\n        }\n    }\n\n    /**\n     * @dev performs a trade by providing either the source or target amount:\n     *\n     * - when trading by the source amount, the amount represents the source amount and the limit is the minimum return\n     *   amount\n     * - when trading by the target amount, the amount represents the target amount and the limit is the maximum source\n     *   amount\n     *\n     * requirements:\n     *\n     * - the caller must have approved the network to transfer the source tokens on its behalf (except for in the\n     *   native token case)\n     */\n    function _trade(\n        TradeTokens memory tokens,\n        TradeParams memory params,\n        TraderInfo memory traderInfo,\n        uint256 deadline\n    ) private {\n        // ensure the beneficiary is set\n        if (traderInfo.beneficiary == address(0)) {\n            traderInfo.beneficiary = traderInfo.trader;\n        }\n\n        bytes32 contextId = keccak256(\n            abi.encodePacked(\n                traderInfo.trader,\n                _time(),\n                tokens.sourceToken,\n                tokens.targetToken,\n                params.amount,\n                params.limit,\n                params.bySourceAmount,\n                deadline,\n                traderInfo.beneficiary\n            )\n        );\n\n        // perform either a single or double hop trade, based on the source and the target pool\n        bool fromBNT = tokens.sourceToken.isEqual(_bnt);\n        TradeResult memory firstHopTradeResult;\n        TradeResult memory lastHopTradeResult;\n        uint256 networkFeeAmount;\n\n        if (fromBNT || tokens.targetToken.isEqual(_bnt)) {\n            lastHopTradeResult = _tradeBNT(\n                contextId,\n                fromBNT ? tokens.targetToken : tokens.sourceToken,\n                fromBNT,\n                params\n            );\n\n            firstHopTradeResult = lastHopTradeResult;\n\n            networkFeeAmount = lastHopTradeResult.networkFeeAmount;\n\n            emit TokensTraded({\n                contextId: contextId,\n                sourceToken: tokens.sourceToken,\n                targetToken: tokens.targetToken,\n                sourceAmount: lastHopTradeResult.sourceAmount,\n                targetAmount: lastHopTradeResult.targetAmount,\n                bntAmount: fromBNT ? lastHopTradeResult.sourceAmount : lastHopTradeResult.targetAmount,\n                targetFeeAmount: lastHopTradeResult.tradingFeeAmount,\n                bntFeeAmount: fromBNT ? 0 : lastHopTradeResult.tradingFeeAmount,\n                trader: traderInfo.trader\n            });\n        } else {\n            (firstHopTradeResult, lastHopTradeResult) = _tradeBaseTokens(contextId, tokens, params);\n\n            networkFeeAmount = firstHopTradeResult.networkFeeAmount + lastHopTradeResult.networkFeeAmount;\n\n            emit TokensTraded({\n                contextId: contextId,\n                sourceToken: tokens.sourceToken,\n                targetToken: tokens.targetToken,\n                sourceAmount: firstHopTradeResult.sourceAmount,\n                targetAmount: lastHopTradeResult.targetAmount,\n                bntAmount: firstHopTradeResult.targetAmount,\n                targetFeeAmount: lastHopTradeResult.tradingFeeAmount,\n                bntFeeAmount: firstHopTradeResult.tradingFeeAmount,\n                trader: traderInfo.trader\n            });\n        }\n\n        // transfer the tokens from the trader to the vault\n        _depositToMasterVault(tokens.sourceToken, traderInfo.trader, firstHopTradeResult.sourceAmount);\n\n        // transfer the target tokens/native token to the beneficiary\n        _masterVault.withdrawFunds(\n            tokens.targetToken,\n            payable(traderInfo.beneficiary),\n            lastHopTradeResult.targetAmount\n        );\n\n        // update the pending network fee amount to be burned by the vortex\n        _pendingNetworkFeeAmount += networkFeeAmount;\n    }\n\n    /**\n     * @dev performs a single hop between BNT and a base token trade by providing either the source or the target amount\n     *\n     * - when trading by the source amount, the amount represents the source amount and the limit is the minimum return\n     *   amount\n     * - when trading by the target amount, the amount represents the target amount and the limit is the maximum source\n     *   amount\n     */\n    function _tradeBNT(\n        bytes32 contextId,\n        Token pool,\n        bool fromBNT,\n        TradeParams memory params\n    ) private returns (TradeResult memory) {\n        TradeTokens memory tokens = fromBNT\n            ? TradeTokens({ sourceToken: Token(address(_bnt)), targetToken: pool })\n            : TradeTokens({ sourceToken: pool, targetToken: Token(address(_bnt)) });\n\n        TradeAmountAndFee memory tradeAmountsAndFee = params.bySourceAmount\n            ? _poolCollection(pool).tradeBySourceAmount(\n                contextId,\n                tokens.sourceToken,\n                tokens.targetToken,\n                params.amount,\n                params.limit\n            )\n            : _poolCollection(pool).tradeByTargetAmount(\n                contextId,\n                tokens.sourceToken,\n                tokens.targetToken,\n                params.amount,\n                params.limit\n            );\n\n        // if the target token is BNT, notify the BNT pool on collected fees (which shouldn't include the network fee\n        // amount, so we have to deduct it explicitly from the full trading fee amount)\n        if (!fromBNT) {\n            _bntPool.onFeesCollected(\n                pool,\n                tradeAmountsAndFee.tradingFeeAmount - tradeAmountsAndFee.networkFeeAmount,\n                true\n            );\n        }\n\n        return\n            TradeResult({\n                sourceAmount: params.bySourceAmount ? params.amount : tradeAmountsAndFee.amount,\n                targetAmount: params.bySourceAmount ? tradeAmountsAndFee.amount : params.amount,\n                tradingFeeAmount: tradeAmountsAndFee.tradingFeeAmount,\n                networkFeeAmount: tradeAmountsAndFee.networkFeeAmount\n            });\n    }\n\n    /**\n     * @dev performs a double hop trade between two base tokens by providing either the source or the target amount\n     *\n     * - when trading by the source amount, the amount represents the source amount and the limit is the minimum return\n     *   amount\n     * - when trading by the target amount, the amount represents the target amount and the limit is the maximum source\n     *   amount\n     */\n    function _tradeBaseTokens(\n        bytes32 contextId,\n        TradeTokens memory tokens,\n        TradeParams memory params\n    ) private returns (TradeResult memory, TradeResult memory) {\n        if (params.bySourceAmount) {\n            uint256 sourceAmount = params.amount;\n            uint256 minReturnAmount = params.limit;\n\n            // trade source tokens to BNT (while accepting any return amount)\n            TradeResult memory targetHop1 = _tradeBNT(\n                contextId,\n                tokens.sourceToken,\n                false,\n                TradeParams({ bySourceAmount: true, amount: sourceAmount, limit: 1 })\n            );\n\n            // trade the received BNT target amount to target tokens (while respecting the minimum return amount)\n            TradeResult memory targetHop2 = _tradeBNT(\n                contextId,\n                tokens.targetToken,\n                true,\n                TradeParams({ bySourceAmount: true, amount: targetHop1.targetAmount, limit: minReturnAmount })\n            );\n\n            return (targetHop1, targetHop2);\n        }\n\n        uint256 targetAmount = params.amount;\n        uint256 maxSourceAmount = params.limit;\n\n        // trade any amount of BNT to get the requested target amount (we will use the actual traded amount to restrict\n        // the trade from the source)\n        TradeResult memory sourceHop2 = _tradeBNT(\n            contextId,\n            tokens.targetToken,\n            true,\n            TradeParams({ bySourceAmount: false, amount: targetAmount, limit: type(uint256).max })\n        );\n\n        // trade source tokens to the required amount of BNT (while respecting the maximum source amount)\n        TradeResult memory sourceHop1 = _tradeBNT(\n            contextId,\n            tokens.sourceToken,\n            false,\n            TradeParams({ bySourceAmount: false, amount: sourceHop2.sourceAmount, limit: maxSourceAmount })\n        );\n\n        return (sourceHop1, sourceHop2);\n    }\n\n    /**\n     * @dev deposits tokens to the master vault and verifies that msg.value corresponds to its type\n     */\n    function _depositToMasterVault(\n        Token token,\n        address caller,\n        uint256 amount\n    ) private {\n        if (token.isNative()) {\n            if (msg.value < amount) {\n                revert NativeTokenAmountMismatch();\n            }\n\n            // using a regular transfer here would revert due to exceeding the 2300 gas limit which is why we're using\n            // call instead (via sendValue), which the 2300 gas limit does not apply for\n            payable(address(_masterVault)).sendValue(amount);\n\n            // refund the caller for the remaining native token amount\n            if (msg.value > amount) {\n                payable(address(caller)).sendValue(msg.value - amount);\n            }\n        } else {\n            if (msg.value > 0) {\n                revert NativeTokenAmountMismatch();\n            }\n\n            token.safeTransferFrom(caller, address(_masterVault), amount);\n        }\n    }\n\n    /**\n     * @dev verifies that the specified pool is managed by a valid pool collection and returns it\n     */\n    function _poolCollection(Token token) private view returns (IPoolCollection) {\n        // verify that the pool is managed by a valid pool collection\n        IPoolCollection poolCollection = _collectionByPool[token];\n        if (address(poolCollection) == address(0)) {\n            revert InvalidToken();\n        }\n\n        return poolCollection;\n    }\n\n    /**\n     * @dev initiates liquidity withdrawal\n     */\n    function _initWithdrawal(\n        address provider,\n        IPoolToken poolToken,\n        uint256 poolTokenAmount\n    ) private returns (uint256) {\n        // transfer the pool tokens from the provider. Note, that the provider should have either previously approved\n        // the pool token amount or provided a EIP712 typed signature for an EIP2612 permit request\n        poolToken.safeTransferFrom(provider, address(_pendingWithdrawals), poolTokenAmount);\n\n        return _pendingWithdrawals.initWithdrawal(provider, poolToken, poolTokenAmount);\n    }\n\n    /**\n     * @dev grants/revokes required roles to/from a pool collection\n     */\n    function _setAccessRoles(IPoolCollection poolCollection, bool set) private {\n        address poolCollectionAddress = address(poolCollection);\n\n        if (set) {\n            _bntPool.grantRole(ROLE_BNT_MANAGER, poolCollectionAddress);\n            _bntPool.grantRole(ROLE_VAULT_MANAGER, poolCollectionAddress);\n            _bntPool.grantRole(ROLE_FUNDING_MANAGER, poolCollectionAddress);\n            _masterVault.grantRole(ROLE_ASSET_MANAGER, poolCollectionAddress);\n            _externalProtectionVault.grantRole(ROLE_ASSET_MANAGER, poolCollectionAddress);\n        } else {\n            _bntPool.revokeRole(ROLE_BNT_MANAGER, poolCollectionAddress);\n            _bntPool.revokeRole(ROLE_VAULT_MANAGER, poolCollectionAddress);\n            _bntPool.revokeRole(ROLE_FUNDING_MANAGER, poolCollectionAddress);\n            _masterVault.revokeRole(ROLE_ASSET_MANAGER, poolCollectionAddress);\n            _externalProtectionVault.revokeRole(ROLE_ASSET_MANAGER, poolCollectionAddress);\n        }\n    }\n}\n"
    },
    "contracts/pools/PoolMigrator.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { Pool, PoolLiquidity, IPoolCollection, AverageRate } from \"./interfaces/IPoolCollection.sol\";\nimport { IPoolToken } from \"./interfaces/IPoolToken.sol\";\nimport { IPoolMigrator } from \"./interfaces/IPoolMigrator.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Fraction } from \"../utility/FractionLibrary.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { Utils, InvalidPool, InvalidPoolCollection } from \"../utility/Utils.sol\";\n\ninterface IPoolCollectionBase {\n    function migratePoolOut(Token pool, IPoolCollection targetPoolCollection) external;\n}\n\ninterface IPoolCollectionV1 is IPoolCollectionBase {\n    struct PoolLiquidityV1 {\n        uint128 bntTradingLiquidity; // the BNT trading liquidity\n        uint128 baseTokenTradingLiquidity; // the base token trading liquidity\n        uint256 stakedBalance; // the staked balance\n    }\n\n    struct PoolV1 {\n        IPoolToken poolToken; // the pool token of a given pool\n        uint32 tradingFeePPM; // the trading fee (in units of PPM)\n        bool tradingEnabled; // whether trading is enabled\n        bool depositingEnabled; // whether depositing is enabled\n        AverageRate averageRate; // the recent average rate\n        uint256 depositLimit; // the deposit limit\n        PoolLiquidityV1 liquidity; // the overall liquidity in the pool\n    }\n\n    function poolData(Token token) external view returns (PoolV1 memory);\n}\n\n/**\n * @dev Pool Migrator contract\n */\ncontract PoolMigrator is IPoolMigrator, Upgradeable, Utils {\n    error UnsupportedVersion();\n\n    IPoolCollection private constant INVALID_POOL_COLLECTION = IPoolCollection(address(0));\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 0] private __gap;\n\n    /**\n     * @dev triggered when an existing pool is migrated between pool collections\n     */\n    event PoolMigrated(Token indexed pool, IPoolCollection prevPoolCollection, IPoolCollection newPoolCollection);\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(IBancorNetwork initNetwork) validAddress(address(initNetwork)) {\n        _network = initNetwork;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __PoolMigrator_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __PoolMigrator_init() internal onlyInitializing {\n        __Upgradeable_init();\n\n        __PoolMigrator_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __PoolMigrator_init_unchained() internal onlyInitializing {}\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IPoolMigrator\n     */\n    function migratePool(Token pool) external only(address(_network)) returns (IPoolCollection) {\n        if (address(pool) == address(0)) {\n            revert InvalidPool();\n        }\n\n        // get the pool collection that this pool exists in\n        IPoolCollection prevPoolCollection = _network.collectionByPool(pool);\n        if (address(prevPoolCollection) == address(0)) {\n            revert InvalidPool();\n        }\n\n        // get the latest pool collection corresponding to its type and ensure that a migration is necessary\n        // note that it's currently not possible to add two pool collections with the same version or type\n        uint16 poolType = prevPoolCollection.poolType();\n        IPoolCollection newPoolCollection = _network.latestPoolCollection(poolType);\n        if (address(newPoolCollection) == address(prevPoolCollection)) {\n            revert InvalidPoolCollection();\n        }\n\n        // migrate all relevant values based on a historical collection version into the new pool collection\n        if (prevPoolCollection.version() == 1) {\n            _migrateFromV1(pool, IPoolCollectionV1(address(prevPoolCollection)), newPoolCollection);\n\n            emit PoolMigrated({\n                pool: pool,\n                prevPoolCollection: prevPoolCollection,\n                newPoolCollection: newPoolCollection\n            });\n\n            return newPoolCollection;\n        }\n\n        revert UnsupportedVersion();\n    }\n\n    /**\n     * @dev migrates a V1 pool to the latest pool version\n     */\n    function _migrateFromV1(\n        Token pool,\n        IPoolCollectionV1 sourcePoolCollection,\n        IPoolCollection targetPoolCollection\n    ) private {\n        IPoolCollectionV1.PoolV1 memory data = sourcePoolCollection.poolData(pool);\n\n        // since the latest pool collection is also v1, currently not additional pre- or post-processing is needed\n        Pool memory newData = Pool({\n            poolToken: data.poolToken,\n            tradingFeePPM: data.tradingFeePPM,\n            tradingEnabled: data.tradingEnabled,\n            depositingEnabled: data.depositingEnabled,\n            averageRate: data.averageRate,\n            depositLimit: data.depositLimit,\n            liquidity: PoolLiquidity({\n                bntTradingLiquidity: data.liquidity.bntTradingLiquidity,\n                baseTokenTradingLiquidity: data.liquidity.baseTokenTradingLiquidity,\n                stakedBalance: data.liquidity.stakedBalance\n            })\n        });\n\n        sourcePoolCollection.migratePoolOut(pool, targetPoolCollection);\n        targetPoolCollection.migratePoolIn(pool, newData);\n    }\n}\n"
    },
    "contracts/utility/TransparentUpgradeableProxyImmutable.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport { AccessDenied, Utils } from \"./Utils.sol\";\n\n/**\n * @dev this contract is a slightly optimized version of the original TransparentUpgradeableProxy solely designed to\n * work with the ProxyAdmin contract:\n *\n * - the address of the admin is stored as an immutable state variables and as the result:\n * - the address of the admin can't be change, so the changeAdmin() function was subsequently removed\n */\ncontract TransparentUpgradeableProxyImmutable is ERC1967Proxy, Utils {\n    address internal immutable _admin;\n\n    /**\n     * @dev initializes an upgradeable proxy managed by `initAdmin`, backed by the implementation at `logic`, and\n     * optionally initialized with `data` as explained in {ERC1967Proxy-constructor}\n     */\n    constructor(\n        address logic,\n        address initAdmin,\n        bytes memory data\n    ) payable ERC1967Proxy(logic, data) validAddress(initAdmin) {\n        _admin = initAdmin;\n\n        // still store it to work with EIP-1967\n        _changeAdmin(initAdmin);\n    }\n\n    modifier ifAdmin() {\n        if (msg.sender == _admin) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev returns the current admin\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function admin() external ifAdmin returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @dev returns the current implementation.\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev upgrades the implementation of the proxy\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by data, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev makes sure the admin cannot access the fallback function\n     */\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _admin) {\n            revert AccessDenied();\n        }\n\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/helpers/TestIFlashLoanRecipient.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IBancorNetwork, IFlashLoanRecipient } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract TestFlashLoanRecipient is IFlashLoanRecipient {\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n    using TokenLibrary for Token;\n\n    struct CallbackData {\n        address caller;\n        IERC20 token;\n        uint256 amount;\n        uint256 feeAmount;\n        bytes data;\n        uint256 receivedAmount;\n    }\n\n    IBancorNetwork private immutable _network;\n    mapping(IERC20 => uint256) private _snapshots;\n    CallbackData private _callbackData;\n    uint256 private _amountToReturn;\n    bool private _reenter;\n\n    constructor(IBancorNetwork network) {\n        _network = network;\n    }\n\n    receive() external payable {}\n\n    function snapshot(IERC20 token) external {\n        _snapshots[token] = Token(address(token)).balanceOf(address(this));\n    }\n\n    function callbackData() external view returns (CallbackData memory) {\n        return _callbackData;\n    }\n\n    function setAmountToReturn(uint256 amountToReturn) external {\n        _amountToReturn = amountToReturn;\n    }\n\n    function setReenter(bool reenter) external {\n        _reenter = reenter;\n    }\n\n    function onFlashLoan(\n        address caller,\n        IERC20 erc20Token,\n        uint256 amount,\n        uint256 feeAmount,\n        bytes memory data\n    ) external {\n        Token token = Token(address(erc20Token));\n\n        _callbackData = CallbackData({\n            caller: caller,\n            token: erc20Token,\n            amount: amount,\n            feeAmount: feeAmount,\n            data: data,\n            receivedAmount: token.balanceOf(address(this)) - _snapshots[erc20Token]\n        });\n\n        if (_reenter) {\n            _network.flashLoan(token, amount, IFlashLoanRecipient(address(this)), new bytes(0));\n        }\n\n        uint256 returnAmount = _amountToReturn != 0 ? _amountToReturn : amount + feeAmount;\n        if (token.isNative()) {\n            payable(msg.sender).sendValue(returnAmount);\n        } else {\n            token.safeTransfer(msg.sender, returnAmount);\n        }\n    }\n}\n"
    },
    "contracts/helpers/TestBancorNetwork.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { Time } from \"../utility/Time.sol\";\n\nimport { INetworkSettings } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IPendingWithdrawals, CompletedWithdrawal } from \"../network/interfaces/IPendingWithdrawals.sol\";\nimport { BancorNetwork } from \"../network/BancorNetwork.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\nimport { IExternalProtectionVault } from \"../vaults/interfaces/IExternalProtectionVault.sol\";\n\nimport { IPoolCollection, TradeAmountAndFee } from \"../pools/interfaces/IPoolCollection.sol\";\nimport { IPoolMigrator } from \"../pools/interfaces/IPoolMigrator.sol\";\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { TestTime } from \"./TestTime.sol\";\n\ncontract TestBancorNetwork is BancorNetwork, TestTime {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        ITokenGovernance initBNTGovernance,\n        ITokenGovernance initVBNTGovernance,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IExternalProtectionVault initExternalProtectionVault,\n        IPoolToken initBNTPoolToken\n    )\n        BancorNetwork(\n            initBNTGovernance,\n            initVBNTGovernance,\n            initNetworkSettings,\n            initMasterVault,\n            initExternalProtectionVault,\n            initBNTPoolToken\n        )\n    {}\n\n    function bntPool() external view returns (IBNTPool) {\n        return _bntPool;\n    }\n\n    function pendingWithdrawals() external view returns (IPendingWithdrawals) {\n        return _pendingWithdrawals;\n    }\n\n    function createPoolT(IPoolCollection poolCollection, Token token) external {\n        poolCollection.createPool(token);\n    }\n\n    function migratePoolT(IPoolMigrator poolMigrator, Token pool) external returns (IPoolCollection) {\n        return poolMigrator.migratePool(pool);\n    }\n\n    function completeWithdrawalT(\n        bytes32 contextId,\n        address provider,\n        uint256 id\n    ) external returns (CompletedWithdrawal memory) {\n        return _pendingWithdrawals.completeWithdrawal(contextId, provider, id);\n    }\n\n    function depositToBNTPoolForT(\n        bytes32 contextId,\n        address provider,\n        uint256 bntAmount,\n        bool isMigrating,\n        uint256 originalPoolTokenAmount\n    ) external returns (uint256) {\n        return _bntPool.depositFor(contextId, provider, bntAmount, isMigrating, originalPoolTokenAmount);\n    }\n\n    function depositToPoolCollectionForT(\n        IPoolCollection poolCollection,\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 tokenAmount\n    ) external returns (uint256) {\n        return poolCollection.depositFor(contextId, provider, pool, tokenAmount);\n    }\n\n    function withdrawFromBNTPoolT(\n        bytes32 contextId,\n        address provider,\n        uint256 poolTokenAmount\n    ) external returns (uint256) {\n        return _bntPool.withdraw(contextId, provider, poolTokenAmount);\n    }\n\n    function withdrawFromPoolCollectionT(\n        IPoolCollection poolCollection,\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 poolTokenAmount\n    ) external returns (uint256) {\n        return poolCollection.withdraw(contextId, provider, pool, poolTokenAmount);\n    }\n\n    function onBNTFeesCollectedT(\n        Token pool,\n        uint256 amount,\n        bool isTraderFee\n    ) external {\n        _bntPool.onFeesCollected(pool, amount, isTraderFee);\n    }\n\n    function onPoolCollectionFeesCollectedT(\n        IPoolCollection poolCollection,\n        Token pool,\n        uint256 amount\n    ) external {\n        poolCollection.onFeesCollected(pool, amount);\n    }\n\n    function tradeBySourcePoolCollectionT(\n        IPoolCollection poolCollection,\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount\n    ) external returns (TradeAmountAndFee memory) {\n        return poolCollection.tradeBySourceAmount(contextId, sourceToken, targetToken, sourceAmount, minReturnAmount);\n    }\n\n    function tradeByTargetPoolCollectionT(\n        IPoolCollection poolCollection,\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount\n    ) external returns (TradeAmountAndFee memory) {\n        return poolCollection.tradeByTargetAmount(contextId, sourceToken, targetToken, targetAmount, maxSourceAmount);\n    }\n\n    function approveT(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) external {\n        token.safeApprove(spender, amount);\n    }\n\n    function _time() internal view virtual override(Time, TestTime) returns (uint32) {\n        return TestTime._time();\n    }\n}\n"
    },
    "contracts/helpers/TestPoolMigrator.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { IPoolCollection, Pool } from \"../pools/interfaces/IPoolCollection.sol\";\n\nimport { PoolMigrator } from \"../pools/PoolMigrator.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\ncontract TestPoolMigrator is PoolMigrator {\n    constructor(IBancorNetwork initNetwork) PoolMigrator(initNetwork) {}\n\n    function migratePoolInT(\n        IPoolCollection poolCollection,\n        Token pool,\n        Pool memory data\n    ) external {\n        poolCollection.migratePoolIn(pool, data);\n    }\n\n    function migratePoolOutT(\n        IPoolCollection poolCollection,\n        Token pool,\n        IPoolCollection targetPoolCollection\n    ) external {\n        poolCollection.migratePoolOut(pool, targetPoolCollection);\n    }\n}\n"
    },
    "contracts/helpers/TestPoolCollection.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings } from \"../network/interfaces/INetworkSettings.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\nimport { IExternalProtectionVault } from \"../vaults/interfaces/IExternalProtectionVault.sol\";\n\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IPoolTokenFactory } from \"../pools/interfaces/IPoolTokenFactory.sol\";\nimport { IPoolMigrator } from \"../pools/interfaces/IPoolMigrator.sol\";\nimport { PoolCollection, Pool, PoolLiquidity, InternalWithdrawalAmounts, PoolRateState } from \"../pools/PoolCollection.sol\";\nimport { AverageRate } from \"../pools/interfaces/IPoolCollection.sol\";\n\nimport { BlockNumber } from \"../utility/BlockNumber.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { TestBlockNumber } from \"./TestBlockNumber.sol\";\n\ncontract TestPoolCollection is PoolCollection, TestBlockNumber {\n    uint16 private immutable _version;\n\n    constructor(\n        uint16 initVersion,\n        IBancorNetwork initNetwork,\n        IERC20 initBNT,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IBNTPool initBNTPool,\n        IExternalProtectionVault initExternalProtectionVault,\n        IPoolTokenFactory initPoolTokenFactory,\n        IPoolMigrator initPoolMigrator\n    )\n        PoolCollection(\n            initNetwork,\n            initBNT,\n            initNetworkSettings,\n            initMasterVault,\n            initBNTPool,\n            initExternalProtectionVault,\n            initPoolTokenFactory,\n            initPoolMigrator\n        )\n    {\n        _version = initVersion;\n    }\n\n    function version() external view override returns (uint16) {\n        return _version;\n    }\n\n    function setTradingLiquidityT(Token pool, PoolLiquidity calldata liquidity) external {\n        _poolData[pool].liquidity = liquidity;\n    }\n\n    function setAverageRateT(Token pool, AverageRate calldata newAverageRate) external {\n        _poolData[pool].averageRate = newAverageRate;\n    }\n\n    function poolWithdrawalAmountsT(Token pool, uint256 poolTokenAmount)\n        external\n        view\n        returns (InternalWithdrawalAmounts memory)\n    {\n        return _poolWithdrawalAmounts(pool, _poolData[pool], poolTokenAmount);\n    }\n\n    function mintPoolTokenT(\n        Token pool,\n        address recipient,\n        uint256 poolTokenAmount\n    ) external {\n        return _poolData[pool].poolToken.mint(recipient, poolTokenAmount);\n    }\n\n    function requestFundingT(\n        bytes32 contextId,\n        Token pool,\n        uint256 bntAmount\n    ) external {\n        _bntPool.requestFunding(contextId, pool, bntAmount);\n    }\n\n    function isPoolRateStable(Token pool) external view returns (bool) {\n        Pool memory data = _poolData[pool];\n        return _poolRateState(data.liquidity, data.averageRate) == PoolRateState.Stable;\n    }\n\n    function _blockNumber() internal view virtual override(BlockNumber, TestBlockNumber) returns (uint32) {\n        return TestBlockNumber._blockNumber();\n    }\n}\n"
    },
    "contracts/helpers/TestBlockNumber.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { BlockNumber } from \"../utility/BlockNumber.sol\";\n\ncontract TestBlockNumber is BlockNumber {\n    uint32 private _currentBlockNumber = 1;\n\n    function _blockNumber() internal view virtual override returns (uint32) {\n        return _currentBlockNumber;\n    }\n\n    function setBlockNumber(uint32 newBlockNumber) external {\n        _currentBlockNumber = newBlockNumber;\n    }\n\n    function currentBlockNumber() external view returns (uint32) {\n        return _currentBlockNumber;\n    }\n}\n"
    },
    "contracts/pools/BNTPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, InvalidStakedBalance } from \"../utility/Utils.sol\";\nimport { PPM_RESOLUTION } from \"../utility/Constants.sol\";\nimport { Fraction } from \"../utility/FractionLibrary.sol\";\nimport { MathEx } from \"../utility/MathEx.sol\";\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\n\n// prettier-ignore\nimport {\n    IBNTPool,\n    ROLE_BNT_POOL_TOKEN_MANAGER,\n    ROLE_BNT_MANAGER,\n    ROLE_VAULT_MANAGER,\n    ROLE_FUNDING_MANAGER\n} from \"./interfaces/IBNTPool.sol\";\n\nimport { IPoolToken } from \"./interfaces/IPoolToken.sol\";\nimport { IPoolCollection, Pool } from \"./interfaces/IPoolCollection.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { Vault } from \"../vaults/Vault.sol\";\nimport { IVault } from \"../vaults/interfaces/IVault.sol\";\n\nimport { PoolToken } from \"./PoolToken.sol\";\n\n/**\n * @dev BNT Pool contract\n */\ncontract BNTPool is IBNTPool, Vault {\n    using TokenLibrary for Token;\n\n    error FundingLimitExceeded();\n\n    struct InternalWithdrawalAmounts {\n        uint256 bntAmount;\n        uint256 withdrawalFeeAmount;\n    }\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the master vault contract\n    IMasterVault private immutable _masterVault;\n\n    // the BNT pool token\n    IPoolToken internal immutable _poolToken;\n\n    // the total staked BNT balance in the network\n    uint256 private _stakedBalance;\n\n    // a mapping between pools and their current funding\n    mapping(Token => uint256) private _currentPoolFunding;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 2] private __gap;\n\n    /**\n     * @dev triggered when liquidity is deposited\n     */\n    event TokensDeposited(\n        bytes32 indexed contextId,\n        address indexed provider,\n        uint256 bntAmount,\n        uint256 poolTokenAmount,\n        uint256 vbntAmount\n    );\n\n    /**\n     * @dev triggered when liquidity is withdrawn\n     */\n    event TokensWithdrawn(\n        bytes32 indexed contextId,\n        address indexed provider,\n        uint256 bntAmount,\n        uint256 poolTokenAmount,\n        uint256 vbntAmount,\n        uint256 withdrawalFeeAmount\n    );\n\n    /**\n     * @dev triggered when funding is requested\n     */\n    event FundingRequested(bytes32 indexed contextId, Token indexed pool, uint256 bntAmount, uint256 poolTokenAmount);\n\n    /**\n     * @dev triggered when funding is renounced\n     */\n    event FundingRenounced(bytes32 indexed contextId, Token indexed pool, uint256 bntAmount, uint256 poolTokenAmount);\n\n    /**\n     * @dev triggered when the total liquidity in the BNT pool is updated\n     */\n    event TotalLiquidityUpdated(\n        bytes32 indexed contextId,\n        uint256 liquidity,\n        uint256 stakedBalance,\n        uint256 poolTokenSupply\n    );\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        ITokenGovernance initBNTGovernance,\n        ITokenGovernance initVBNTGovernance,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IPoolToken initBNTPoolToken\n    )\n        Vault(initBNTGovernance, initVBNTGovernance)\n        validAddress(address(initNetwork))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initMasterVault))\n        validAddress(address(initBNTPoolToken))\n    {\n        _network = initNetwork;\n        _networkSettings = initNetworkSettings;\n        _masterVault = initMasterVault;\n        _poolToken = initBNTPoolToken;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __BNTPool_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __BNTPool_init() internal onlyInitializing {\n        __Vault_init();\n\n        __BNTPool_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __BNTPool_init_unchained() internal onlyInitializing {\n        _poolToken.acceptOwnership();\n\n        // set up administrative roles\n        _setRoleAdmin(ROLE_BNT_POOL_TOKEN_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_BNT_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_VAULT_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_FUNDING_MANAGER, ROLE_ADMIN);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    modifier poolWhitelisted(Token pool) {\n        _poolWhitelisted(pool);\n\n        _;\n    }\n\n    /**\n     * @dev validates that the provided pool is whitelisted\n     */\n    function _poolWhitelisted(Token pool) internal view {\n        if (!_networkSettings.isTokenWhitelisted(pool)) {\n            revert NotWhitelisted();\n        }\n    }\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc Vault\n     */\n    function isPayable() public pure override(IVault, Vault) returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev returns the BNT pool token manager role\n     */\n    function roleBNTPoolTokenManager() external pure returns (bytes32) {\n        return ROLE_BNT_POOL_TOKEN_MANAGER;\n    }\n\n    /**\n     * @dev returns the BNT manager role\n     */\n    function roleBNTManager() external pure returns (bytes32) {\n        return ROLE_BNT_MANAGER;\n    }\n\n    /**\n     * @dev returns the vault manager role\n     */\n    function roleVaultManager() external pure returns (bytes32) {\n        return ROLE_VAULT_MANAGER;\n    }\n\n    /**\n     * @dev returns the funding manager role\n     */\n    function roleFundingManager() external pure returns (bytes32) {\n        return ROLE_FUNDING_MANAGER;\n    }\n\n    /**\n     * @dev returns whether the given caller is allowed access to the given token\n     *\n     * requirements:\n     *\n     * - the token must be the BNT pool token\n     * - the caller must have the ROLE_BNT_POOL_TOKEN_MANAGER role\n     */\n    function isAuthorizedWithdrawal(\n        address caller,\n        Token token,\n        address, /* target */\n        uint256 /* amount */\n    ) internal view override returns (bool) {\n        return token.isEqual(_poolToken) && hasRole(ROLE_BNT_POOL_TOKEN_MANAGER, caller);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function poolToken() external view returns (IPoolToken) {\n        return _poolToken;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function stakedBalance() external view returns (uint256) {\n        return _stakedBalance;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function currentPoolFunding(Token pool) external view returns (uint256) {\n        return _currentPoolFunding[pool];\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function availableFunding(Token pool) external view returns (uint256) {\n        return MathEx.subMax0(_networkSettings.poolFundingLimit(pool), _currentPoolFunding[pool]);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function poolTokenToUnderlying(uint256 poolTokenAmount) external view returns (uint256) {\n        return _poolTokenToUnderlying(poolTokenAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function underlyingToPoolToken(uint256 bntAmount) external view returns (uint256) {\n        return _underlyingToPoolToken(bntAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function poolTokenAmountToBurn(uint256 bntAmountToDistribute) external view returns (uint256) {\n        if (bntAmountToDistribute == 0) {\n            return 0;\n        }\n\n        uint256 poolTokenSupply = _poolToken.totalSupply();\n        uint256 val = bntAmountToDistribute * poolTokenSupply;\n\n        return\n            MathEx.mulDivF(\n                val,\n                poolTokenSupply,\n                val + _stakedBalance * (poolTokenSupply - _poolToken.balanceOf(address(this)))\n            );\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function mint(address recipient, uint256 bntAmount)\n        external\n        onlyRoleMember(ROLE_BNT_MANAGER)\n        validAddress(recipient)\n        greaterThanZero(bntAmount)\n    {\n        _bntGovernance.mint(recipient, bntAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function burnFromVault(uint256 bntAmount) external onlyRoleMember(ROLE_VAULT_MANAGER) greaterThanZero(bntAmount) {\n        _masterVault.burn(Token(address(_bnt)), bntAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function depositFor(\n        bytes32 contextId,\n        address provider,\n        uint256 bntAmount,\n        bool isMigrating,\n        uint256 originalVBNTAmount\n    ) external only(address(_network)) validAddress(provider) greaterThanZero(bntAmount) returns (uint256) {\n        // calculate the pool token amount to transfer\n        uint256 poolTokenAmount = _underlyingToPoolToken(bntAmount);\n\n        // transfer pool tokens from the protocol to the provider. Please note that it's not possible to deposit\n        // liquidity requiring the protocol to transfer the provider more protocol tokens than it holds\n        _poolToken.transfer(provider, poolTokenAmount);\n\n        // burn the previously received BNT\n        _bntGovernance.burn(bntAmount);\n\n        uint256 vbntAmount = poolTokenAmount;\n\n        // the provider should receive pool tokens and VBNT in equal amounts. since the provider might already have\n        // some VBNT during migration, the contract only mints the delta between the full amount and the amount the\n        // provider already has\n        if (isMigrating) {\n            vbntAmount = MathEx.subMax0(vbntAmount, originalVBNTAmount);\n        }\n\n        // mint VBNT to the provider\n        if (vbntAmount > 0) {\n            _vbntGovernance.mint(provider, vbntAmount);\n        }\n\n        emit TokensDeposited({\n            contextId: contextId,\n            provider: provider,\n            bntAmount: bntAmount,\n            poolTokenAmount: poolTokenAmount,\n            vbntAmount: vbntAmount\n        });\n\n        return poolTokenAmount;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function withdraw(\n        bytes32 contextId,\n        address provider,\n        uint256 poolTokenAmount\n    ) external only(address(_network)) validAddress(provider) greaterThanZero(poolTokenAmount) returns (uint256) {\n        InternalWithdrawalAmounts memory amounts = _withdrawalAmounts(poolTokenAmount);\n\n        // get the pool tokens from the caller\n        _poolToken.transferFrom(msg.sender, address(this), poolTokenAmount);\n\n        // burn the respective VBNT amount\n        _vbntGovernance.burn(poolTokenAmount);\n\n        // mint BNT to the provider\n        _bntGovernance.mint(provider, amounts.bntAmount);\n\n        emit TokensWithdrawn({\n            contextId: contextId,\n            provider: provider,\n            bntAmount: amounts.bntAmount,\n            poolTokenAmount: poolTokenAmount,\n            vbntAmount: poolTokenAmount,\n            withdrawalFeeAmount: amounts.withdrawalFeeAmount\n        });\n\n        return amounts.bntAmount;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function withdrawalAmount(uint256 poolTokenAmount)\n        external\n        view\n        greaterThanZero(poolTokenAmount)\n        returns (uint256)\n    {\n        InternalWithdrawalAmounts memory amounts = _withdrawalAmounts(poolTokenAmount);\n\n        return amounts.bntAmount;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function requestFunding(\n        bytes32 contextId,\n        Token pool,\n        uint256 bntAmount\n    ) external onlyRoleMember(ROLE_FUNDING_MANAGER) poolWhitelisted(pool) greaterThanZero(bntAmount) {\n        uint256 currentFunding = _currentPoolFunding[pool];\n        uint256 fundingLimit = _networkSettings.poolFundingLimit(pool);\n        uint256 newFunding = currentFunding + bntAmount;\n\n        // verify that the new funding amount doesn't exceed the limit\n        if (newFunding > fundingLimit) {\n            revert FundingLimitExceeded();\n        }\n\n        // calculate the pool token amount to mint\n        uint256 currentStakedBalance = _stakedBalance;\n        uint256 poolTokenAmount;\n        uint256 poolTokenTotalSupply = _poolToken.totalSupply();\n        if (poolTokenTotalSupply == 0) {\n            // if this is the initial liquidity provision - use a one-to-one pool token to BNT rate\n            if (currentStakedBalance > 0) {\n                revert InvalidStakedBalance();\n            }\n\n            poolTokenAmount = bntAmount;\n        } else {\n            poolTokenAmount = _underlyingToPoolToken(bntAmount, poolTokenTotalSupply, currentStakedBalance);\n        }\n\n        // update the staked balance\n        uint256 newStakedBalance = currentStakedBalance + bntAmount;\n        _stakedBalance = newStakedBalance;\n\n        // update the current funding amount\n        _currentPoolFunding[pool] = newFunding;\n\n        // mint pool tokens to the protocol\n        _poolToken.mint(address(this), poolTokenAmount);\n\n        // mint BNT to the vault\n        _bntGovernance.mint(address(_masterVault), bntAmount);\n\n        emit FundingRequested({\n            contextId: contextId,\n            pool: pool,\n            bntAmount: bntAmount,\n            poolTokenAmount: poolTokenAmount\n        });\n\n        emit TotalLiquidityUpdated({\n            contextId: contextId,\n            liquidity: _bnt.balanceOf(address(_masterVault)),\n            stakedBalance: newStakedBalance,\n            poolTokenSupply: poolTokenTotalSupply + poolTokenAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function renounceFunding(\n        bytes32 contextId,\n        Token pool,\n        uint256 bntAmount\n    ) external onlyRoleMember(ROLE_FUNDING_MANAGER) poolWhitelisted(pool) greaterThanZero(bntAmount) {\n        uint256 currentStakedBalance = _stakedBalance;\n\n        // calculate the renounced amount to deduct from both the staked balance and current pool funding\n        uint256 currentFunding = _currentPoolFunding[pool];\n        uint256 reduceFundingAmount = Math.min(currentFunding, bntAmount);\n\n        // calculate the pool token amount to burn\n        uint256 poolTokenTotalSupply = _poolToken.totalSupply();\n        uint256 poolTokenAmount = _underlyingToPoolToken(\n            reduceFundingAmount,\n            poolTokenTotalSupply,\n            currentStakedBalance\n        );\n\n        // update the current pool funding. Note that the given amount can be higher than the funding amount but the\n        // request shouldn't fail (and the funding amount cannot get negative)\n        _currentPoolFunding[pool] = currentFunding - reduceFundingAmount;\n\n        // update the staked balance\n        uint256 newStakedBalance = currentStakedBalance - reduceFundingAmount;\n        _stakedBalance = newStakedBalance;\n\n        // burn pool tokens from the protocol\n        _poolToken.burn(poolTokenAmount);\n\n        // burn all BNT from the master vault\n        _masterVault.burn(Token(address(_bnt)), bntAmount);\n\n        emit FundingRenounced({\n            contextId: contextId,\n            pool: pool,\n            bntAmount: bntAmount,\n            poolTokenAmount: poolTokenAmount\n        });\n\n        emit TotalLiquidityUpdated({\n            contextId: contextId,\n            liquidity: _bnt.balanceOf(address(_masterVault)),\n            stakedBalance: newStakedBalance,\n            poolTokenSupply: poolTokenTotalSupply - poolTokenAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function onFeesCollected(\n        Token pool,\n        uint256 feeAmount,\n        bool isTradeFee\n    ) external only(address(_network)) validAddress(address(pool)) {\n        if (feeAmount == 0) {\n            return;\n        }\n\n        // increase the staked balance by the given amount\n        _stakedBalance += feeAmount;\n\n        if (isTradeFee) {\n            // increase the current funding for the specified pool by the given amount\n            _currentPoolFunding[pool] += feeAmount;\n        }\n    }\n\n    /**\n     * @dev converts the specified pool token amount to the underlying BNT amount\n     */\n    function _poolTokenToUnderlying(uint256 poolTokenAmount) private view returns (uint256) {\n        return MathEx.mulDivF(poolTokenAmount, _stakedBalance, _poolToken.totalSupply());\n    }\n\n    /**\n     * @dev converts the specified underlying BNT amount to pool token amount\n     */\n    function _underlyingToPoolToken(uint256 bntAmount) private view returns (uint256) {\n        return _underlyingToPoolToken(bntAmount, _poolToken.totalSupply(), _stakedBalance);\n    }\n\n    /**\n     * @dev converts the specified underlying BNT amount to pool token amount\n     */\n    function _underlyingToPoolToken(\n        uint256 bntAmount,\n        uint256 poolTokenTotalSupply,\n        uint256 currentStakedBalance\n    ) private pure returns (uint256) {\n        return MathEx.mulDivC(bntAmount, poolTokenTotalSupply, currentStakedBalance);\n    }\n\n    /**\n     * @dev returns withdrawal amounts\n     */\n    function _withdrawalAmounts(uint256 poolTokenAmount) internal view returns (InternalWithdrawalAmounts memory) {\n        // calculate BNT amount to transfer\n        uint256 bntAmount = _poolTokenToUnderlying(poolTokenAmount);\n\n        // deduct the exit fee from BNT amount\n        uint256 withdrawalFeeAmount = MathEx.mulDivF(bntAmount, _networkSettings.withdrawalFeePPM(), PPM_RESOLUTION);\n\n        bntAmount -= withdrawalFeeAmount;\n\n        return InternalWithdrawalAmounts({ bntAmount: bntAmount, withdrawalFeeAmount: withdrawalFeeAmount });\n    }\n}\n"
    },
    "contracts/helpers/TestMathEx.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { MathEx, Uint512 } from \"../utility/MathEx.sol\";\nimport { Fraction } from \"../utility/FractionLibrary.sol\";\n\ncontract TestMathEx {\n    function exp(Fraction memory f) external pure returns (Fraction memory) {\n        return MathEx.exp(f);\n    }\n\n    function reducedFraction(Fraction memory fraction, uint256 max) external pure returns (Fraction memory) {\n        return MathEx.reducedFraction(fraction, max);\n    }\n\n    function weightedAverage(\n        Fraction memory fraction1,\n        Fraction memory fraction2,\n        uint256 weight1,\n        uint256 weight2\n    ) external pure returns (Fraction memory) {\n        return MathEx.weightedAverage(fraction1, fraction2, weight1, weight2);\n    }\n\n    function isInRange(\n        Fraction memory baseSample,\n        Fraction memory offsetSample,\n        uint32 maxDeviationPPM\n    ) external pure returns (bool) {\n        return MathEx.isInRange(baseSample, offsetSample, maxDeviationPPM);\n    }\n\n    function mulDivF(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) external pure returns (uint256) {\n        return MathEx.mulDivF(x, y, z);\n    }\n\n    function mulDivC(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) external pure returns (uint256) {\n        return MathEx.mulDivC(x, y, z);\n    }\n\n    function subMax0(uint256 n1, uint256 n2) external pure returns (uint256) {\n        return MathEx.subMax0(n1, n2);\n    }\n\n    function mul512(uint256 x, uint256 y) external pure returns (Uint512 memory) {\n        return MathEx.mul512(x, y);\n    }\n\n    function gt512(Uint512 memory x, Uint512 memory y) external pure returns (bool) {\n        return MathEx.gt512(x, y);\n    }\n\n    function lt512(Uint512 memory x, Uint512 memory y) external pure returns (bool) {\n        return MathEx.lt512(x, y);\n    }\n\n    function gte512(Uint512 memory x, Uint512 memory y) external pure returns (bool) {\n        return MathEx.gte512(x, y);\n    }\n\n    function lte512(Uint512 memory x, Uint512 memory y) external pure returns (bool) {\n        return MathEx.lte512(x, y);\n    }\n}\n"
    },
    "contracts/helpers/TestFractionLibrary.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    Fraction,\n    Fraction112,\n    zeroFraction as _zeroFraction,\n    zeroFraction112 as _zeroFraction112,\n    FractionLibrary\n} from \"../utility/FractionLibrary.sol\";\n\ncontract TestFractionLibrary {\n    using FractionLibrary for Fraction;\n    using FractionLibrary for Fraction112;\n\n    function zeroFraction() external pure returns (Fraction memory) {\n        return _zeroFraction();\n    }\n\n    function zeroFraction112() external pure returns (Fraction112 memory) {\n        return _zeroFraction112();\n    }\n\n    function isValid256(Fraction memory fraction) external pure returns (bool) {\n        return fraction.isValid();\n    }\n\n    function isPositive256(Fraction memory fraction) external pure returns (bool) {\n        return fraction.isPositive();\n    }\n\n    function isValid112(Fraction112 memory fraction) external pure returns (bool) {\n        return fraction.isValid();\n    }\n\n    function isPositive112(Fraction112 memory fraction) external pure returns (bool) {\n        return fraction.isPositive();\n    }\n\n    function toFraction112(Fraction memory fraction) external pure returns (Fraction112 memory) {\n        return fraction.toFraction112();\n    }\n\n    function fromFraction112(Fraction112 memory fraction) external pure returns (Fraction memory) {\n        return fraction.fromFraction112();\n    }\n}\n"
    },
    "contracts/rewards/RewardsMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { Fraction } from \"../utility/FractionLibrary.sol\";\nimport { MathEx } from \"../utility/MathEx.sol\";\n\n/**\n * @dev This library supports the calculation of staking rewards\n */\nlibrary RewardsMath {\n    uint256 private constant LAMBDA_N = 142857142857143;\n    uint256 private constant LAMBDA_D = 10000000000000000000000;\n\n    /**\n     * @dev returns the amount of rewards distributed on a flat amount ratio\n     */\n    function calcFlatRewards(\n        uint256 totalRewards,\n        uint32 timeElapsed,\n        uint32 programDuration\n    ) internal pure returns (uint256) {\n        assert(timeElapsed <= programDuration);\n        return MathEx.mulDivF(totalRewards, timeElapsed, programDuration);\n    }\n\n    /**\n     * @dev returns the amount of rewards distributed after a given time period since deployment has elapsed\n     * The returned value is calculated as `totalRewards * (1 - 1 / e ^ (timeElapsed * LAMBDA))`.\n     * Note that because the exponentiation function is limited to an input of up to (and excluding) 16, the\n     * input value to this function is limited by `timeElapsed * LAMBDA < 16` --> `timeElapsed < 1120000000`.\n     * For `timeElapsed = 1120000000 - 1`, the formula above returns more than 99.9999% of `totalRewards`.\n     */\n    function calcExpDecayRewards(uint256 totalRewards, uint32 timeElapsed) internal pure returns (uint256) {\n        Fraction memory input = Fraction({ n: timeElapsed * LAMBDA_N, d: LAMBDA_D });\n        Fraction memory output = MathEx.exp(input);\n        return MathEx.mulDivF(totalRewards, output.n - output.d, output.n);\n    }\n}\n"
    },
    "contracts/rewards/AutoCompoundingRewards.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { EnumerableSetUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, AccessDenied, DoesNotExist, AlreadyExists, InvalidParam } from \"../utility/Utils.sol\";\nimport { Time } from \"../utility/Time.sol\";\n\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IVault } from \"../vaults/interfaces/IVault.sol\";\nimport { IExternalRewardsVault } from \"../vaults/interfaces/IExternalRewardsVault.sol\";\n\n// prettier-ignore\nimport {\n    IAutoCompoundingRewards,\n    ProgramData,\n    FLAT_DISTRIBUTION,\n    EXPONENTIAL_DECAY_DISTRIBUTION\n} from \"./interfaces/IAutoCompoundingRewards.sol\";\n\nimport { RewardsMath } from \"./RewardsMath.sol\";\n\n/**\n * @dev Auto-compounding Rewards contract\n */\ncontract AutoCompoundingRewards is IAutoCompoundingRewards, ReentrancyGuardUpgradeable, Utils, Time, Upgradeable {\n    using TokenLibrary for Token;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    error InsufficientFunds();\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the BNT contract\n    IERC20 private immutable _bnt;\n\n    // the BNT pool contract\n    IBNTPool private immutable _bntPool;\n\n    // the BNT pool token contract\n    IPoolToken private immutable _bntPoolToken;\n\n    // the address of the external rewards vault\n    IExternalRewardsVault private immutable _externalRewardsVault;\n\n    // a mapping between pools and programs\n    mapping(Token => ProgramData) private _programs;\n\n    // a set of all pools that have a rewards program associated with them\n    EnumerableSetUpgradeable.AddressSet private _pools;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 3] private __gap;\n\n    /**\n     * @dev triggered when a program is created\n     */\n    event ProgramCreated(\n        Token indexed pool,\n        uint8 indexed distributionType,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 endTime\n    );\n\n    /**\n     * @dev triggered when a program is terminated prematurely\n     */\n    event ProgramTerminated(Token indexed pool, uint32 endTime, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when a program is enabled/disabled\n     */\n    event ProgramEnabled(Token indexed pool, bool status, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when rewards are distributed\n     */\n    event RewardsDistributed(\n        Token indexed pool,\n        uint256 rewardsAmount,\n        uint256 poolTokenAmount,\n        uint256 remainingRewards\n    );\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        INetworkSettings initNetworkSettings,\n        IERC20 initBNT,\n        IBNTPool initBNTPool,\n        IExternalRewardsVault initExternalRewardsVault\n    )\n        validAddress(address(initNetwork))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initBNT))\n        validAddress(address(initBNTPool))\n        validAddress(address(initExternalRewardsVault))\n    {\n        _network = initNetwork;\n        _networkSettings = initNetworkSettings;\n        _bnt = initBNT;\n        _bntPool = initBNTPool;\n        _bntPoolToken = initBNTPool.poolToken();\n        _externalRewardsVault = initExternalRewardsVault;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __AutoCompoundingRewards_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __AutoCompoundingRewards_init() internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __Upgradeable_init();\n\n        __AutoCompoundingRewards_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __AutoCompoundingRewards_init_unchained() internal onlyInitializing {}\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function program(Token pool) external view returns (ProgramData memory) {\n        return _programs[pool];\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function programs() external view returns (ProgramData[] memory) {\n        uint256 numPrograms = _pools.length();\n\n        ProgramData[] memory list = new ProgramData[](numPrograms);\n        for (uint256 i = 0; i < numPrograms; i++) {\n            list[i] = _programs[Token(_pools.at(i))];\n        }\n\n        return list;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function pools() external view returns (address[] memory) {\n        return _pools.values();\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function isProgramActive(Token pool) external view returns (bool) {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            return false;\n        }\n\n        uint32 currTime = _time();\n\n        if (p.distributionType == EXPONENTIAL_DECAY_DISTRIBUTION) {\n            return p.startTime <= currTime;\n        }\n\n        return p.startTime <= currTime && currTime <= p.endTime;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function createProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint8 distributionType,\n        uint32 startTime,\n        uint32 endTime\n    ) external validAddress(address(pool)) greaterThanZero(totalRewards) onlyAdmin nonReentrant {\n        if (_doesProgramExist(_programs[pool])) {\n            revert AlreadyExists();\n        }\n\n        IPoolToken poolToken;\n        if (pool.isEqual(_bnt)) {\n            poolToken = _bntPoolToken;\n        } else {\n            if (!_networkSettings.isTokenWhitelisted(pool)) {\n                revert NotWhitelisted();\n            }\n\n            poolToken = _network.collectionByPool(pool).poolToken(pool);\n        }\n\n        uint32 currTime = _time();\n        if (distributionType == FLAT_DISTRIBUTION) {\n            if (!(currTime <= startTime && startTime < endTime)) {\n                revert InvalidParam();\n            }\n        } else if (distributionType == EXPONENTIAL_DECAY_DISTRIBUTION) {\n            if (!(currTime <= startTime && endTime == 0)) {\n                revert InvalidParam();\n            }\n        } else {\n            revert InvalidParam();\n        }\n\n        ProgramData memory p = ProgramData({\n            startTime: startTime,\n            endTime: endTime,\n            prevDistributionTimestamp: 0,\n            poolToken: poolToken,\n            isEnabled: true,\n            distributionType: distributionType,\n            totalRewards: totalRewards,\n            remainingRewards: totalRewards\n        });\n\n        _verifyFunds(_poolTokenAmountToBurn(pool, p, totalRewards), poolToken, _rewardsVault(pool));\n\n        _programs[pool] = p;\n\n        assert(_pools.add(address(pool)));\n\n        emit ProgramCreated({\n            pool: pool,\n            distributionType: distributionType,\n            totalRewards: totalRewards,\n            startTime: startTime,\n            endTime: endTime\n        });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function terminateProgram(Token pool) external onlyAdmin {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            revert DoesNotExist();\n        }\n\n        delete _programs[pool];\n\n        assert(_pools.remove(address(pool)));\n\n        emit ProgramTerminated({ pool: pool, endTime: p.endTime, remainingRewards: p.remainingRewards });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function enableProgram(Token pool, bool status) external onlyAdmin {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            revert DoesNotExist();\n        }\n\n        bool prevStatus = p.isEnabled;\n        if (prevStatus == status) {\n            return;\n        }\n\n        _programs[pool].isEnabled = status;\n\n        emit ProgramEnabled({ pool: pool, status: status, remainingRewards: p.remainingRewards });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function processRewards(Token pool) external nonReentrant {\n        ProgramData memory p = _programs[pool];\n\n        uint32 currTime = _time();\n\n        if (!p.isEnabled || currTime < p.startTime) {\n            return;\n        }\n\n        uint256 tokenAmountToDistribute = _tokenAmountToDistribute(p, currTime);\n        if (tokenAmountToDistribute == 0) {\n            return;\n        }\n\n        uint256 poolTokenAmountToBurn = _poolTokenAmountToBurn(pool, p, tokenAmountToDistribute);\n        if (poolTokenAmountToBurn == 0) {\n            return;\n        }\n\n        IVault rewardsVault = _rewardsVault(pool);\n        _verifyFunds(poolTokenAmountToBurn, p.poolToken, rewardsVault);\n        rewardsVault.burn(Token(address(p.poolToken)), poolTokenAmountToBurn);\n\n        p.remainingRewards -= tokenAmountToDistribute;\n        p.prevDistributionTimestamp = currTime;\n\n        _programs[pool] = p;\n\n        emit RewardsDistributed({\n            pool: pool,\n            rewardsAmount: tokenAmountToDistribute,\n            poolTokenAmount: poolTokenAmountToBurn,\n            remainingRewards: p.remainingRewards\n        });\n    }\n\n    /**\n     * @dev returns the amount of tokens to distribute\n     */\n    function _tokenAmountToDistribute(ProgramData memory p, uint32 currTime) private pure returns (uint256) {\n        uint32 prevTime = uint32(Math.max(p.prevDistributionTimestamp, p.startTime));\n\n        if (p.distributionType == FLAT_DISTRIBUTION) {\n            uint32 currTimeElapsed = uint32(Math.min(currTime, p.endTime)) - p.startTime;\n            uint32 prevTimeElapsed = uint32(Math.min(prevTime, p.endTime)) - p.startTime;\n            return\n                RewardsMath.calcFlatRewards(p.totalRewards, currTimeElapsed - prevTimeElapsed, p.endTime - p.startTime);\n        } else {\n            // if (p.distributionType == EXPONENTIAL_DECAY_DISTRIBUTION)\n            uint32 currTimeElapsed = currTime - p.startTime;\n            uint32 prevTimeElapsed = prevTime - p.startTime;\n            return\n                RewardsMath.calcExpDecayRewards(p.totalRewards, currTimeElapsed) -\n                RewardsMath.calcExpDecayRewards(p.totalRewards, prevTimeElapsed);\n        }\n    }\n\n    /**\n     * @dev returns the amount of pool tokens to burn\n     */\n    function _poolTokenAmountToBurn(\n        Token pool,\n        ProgramData memory p,\n        uint256 tokenAmountToDistribute\n    ) private view returns (uint256) {\n        if (pool.isEqual(_bnt)) {\n            return _bntPool.poolTokenAmountToBurn(tokenAmountToDistribute);\n        }\n\n        return\n            _network.collectionByPool(pool).poolTokenAmountToBurn(\n                pool,\n                tokenAmountToDistribute,\n                p.poolToken.balanceOf(address(_externalRewardsVault))\n            );\n    }\n\n    /**\n     * @dev returns whether or not a given program exists\n     */\n    function _doesProgramExist(ProgramData memory p) private pure returns (bool) {\n        return address(p.poolToken) != address(0);\n    }\n\n    /**\n     * @dev returns the rewards vault for a given pool\n     */\n    function _rewardsVault(Token pool) private view returns (IVault) {\n        return pool.isEqual(_bnt) ? IVault(_bntPool) : IVault(_externalRewardsVault);\n    }\n\n    /**\n     * @dev verifies that the rewards vault holds a sufficient amount of pool tokens\n     */\n    function _verifyFunds(\n        uint256 requiredAmount,\n        IPoolToken poolToken,\n        IVault rewardsVault\n    ) private view {\n        if (requiredAmount > poolToken.balanceOf(address(rewardsVault))) {\n            revert InsufficientFunds();\n        }\n    }\n}\n"
    },
    "contracts/rewards/interfaces/IAutoCompoundingRewards.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IUpgradeable } from \"../../utility/interfaces/IUpgradeable.sol\";\n\nimport { IPoolToken } from \"../../pools/interfaces/IPoolToken.sol\";\n\nimport { Token } from \"../../token/Token.sol\";\n\n// distribution types\nuint8 constant FLAT_DISTRIBUTION = 0;\nuint8 constant EXPONENTIAL_DECAY_DISTRIBUTION = 1;\n\nstruct ProgramData {\n    uint32 startTime;\n    uint32 endTime;\n    uint32 prevDistributionTimestamp;\n    IPoolToken poolToken;\n    bool isEnabled;\n    uint8 distributionType;\n    uint256 totalRewards;\n    uint256 remainingRewards;\n}\n\ninterface IAutoCompoundingRewards is IUpgradeable {\n    /**\n     * @dev returns the program data of a pool\n     */\n    function program(Token pool) external view returns (ProgramData memory);\n\n    /**\n     * @dev returns a list of all pools' program data\n     */\n    function programs() external view returns (ProgramData[] memory);\n\n    /**\n     * @dev returns a list of all the pools which have a program associated with them\n     */\n    function pools() external view returns (address[] memory);\n\n    /**\n     * @dev returns whether a program is currently active\n     */\n    function isProgramActive(Token pool) external view returns (bool);\n\n    /**\n     * @dev creates a program for a pool\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     * - the pool must not have an active program\n     */\n    function createProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint8 distributionType,\n        uint32 startTime,\n        uint32 endTime\n    ) external;\n\n    /**\n     * @dev terminates a rewards program\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     * - the program must be active\n     */\n    function terminateProgram(Token pool) external;\n\n    /**\n     * @dev enables or disables a program\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function enableProgram(Token pool, bool status) external;\n\n    /**\n     * @dev processes program rewards\n     */\n    function processRewards(Token pool) external;\n}\n"
    },
    "contracts/helpers/TestAutoCompoundingRewards.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { Time } from \"../utility/Time.sol\";\n\nimport { AutoCompoundingRewards } from \"../rewards/AutoCompoundingRewards.sol\";\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings } from \"../network/interfaces/INetworkSettings.sol\";\n\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { IExternalRewardsVault } from \"../vaults/interfaces/IExternalRewardsVault.sol\";\n\nimport { TestTime } from \"./TestTime.sol\";\n\ncontract TestAutoCompoundingRewards is AutoCompoundingRewards, TestTime {\n    constructor(\n        IBancorNetwork initNetwork,\n        INetworkSettings initNetworkSettings,\n        IERC20 initBNT,\n        IBNTPool initBNTPool,\n        IExternalRewardsVault initExternalRewardsVault\n    ) AutoCompoundingRewards(initNetwork, initNetworkSettings, initBNT, initBNTPool, initExternalRewardsVault) {}\n\n    function _time() internal view virtual override(Time, TestTime) returns (uint32) {\n        return TestTime._time();\n    }\n}\n"
    },
    "contracts/helpers/TestTokenLibrary.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary, Signature } from \"../token/TokenLibrary.sol\";\n\ncontract TestTokenLibrary {\n    using TokenLibrary for Token;\n\n    receive() external payable {}\n\n    function isNative(Token token) external pure returns (bool) {\n        return token.isNative();\n    }\n\n    function symbol(Token token) external view returns (string memory) {\n        return token.symbol();\n    }\n\n    function decimals(Token token) external view returns (uint8) {\n        return token.decimals();\n    }\n\n    function balanceOf(Token token, address account) external view returns (uint256) {\n        return token.balanceOf(account);\n    }\n\n    function safeTransfer(\n        Token token,\n        address to,\n        uint256 amount\n    ) external {\n        token.safeTransfer(to, amount);\n    }\n\n    function safeTransferFrom(\n        Token token,\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    function safeApprove(\n        Token token,\n        address spender,\n        uint256 amount\n    ) external {\n        token.safeApprove(spender, amount);\n    }\n\n    function ensureApprove(\n        Token token,\n        address spender,\n        uint256 amount\n    ) external {\n        token.ensureApprove(spender, amount);\n    }\n\n    function permit(\n        Token token,\n        address owner,\n        address spender,\n        uint256 tokenAmount,\n        uint256 deadline,\n        Signature memory signature\n    ) external {\n        token.permit(owner, spender, tokenAmount, deadline, signature);\n    }\n\n    function isEqual(Token token, IERC20 erc20Token) external pure returns (bool) {\n        return token.isEqual(erc20Token);\n    }\n}\n"
    },
    "contracts/helpers/TestSafeERC20Ex.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { SafeERC20Ex } from \"../token/SafeERC20Ex.sol\";\n\ncontract TestSafeERC20Ex {\n    using SafeERC20Ex for IERC20;\n\n    function ensureApprove(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) external {\n        token.ensureApprove(spender, amount);\n    }\n}\n"
    },
    "contracts/helpers/TestGovernedToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IMintableToken } from \"@bancor/token-governance/contracts/IMintableToken.sol\";\n\nimport { TestERC20Token } from \"./TestERC20Token.sol\";\n\ncontract TestGovernedToken is IMintableToken, TestERC20Token {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply\n    ) TestERC20Token(name, symbol, totalSupply) {\n        _mint(msg.sender, totalSupply);\n    }\n\n    function issue(address recipient, uint256 amount) external {\n        _mint(recipient, amount);\n    }\n\n    function destroy(address account, uint256 amount) external {\n        _burn(account, amount);\n    }\n\n    function owner() external pure returns (address) {\n        return address(0);\n    }\n\n    function transferOwnership(address newOwner) external {}\n\n    function acceptOwnership() external {}\n}\n"
    },
    "contracts/helpers/TestERC20Token.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract TestERC20Token is ERC20Permit {\n    uint8 private _decimals = 18;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply\n    ) ERC20(name, symbol) ERC20Permit(name) {\n        _mint(msg.sender, totalSupply);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    function updateDecimals(uint8 newDecimals) external {\n        _decimals = newDecimals;\n    }\n}\n"
    },
    "contracts/helpers/TestERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { ERC20Burnable } from \"../token/ERC20Burnable.sol\";\n\nimport { TestERC20Token } from \"./TestERC20Token.sol\";\n\ncontract TestERC20Burnable is TestERC20Token, ERC20Burnable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply\n    ) TestERC20Token(name, symbol, totalSupply) {}\n\n    function decimals() public view virtual override(ERC20, TestERC20Token) returns (uint8) {\n        return TestERC20Token.decimals();\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "contracts/helpers/MockUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { Utils } from \"../utility/Utils.sol\";\n\nimport { MockUniswapV2Pair } from \"./MockUniswapV2Pair.sol\";\nimport { TestERC20Token } from \"./TestERC20Token.sol\";\n\ncontract MockUniswapV2Factory is TestERC20Token, Utils {\n    using SafeERC20 for IERC20;\n    using TokenLibrary for Token;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet private _tokens;\n    MockUniswapV2Pair private _pair;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply,\n        MockUniswapV2Pair pair\n    ) TestERC20Token(name, symbol, totalSupply) {\n        _pair = pair;\n    }\n\n    function getPair(address token0, address token1) external view returns (address) {\n        if (_tokens.contains(token0) && _tokens.contains(token1)) {\n            return address(_pair);\n        }\n        return address(0);\n    }\n\n    function setTokens(address token0, address token1) external {\n        _tokens.add(token0);\n        _tokens.add(token1);\n    }\n}\n"
    },
    "contracts/helpers/MockUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { IUniswapV2Pair } from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport { IUniswapV2Router02 } from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { Utils } from \"../utility/Utils.sol\";\n\nimport { TestERC20Token } from \"./TestERC20Token.sol\";\n\ncontract MockUniswapV2Pair is TestERC20Token, Utils {\n    using SafeERC20 for IERC20;\n    using TokenLibrary for Token;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply\n    ) TestERC20Token(name, symbol, totalSupply) {}\n\n    Token public token0;\n    Token public token1;\n\n    function setTokens(Token token0_, Token token1_) external {\n        token0 = token0_;\n        token1 = token1_;\n    }\n\n    function burn(address to, uint256 amount) external {\n        Token[2] memory tokens = [token0, token1];\n\n        for (uint256 i = 0; i < 2; i++) {\n            if (tokens[i].isNative()) {\n                payable(address(to)).transfer(amount);\n            } else {\n                tokens[i].safeTransfer(to, amount);\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/helpers/MockUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { MockUniswapV2Pair } from \"./MockUniswapV2Pair.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { Utils } from \"../utility/Utils.sol\";\n\nimport { TestERC20Token } from \"./TestERC20Token.sol\";\n\ncontract MockUniswapV2Router02 is TestERC20Token, Utils {\n    using SafeERC20 for IERC20;\n    using TokenLibrary for Token;\n\n    MockUniswapV2Pair private _pair;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply,\n        MockUniswapV2Pair pair\n    ) TestERC20Token(name, symbol, totalSupply) {\n        _pair = pair;\n    }\n\n    function removeLiquidity(\n        address, /*tokenA*/\n        address, /*tokenB*/\n        uint256 liquidity,\n        uint256, /*amountAMin*/\n        uint256, /*amountBMin*/\n        address, /*to*/\n        uint256 /*deadline*/\n    ) external returns (uint256 amountA, uint256 amountB) {\n        // mimic approval\n        Token(address(_pair)).safeTransferFrom(msg.sender, address(_pair), liquidity);\n        // mimic Uniswap burn\n        _pair.burn(msg.sender, liquidity);\n\n        amountA = liquidity;\n        amountB = liquidity;\n    }\n\n    function removeLiquidityETH(\n        address, /*token*/\n        uint256 liquidity,\n        uint256, /*amountTokenMin*/\n        uint256, /*amountETHMin*/\n        address, /*to*/\n        uint256 /*deadline*/\n    ) external returns (uint256 amountToken, uint256 amountETH) {\n        // mimic approval\n        Token(address(_pair)).safeTransferFrom(msg.sender, address(_pair), liquidity);\n\n        // mimic Uniswap burn\n        _pair.burn(msg.sender, liquidity);\n\n        amountToken = liquidity;\n        amountETH = liquidity;\n    }\n}\n"
    },
    "contracts/helpers/TestTokenGovernance.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ITokenGovernance, IMintableToken } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { AccessControlEnumerable } from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\nimport { AccessDenied } from \"../utility/Utils.sol\";\n\ncontract TestTokenGovernance is ITokenGovernance, AccessControlEnumerable {\n    bytes32 public constant ROLE_SUPERVISOR = keccak256(\"ROLE_SUPERVISOR\");\n    bytes32 public constant ROLE_GOVERNOR = keccak256(\"ROLE_GOVERNOR\");\n    bytes32 public constant ROLE_MINTER = keccak256(\"ROLE_MINTER\");\n\n    IMintableToken private immutable _token;\n\n    constructor(IMintableToken mintableToken) {\n        _token = mintableToken;\n\n        _setRoleAdmin(ROLE_SUPERVISOR, ROLE_SUPERVISOR);\n        _setRoleAdmin(ROLE_GOVERNOR, ROLE_SUPERVISOR);\n        _setRoleAdmin(ROLE_MINTER, ROLE_GOVERNOR);\n\n        _setupRole(ROLE_SUPERVISOR, _msgSender());\n    }\n\n    function token() external view returns (IMintableToken) {\n        return _token;\n    }\n\n    function acceptTokenOwnership() external {\n        if (!hasRole(ROLE_SUPERVISOR, _msgSender())) {\n            revert AccessDenied();\n        }\n\n        _token.acceptOwnership();\n    }\n\n    function mint(address to, uint256 amount) external override {\n        if (!hasRole(ROLE_MINTER, _msgSender())) {\n            revert AccessDenied();\n        }\n\n        _token.issue(to, amount);\n    }\n\n    function burn(uint256 amount) external override {\n        _token.destroy(_msgSender(), amount);\n    }\n}\n"
    },
    "contracts/helpers/TestVault.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { Vault } from \"../vaults/Vault.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\n\ncontract TestVault is Vault {\n    bool private _isAuthorizedWithdrawal;\n    bool private _isPayable;\n\n    uint256[MAX_GAP - 1] private __gap;\n\n    constructor(ITokenGovernance initBNTGovernance, ITokenGovernance initVBNTGovernance)\n        Vault(initBNTGovernance, initVBNTGovernance)\n    {}\n\n    function initialize() external initializer {\n        __TestVault_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    function __TestVault_init() internal onlyInitializing {\n        __Vault_init();\n\n        __TestVault_init_unchained();\n    }\n\n    function __TestVault_init_unchained() internal onlyInitializing {}\n\n    // solhint-enable func-name-mixedcase\n\n    function setAuthorizedWithdrawal(bool state) external {\n        _isAuthorizedWithdrawal = state;\n    }\n\n    function setPayable(bool state) external {\n        _isPayable = state;\n    }\n\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    function isPayable() public view override returns (bool) {\n        return _isPayable;\n    }\n\n    function isAuthorizedWithdrawal(\n        address, /* caller */\n        Token, /* reserverToken */\n        address, /* target */\n        uint256 /* amount */\n    ) internal view override returns (bool) {\n        return _isAuthorizedWithdrawal;\n    }\n}\n"
    },
    "contracts/helpers/TestUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\n\ncontract TestUpgradeable is Upgradeable {\n    uint16 private _version;\n\n    function initialize() external initializer {\n        __TestUpgradeable_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    function __TestUpgradeable_init() internal onlyInitializing {\n        __Upgradeable_init();\n\n        __TestUpgradeable_init_unchained();\n    }\n\n    function __TestUpgradeable_init_unchained() internal onlyInitializing {\n        _version = 1;\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    function version() public view override(Upgradeable) returns (uint16) {\n        return _version;\n    }\n\n    function setVersion(uint16 newVersion) external {\n        _version = newVersion;\n    }\n\n    function initializations() external view returns (uint16) {\n        return _initializations;\n    }\n\n    function setInitializations(uint16 newInitializations) external {\n        _initializations = newInitializations;\n    }\n\n    function restricted() external view onlyAdmin {}\n}\n"
    },
    "contracts/helpers/TestLogic.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\n\ncontract TestLogic is Upgradeable {\n    bool private _initializedLogic;\n    uint256 private _data;\n    uint16 private immutable _version;\n\n    uint256[MAX_GAP - 1] private __gap;\n\n    event Upgraded(uint16 newVersion, uint256 arg1, bool arg2, string arg3);\n\n    constructor(uint16 initVersion) {\n        _version = initVersion;\n    }\n\n    function initialize() external initializer {\n        __TestLogic_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    function __TestLogic_init() internal onlyInitializing {\n        __TestLogic_init_unchained();\n    }\n\n    function __TestLogic_init_unchained() internal onlyInitializing {\n        _initializedLogic = true;\n\n        _data = 100;\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    function initialized() external view returns (bool) {\n        return _initializedLogic;\n    }\n\n    function version() public view override returns (uint16) {\n        return _version;\n    }\n\n    function data() external view returns (uint256) {\n        return _data;\n    }\n\n    function setData(uint16 newData) external {\n        _data = newData;\n    }\n}\n"
    },
    "contracts/helpers/TesrBNTPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings } from \"../network/interfaces/INetworkSettings.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { BNTPool } from \"../pools/BNTPool.sol\";\n\ncontract TestBNTPool is BNTPool {\n    constructor(\n        IBancorNetwork initNetwork,\n        ITokenGovernance initBNTGovernance,\n        ITokenGovernance initVBNTGovernance,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IPoolToken initBNTPoolToken\n    )\n        BNTPool(\n            initNetwork,\n            initBNTGovernance,\n            initVBNTGovernance,\n            initNetworkSettings,\n            initMasterVault,\n            initBNTPoolToken\n        )\n    {}\n\n    function mintPoolTokenT(address recipient, uint256 poolTokenAmount) external {\n        return _poolToken.mint(recipient, poolTokenAmount);\n    }\n\n    function burnPoolTokenT(uint256 poolTokenAmount) external {\n        return _poolToken.burn(poolTokenAmount);\n    }\n}\n"
    },
    "contracts/helpers/RewardsMath.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { RewardsMath } from \"../rewards/RewardsMath.sol\";\n\ncontract TestRewardsMath {\n    function calcFlatRewards(\n        uint256 totalRewards,\n        uint32 timeElapsed,\n        uint32 programDuration\n    ) external pure returns (uint256) {\n        return RewardsMath.calcFlatRewards(totalRewards, timeElapsed, programDuration);\n    }\n\n    function calcExpDecayRewards(uint256 totalRewards, uint32 timeElapsed) external pure returns (uint256) {\n        return RewardsMath.calcExpDecayRewards(totalRewards, timeElapsed);\n    }\n}\n"
    },
    "contracts/helpers/TestOwned.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Owned } from \"../utility/Owned.sol\";\n\ncontract TestOwned is Owned {}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}